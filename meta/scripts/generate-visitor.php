<?php

use Symfony\Component\Yaml\Yaml;

require_once __DIR__ . '/../vendor/autoload.php';

class VisitorMut
{
    const VISITOR_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    #![allow(unused_variables)]

    use pxp_ast::*;
    use crate::walk_mut::*;
    use pxp_span::Span;
    use pxp_syntax::comments::Comment;
    use pxp_type::Type;

    pub trait VisitorMut {
        fn visit(&mut self, node: &mut [Statement]) {
            walk_mut(self, node);
        }

        %s
    }
    EOF;

    const WALK_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.

    use crate::visitor_mut::VisitorMut;
    use pxp_ast::*;

    pub fn walk_mut<V: VisitorMut + ?Sized>(visitor: &mut V, node: &mut [Statement]) {
        for statement in node {
            visitor.visit_statement(statement);
        }
    }

    %s
    EOF;

    const FILENAME = "visitor_mut.rs";
    const WALKERS = "walk_mut.rs";
    const NODE = "&mut ";
}

class Visitor
{
    const VISITOR_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    #![allow(unused_variables)]

    use pxp_ast::*;
    use crate::walk::*;
    use pxp_span::Span;
    use pxp_syntax::comments::Comment;
    use pxp_type::Type;

    pub trait Visitor {
        fn visit(&mut self, node: &[Statement]) {
            walk(self, node);
        }

        %s
    }
    EOF;

    const WALK_TEMPLATE = <<<'EOF'
    // This file is automatically generated by the generate-visitor.php script.
    // Do not modify this file directly.
    
    use crate::visitor::Visitor;
    use pxp_ast::*;

    pub fn walk<V: Visitor + ?Sized>(visitor: &mut V, node: &[Statement]) {
        for statement in node {
            visitor.visit_statement(statement);
        }
    }

    %s
    EOF;

    const FILENAME = "visitor.rs";
    const WALKERS = "walk.rs";
    const NODE = "&";
}

function main() {
    $yaml = Yaml::parseFile(__DIR__ . '/../../crates/pxp-ast/meta/ast.yaml');

    foreach ([VisitorMut::class, Visitor::class] as $trait) {
        $methods = generate_methods($yaml, $trait);
        $generated = sprintf($trait::VISITOR_TEMPLATE, implode("\n\n", $methods));    

        file_put_contents(__DIR__ . '/../../crates/pxp-visitor/src/' . $trait::FILENAME, $generated);

        echo "Generated " . class_basename($trait) . ".\n";

        $walkers = generate_walkers($yaml, $trait);
        $generated = sprintf($trait::WALK_TEMPLATE, implode("\n\n", $walkers));

        file_put_contents(__DIR__ . '/../../crates/pxp-visitor/src/' . $trait::WALKERS, $generated);

        echo "Generated walkers for " . class_basename($trait) . ".\n";
    }
}

function generate_walkers(array $yaml, string $trait): array
{
    $walkers = [];
    $trait = class_basename($trait);

    foreach ($yaml as $type => $fields) {
        if (is_string($fields)) {
            continue;
        }

        $enum = isset($fields['as']) && $fields['as'] === 'Enum';
        $fields = get_visitable_fields($fields);

        if (count($fields) === 0) {
            continue;
        }

        $function = sprintf("pub fn %s<V: %s + ?Sized>(visitor: &mut V, node: %s%s) {\n", type_name_to_walk_method($type), class_basename($trait), $trait::NODE, strip_type_to_root($type));

        if ($enum) {

        } else {
            foreach ($fields as $field => $type) {
                if (in_array($type, ['CommentGroup', 'BackedEnumType', 'Type', 'Span', 'Symbol', 'Token', 'bool', 'NameQualification'])) {
                    continue;
                }

                if (is_string($type) && is_simple($type)) {
                    $function .= sprintf("    visitor.%s(%snode.%s);\n", type_name_to_method($type), $trait::NODE, $field);
                }

                if (is_string($type) && is_vec($type)) {
                    $function .= sprintf("    for item in %snode.%s {\n", $trait::NODE, $field);
                    $function .= sprintf("        visitor.%s(item);\n", type_name_to_method($type));
                    $function .= '}';
                }

                if (is_string($type) && is_option($type)) {
                    $function .= sprintf("    if let Some(item) = %snode.%s {\n", $trait::NODE, $field);
                    $function .= sprintf("        visitor.%s(item);\n", type_name_to_method($type));
                    $function .= '}';
                }

                if (is_string($type) && is_comma_separated($type)) {
                    $function .= sprintf("    for item in %snode.%s.inner {\n", $trait::NODE, $field);
                    $function .= sprintf("        visitor.%s(item);\n", type_name_to_method(strip_option($type)));
                    $function .= '}';
                }
            }
        }

        $function .= "}";

        $walkers[] = $function;
    }

    return $walkers;
}

function generate_methods(array $yaml, string $trait): array
{
    $methods = [];

    foreach ($yaml as $type => $fields) {
        // Type alias.
        if (is_string($fields)) {
            continue;
        }

        $method = sprintf("fn %s(&mut self, node: %s%s) {\n", type_name_to_method($type), $trait::NODE, strip_type_to_root($type));
        $fields = get_visitable_fields($fields);

        if (count($fields) === 0) {
            goto end_method;
        }

        $method .= sprintf("   %s(self, node);\n", type_name_to_walk_method($type));

        end_method:
        $method .= "}\n";
        $methods[] = $method;
    }

    return $methods;
}

function strip_type_to_root(string $type): string
{
    return str($type)->afterLast('<')->before('>');
}

function get_visitable_fields(array $fields): array
{
    $reserved = ['as', 'derive'];

    return collect($fields)
        ->filter(function ($field, string $key) use ($reserved) {
            if (in_array($key, $reserved, true)) {
                return false;
            }

            if (is_string($field) && ($field === 'Span' || strip_type_to_root($field) === 'Span')) {
                return false;
            }

            if (is_string($field) && ($field === 'Token' || strip_type_to_root($field) === 'Token')) {
                return false;
            }

            if (is_string($field) && $field === 'bool') {
                return false;
            }

            return true;
        })
        ->all();
}

function type_name_to_method(string $type): string {
    if ($type === 'Block') {
        return 'visit';
    }

    return str(strip_type_to_root($type))->snake()->prepend('visit_');
}

function type_name_to_walk_method(string $type): string {
    return str(strip_type_to_root($type))->snake()->prepend('walk_');
}

function is_simple(string $type): bool {
    return !is_vec($type) && !is_option($type) && !is_comma_separated($type);
}

function is_comma_separated(string $type): bool {
    return str($type)->contains('CommaSeparated<');
}

function is_vec(string $type): bool {
    return str($type)->startsWith('Vec<');
}

function is_option(string $type): bool {
    return str($type)->startsWith('Option<');
}

function strip_option(string $type): string {
    return str($type)->after('Option<')->beforeLast('>');
}

main();