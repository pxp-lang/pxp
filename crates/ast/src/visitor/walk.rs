// This file is automatically generated by the generate-visitor.php script.
// Do not modify this file directly.
#![allow(unused, clippy::single_match)]

use super::Visitor;
use crate::*;

pub fn walk<V: Visitor + ?Sized>(visitor: &mut V, node: &[Statement]) {
    for statement in node {
        visitor.visit_statement(statement);
    }
}

pub fn walk_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &Statement) {
    visitor.visit_statement_kind(&node.kind);
}

pub fn walk_statement_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &StatementKind) {
    match node {
        StatementKind::FullOpeningTag(inner) => visitor.visit_full_opening_tag_statement(inner),
        StatementKind::ShortOpeningTag(inner) => visitor.visit_short_opening_tag_statement(inner),
        StatementKind::EchoOpeningTag(inner) => visitor.visit_echo_opening_tag_statement(inner),
        StatementKind::ClosingTag(inner) => visitor.visit_closing_tag_statement(inner),
        StatementKind::InlineHtml(inner) => visitor.visit_inline_html_statement(inner),
        StatementKind::Label(inner) => visitor.visit_label_statement(inner),
        StatementKind::Goto(inner) => visitor.visit_goto_statement(inner),
        StatementKind::HaltCompiler(inner) => visitor.visit_halt_compiler_statement(inner),
        StatementKind::Static(inner) => visitor.visit_static_statement(inner),
        StatementKind::DoWhile(inner) => visitor.visit_do_while_statement(inner),
        StatementKind::While(inner) => visitor.visit_while_statement(inner),
        StatementKind::For(inner) => visitor.visit_for_statement(inner),
        StatementKind::Foreach(inner) => visitor.visit_foreach_statement(inner),
        StatementKind::Break(inner) => visitor.visit_break_statement(inner),
        StatementKind::Continue(inner) => visitor.visit_continue_statement(inner),
        StatementKind::Constant(inner) => visitor.visit_constant_statement(inner),
        StatementKind::Function(inner) => visitor.visit_function_statement(inner),
        StatementKind::Class(inner) => visitor.visit_class_statement(inner),
        StatementKind::Trait(inner) => visitor.visit_trait_statement(inner),
        StatementKind::Interface(inner) => visitor.visit_interface_statement(inner),
        StatementKind::If(inner) => visitor.visit_if_statement(inner),
        StatementKind::Switch(inner) => visitor.visit_switch_statement(inner),
        StatementKind::Echo(inner) => visitor.visit_echo_statement(inner),
        StatementKind::Expression(inner) => visitor.visit_expression_statement(inner),
        StatementKind::Return(inner) => visitor.visit_return_statement(inner),
        StatementKind::Namespace(inner) => visitor.visit_namespace_statement(inner),
        StatementKind::Use(inner) => visitor.visit_use_statement(inner),
        StatementKind::GroupUse(inner) => visitor.visit_group_use_statement(inner),
        StatementKind::Try(inner) => visitor.visit_try_statement(inner),
        StatementKind::UnitEnum(inner) => visitor.visit_unit_enum_statement(inner),
        StatementKind::BackedEnum(inner) => visitor.visit_backed_enum_statement(inner),
        StatementKind::Block(inner) => visitor.visit_block_statement(inner),
        StatementKind::Global(inner) => visitor.visit_global_statement(inner),
        StatementKind::Declare(inner) => visitor.visit_declare_statement(inner),
        _ => {}
    }
}

pub fn walk_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &Expression) {
    visitor.visit_expression_kind(&node.kind);
}

pub fn walk_expression_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &ExpressionKind) {
    match node {
        ExpressionKind::Missing(inner) => visitor.visit_missing_expression(inner),
        ExpressionKind::Eval(inner) => visitor.visit_eval_expression(inner),
        ExpressionKind::Empty(inner) => visitor.visit_empty_expression(inner),
        ExpressionKind::Die(inner) => visitor.visit_die_expression(inner),
        ExpressionKind::Exit(inner) => visitor.visit_exit_expression(inner),
        ExpressionKind::Isset(inner) => visitor.visit_isset_expression(inner),
        ExpressionKind::Unset(inner) => visitor.visit_unset_expression(inner),
        ExpressionKind::Print(inner) => visitor.visit_print_expression(inner),
        ExpressionKind::Literal(inner) => visitor.visit_literal(inner),
        ExpressionKind::ArithmeticOperation(inner) => {
            visitor.visit_arithmetic_operation_expression(inner)
        }
        ExpressionKind::AssignmentOperation(inner) => {
            visitor.visit_assignment_operation_expression(inner)
        }
        ExpressionKind::BitwiseOperation(inner) => {
            visitor.visit_bitwise_operation_expression(inner)
        }
        ExpressionKind::ComparisonOperation(inner) => {
            visitor.visit_comparison_operation_expression(inner)
        }
        ExpressionKind::LogicalOperation(inner) => {
            visitor.visit_logical_operation_expression(inner)
        }
        ExpressionKind::Concat(inner) => visitor.visit_concat_expression(inner),
        ExpressionKind::Instanceof(inner) => visitor.visit_instanceof_expression(inner),
        ExpressionKind::Reference(inner) => visitor.visit_reference_expression(inner),
        ExpressionKind::Parenthesized(inner) => visitor.visit_parenthesized_expression(inner),
        ExpressionKind::ErrorSuppress(inner) => visitor.visit_error_suppress_expression(inner),
        ExpressionKind::Identifier(inner) => visitor.visit_identifier(inner),
        ExpressionKind::Variable(inner) => visitor.visit_variable(inner),
        ExpressionKind::Include(inner) => visitor.visit_include_expression(inner),
        ExpressionKind::IncludeOnce(inner) => visitor.visit_include_once_expression(inner),
        ExpressionKind::Require(inner) => visitor.visit_require_expression(inner),
        ExpressionKind::RequireOnce(inner) => visitor.visit_require_once_expression(inner),
        ExpressionKind::FunctionCall(inner) => visitor.visit_function_call_expression(inner),
        ExpressionKind::FunctionClosureCreation(inner) => {
            visitor.visit_function_closure_creation_expression(inner)
        }
        ExpressionKind::MethodCall(inner) => visitor.visit_method_call_expression(inner),
        ExpressionKind::MethodClosureCreation(inner) => {
            visitor.visit_method_closure_creation_expression(inner)
        }
        ExpressionKind::NullsafeMethodCall(inner) => {
            visitor.visit_nullsafe_method_call_expression(inner)
        }
        ExpressionKind::StaticMethodCall(inner) => {
            visitor.visit_static_method_call_expression(inner)
        }
        ExpressionKind::StaticVariableMethodCall(inner) => {
            visitor.visit_static_variable_method_call_expression(inner)
        }
        ExpressionKind::StaticMethodClosureCreation(inner) => {
            visitor.visit_static_method_closure_creation_expression(inner)
        }
        ExpressionKind::StaticVariableMethodClosureCreation(inner) => {
            visitor.visit_static_variable_method_closure_creation_expression(inner)
        }
        ExpressionKind::PropertyFetch(inner) => visitor.visit_property_fetch_expression(inner),
        ExpressionKind::NullsafePropertyFetch(inner) => {
            visitor.visit_nullsafe_property_fetch_expression(inner)
        }
        ExpressionKind::StaticPropertyFetch(inner) => {
            visitor.visit_static_property_fetch_expression(inner)
        }
        ExpressionKind::ConstantFetch(inner) => visitor.visit_constant_fetch_expression(inner),
        ExpressionKind::Static(inner) => visitor.visit_static_expression(inner),
        ExpressionKind::Self_(inner) => visitor.visit_self_expression(inner),
        ExpressionKind::Parent(inner) => visitor.visit_parent_expression(inner),
        ExpressionKind::ShortArray(inner) => visitor.visit_short_array_expression(inner),
        ExpressionKind::Array(inner) => visitor.visit_array_expression(inner),
        ExpressionKind::List(inner) => visitor.visit_list_expression(inner),
        ExpressionKind::Closure(inner) => visitor.visit_closure_expression(inner),
        ExpressionKind::ArrowFunction(inner) => visitor.visit_arrow_function_expression(inner),
        ExpressionKind::New(inner) => visitor.visit_new_expression(inner),
        ExpressionKind::InterpolatedString(inner) => {
            visitor.visit_interpolated_string_expression(inner)
        }
        ExpressionKind::Heredoc(inner) => visitor.visit_heredoc_expression(inner),
        ExpressionKind::Nowdoc(inner) => visitor.visit_nowdoc_expression(inner),
        ExpressionKind::ShellExec(inner) => visitor.visit_shell_exec_expression(inner),
        ExpressionKind::AnonymousClass(inner) => visitor.visit_anonymous_class_expression(inner),
        ExpressionKind::Bool(inner) => visitor.visit_bool_expression(inner),
        ExpressionKind::ArrayIndex(inner) => visitor.visit_array_index_expression(inner),
        ExpressionKind::MagicConstant(inner) => visitor.visit_magic_constant_expression(inner),
        ExpressionKind::ShortTernary(inner) => visitor.visit_short_ternary_expression(inner),
        ExpressionKind::Ternary(inner) => visitor.visit_ternary_expression(inner),
        ExpressionKind::Coalesce(inner) => visitor.visit_coalesce_expression(inner),
        ExpressionKind::Clone(inner) => visitor.visit_clone_expression(inner),
        ExpressionKind::Match(inner) => visitor.visit_match_expression(inner),
        ExpressionKind::Throw(inner) => visitor.visit_throw_expression(inner),
        ExpressionKind::Yield(inner) => visitor.visit_yield_expression(inner),
        ExpressionKind::YieldFrom(inner) => visitor.visit_yield_from_expression(inner),
        ExpressionKind::Cast(inner) => visitor.visit_cast_expression(inner),
        ExpressionKind::Name(inner) => visitor.visit_name(inner),
        _ => {}
    }
}

pub fn walk_expression_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ExpressionStatement) {
    visitor.visit_expression(&node.expression);
    visitor.visit_ending(&node.ending);
}

pub fn walk_global_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &GlobalStatement) {
    for item in &node.variables {
        visitor.visit_variable(item);
    }
}

pub fn walk_block_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &BlockStatement) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_case<V: Visitor + ?Sized>(visitor: &mut V, node: &Case) {
    if let Some(item) = &node.condition {
        visitor.visit_expression(item);
    }
    visitor.visit(&node.body);
}

pub fn walk_use<V: Visitor + ?Sized>(visitor: &mut V, node: &Use) {
    visitor.visit_name(&node.name);
    if let Some(item) = &node.alias {
        visitor.visit_simple_identifier(item);
    }
    visitor.visit_use_kind(&node.kind);
}

pub fn walk_use_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &UseKind) {
    match node {
        UseKind::Normal => {}
        UseKind::Function => {}
        UseKind::Const => {}
        _ => {}
    }
}

pub fn walk_eval_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &EvalExpression) {
    visitor.visit_single_argument(&node.argument);
}

pub fn walk_empty_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &EmptyExpression) {
    visitor.visit_single_argument(&node.argument);
}

pub fn walk_die_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &DieExpression) {
    if let Some(item) = &node.argument {
        visitor.visit_single_argument(item);
    }
}

pub fn walk_exit_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ExitExpression) {
    if let Some(item) = &node.argument {
        visitor.visit_single_argument(item);
    }
}

pub fn walk_isset_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &IssetExpression) {
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_unset_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &UnsetExpression) {
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_print_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &PrintExpression) {
    if let Some(item) = &node.value {
        visitor.visit_expression(item);
    }
    if let Some(item) = &node.argument {
        visitor.visit_single_argument(item);
    }
}

pub fn walk_concat_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ConcatExpression) {
    visitor.visit_expression(&node.left);
    visitor.visit_expression(&node.right);
}

pub fn walk_instanceof_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &InstanceofExpression,
) {
    visitor.visit_expression(&node.left);
    visitor.visit_expression(&node.right);
}

pub fn walk_reference_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ReferenceExpression) {
    visitor.visit_expression(&node.right);
}

pub fn walk_parenthesized_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ParenthesizedExpression,
) {
    visitor.visit_expression(&node.expr);
}

pub fn walk_error_suppress_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ErrorSuppressExpression,
) {
    visitor.visit_expression(&node.expr);
}

pub fn walk_include_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &IncludeExpression) {
    visitor.visit_expression(&node.path);
}

pub fn walk_include_once_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &IncludeOnceExpression,
) {
    visitor.visit_expression(&node.path);
}

pub fn walk_require_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &RequireExpression) {
    visitor.visit_expression(&node.path);
}

pub fn walk_require_once_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &RequireOnceExpression,
) {
    visitor.visit_expression(&node.path);
}

pub fn walk_function_call_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &FunctionCallExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_function_closure_creation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &FunctionClosureCreationExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_argument_placeholder(&node.placeholder);
}

pub fn walk_method_call_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &MethodCallExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_expression(&node.method);
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_method_closure_creation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &MethodClosureCreationExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_expression(&node.method);
    visitor.visit_argument_placeholder(&node.placeholder);
}

pub fn walk_nullsafe_method_call_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &NullsafeMethodCallExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_expression(&node.method);
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_static_method_call_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &StaticMethodCallExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_identifier(&node.method);
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_static_variable_method_call_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &StaticVariableMethodCallExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_variable(&node.method);
    visitor.visit_argument_list(&node.arguments);
}

pub fn walk_static_method_closure_creation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &StaticMethodClosureCreationExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_identifier(&node.method);
    visitor.visit_argument_placeholder(&node.placeholder);
}

pub fn walk_static_variable_method_closure_creation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &StaticVariableMethodClosureCreationExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_variable(&node.method);
    visitor.visit_argument_placeholder(&node.placeholder);
}

pub fn walk_property_fetch_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &PropertyFetchExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_expression(&node.property);
}

pub fn walk_nullsafe_property_fetch_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &NullsafePropertyFetchExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_expression(&node.property);
}

pub fn walk_static_property_fetch_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &StaticPropertyFetchExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_variable(&node.property);
}

pub fn walk_constant_fetch_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ConstantFetchExpression,
) {
    visitor.visit_expression(&node.target);
    visitor.visit_identifier(&node.constant);
}

pub fn walk_short_array_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ShortArrayExpression,
) {
    for item in &node.items.inner {
        visitor.visit_array_item(item);
    }
}

pub fn walk_array_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ArrayExpression) {
    for item in &node.items.inner {
        visitor.visit_array_item(item);
    }
}

pub fn walk_list_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ListExpression) {
    for item in &node.items {
        visitor.visit_list_entry(item);
    }
}

pub fn walk_new_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &NewExpression) {
    visitor.visit_expression(&node.target);
    if let Some(item) = &node.arguments {
        visitor.visit_argument_list(item);
    }
}

pub fn walk_interpolated_string_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &InterpolatedStringExpression,
) {
    for item in &node.parts {
        visitor.visit_string_part(item);
    }
}

pub fn walk_heredoc_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &HeredocExpression) {
    for item in &node.parts {
        visitor.visit_string_part(item);
    }
}

pub fn walk_shell_exec_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ShellExecExpression,
) {
    for item in &node.parts {
        visitor.visit_string_part(item);
    }
}

pub fn walk_array_index_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArrayIndexExpression,
) {
    visitor.visit_expression(&node.array);
    if let Some(item) = &node.index {
        visitor.visit_expression(item);
    }
}

pub fn walk_short_ternary_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ShortTernaryExpression,
) {
    visitor.visit_expression(&node.condition);
    visitor.visit_expression(&node.r#else);
}

pub fn walk_ternary_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &TernaryExpression) {
    visitor.visit_expression(&node.condition);
    visitor.visit_expression(&node.then);
    visitor.visit_expression(&node.r#else);
}

pub fn walk_coalesce_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &CoalesceExpression) {
    visitor.visit_expression(&node.lhs);
    visitor.visit_expression(&node.rhs);
}

pub fn walk_clone_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &CloneExpression) {
    visitor.visit_expression(&node.target);
}

pub fn walk_match_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &MatchExpression) {
    visitor.visit_expression(&node.condition);
    if let Some(item) = &node.default {
        visitor.visit_default_match_arm(item);
    }
    for item in &node.arms {
        visitor.visit_match_arm(item);
    }
}

pub fn walk_throw_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ThrowExpression) {
    visitor.visit_expression(&node.value);
}

pub fn walk_yield_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &YieldExpression) {
    if let Some(item) = &node.key {
        visitor.visit_expression(item);
    }
    if let Some(item) = &node.value {
        visitor.visit_expression(item);
    }
}

pub fn walk_yield_from_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &YieldFromExpression,
) {
    visitor.visit_expression(&node.value);
}

pub fn walk_cast_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &CastExpression) {
    visitor.visit_cast_kind(&node.kind);
    visitor.visit_expression(&node.value);
}

pub fn walk_default_match_arm<V: Visitor + ?Sized>(visitor: &mut V, node: &DefaultMatchArm) {
    visitor.visit_expression(&node.body);
}

pub fn walk_match_arm<V: Visitor + ?Sized>(visitor: &mut V, node: &MatchArm) {
    for item in &node.conditions {
        visitor.visit_expression(item);
    }
    visitor.visit_expression(&node.body);
}

pub fn walk_magic_constant_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &MagicConstantExpression,
) {
    visitor.visit_magic_constant_kind(&node.kind);
}

pub fn walk_magic_constant_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &MagicConstantKind) {
    match node {
        MagicConstantKind::Directory => {}
        MagicConstantKind::File => {}
        MagicConstantKind::Line => {}
        MagicConstantKind::Function => {}
        MagicConstantKind::Class => {}
        MagicConstantKind::Method => {}
        MagicConstantKind::Namespace => {}
        MagicConstantKind::Trait => {}
        MagicConstantKind::CompilerHaltOffset => {}
        _ => {}
    }
}

pub fn walk_string_part<V: Visitor + ?Sized>(visitor: &mut V, node: &StringPart) {
    match node {
        StringPart::Literal(inner) => visitor.visit_literal_string_part(inner),
        StringPart::Expression(inner) => visitor.visit_expression_string_part(inner),
        _ => {}
    }
}

pub fn walk_expression_string_part<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ExpressionStringPart,
) {
    visitor.visit_expression(&node.expression);
}

pub fn walk_array_item<V: Visitor + ?Sized>(visitor: &mut V, node: &ArrayItem) {
    match node {
        ArrayItem::Value(inner) => visitor.visit_array_item_value(inner),
        ArrayItem::ReferencedValue(inner) => visitor.visit_array_item_referenced_value(inner),
        ArrayItem::SpreadValue(inner) => visitor.visit_array_item_spread_value(inner),
        ArrayItem::KeyValue(inner) => visitor.visit_array_item_key_value(inner),
        ArrayItem::ReferencedKeyValue(inner) => {
            visitor.visit_array_item_referenced_key_value(inner)
        }
        _ => {}
    }
}

pub fn walk_array_item_value<V: Visitor + ?Sized>(visitor: &mut V, node: &ArrayItemValue) {
    visitor.visit_expression(&node.value);
}

pub fn walk_array_item_referenced_value<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArrayItemReferencedValue,
) {
    visitor.visit_expression(&node.value);
}

pub fn walk_array_item_spread_value<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArrayItemSpreadValue,
) {
    visitor.visit_expression(&node.value);
}

pub fn walk_array_item_key_value<V: Visitor + ?Sized>(visitor: &mut V, node: &ArrayItemKeyValue) {
    visitor.visit_expression(&node.key);
    visitor.visit_expression(&node.value);
}

pub fn walk_array_item_referenced_key_value<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArrayItemReferencedKeyValue,
) {
    visitor.visit_expression(&node.key);
    visitor.visit_expression(&node.value);
}

pub fn walk_list_entry<V: Visitor + ?Sized>(visitor: &mut V, node: &ListEntry) {
    match node {
        ListEntry::Value(inner) => visitor.visit_list_entry_value(inner),
        ListEntry::KeyValue(inner) => visitor.visit_list_entry_key_value(inner),
        _ => {}
    }
}

pub fn walk_list_entry_value<V: Visitor + ?Sized>(visitor: &mut V, node: &ListEntryValue) {
    visitor.visit_expression(&node.value);
}

pub fn walk_list_entry_key_value<V: Visitor + ?Sized>(visitor: &mut V, node: &ListEntryKeyValue) {
    visitor.visit_expression(&node.key);
    visitor.visit_expression(&node.value);
}

pub fn walk_positional_argument<V: Visitor + ?Sized>(visitor: &mut V, node: &PositionalArgument) {
    visitor.visit_expression(&node.value);
}

pub fn walk_named_argument<V: Visitor + ?Sized>(visitor: &mut V, node: &NamedArgument) {
    visitor.visit_simple_identifier(&node.name);
    visitor.visit_expression(&node.value);
}

pub fn walk_argument<V: Visitor + ?Sized>(visitor: &mut V, node: &Argument) {
    match node {
        Argument::Positional(inner) => visitor.visit_positional_argument(inner),
        Argument::Named(inner) => visitor.visit_named_argument(inner),
        _ => {}
    }
}

pub fn walk_argument_list<V: Visitor + ?Sized>(visitor: &mut V, node: &ArgumentList) {
    for item in &node.arguments {
        visitor.visit_argument(item);
    }
}

pub fn walk_single_argument<V: Visitor + ?Sized>(visitor: &mut V, node: &SingleArgument) {
    if let Some(item) = &node.argument {
        visitor.visit_argument(item);
    }
}

pub fn walk_attribute<V: Visitor + ?Sized>(visitor: &mut V, node: &Attribute) {
    visitor.visit_name(&node.name);
    if let Some(item) = &node.arguments {
        visitor.visit_argument_list(item);
    }
}

pub fn walk_attribute_group<V: Visitor + ?Sized>(visitor: &mut V, node: &AttributeGroup) {
    for item in &node.members {
        visitor.visit_attribute(item);
    }
}

pub fn walk_class_body<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassBody) {
    for item in &node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_class_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassStatement) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_class_modifier_group(&node.modifiers);
    visitor.visit_name(&node.name);
    if let Some(item) = &node.extends {
        visitor.visit_class_extends(item);
    }
    if let Some(item) = &node.implements {
        visitor.visit_class_implements(item);
    }
    visitor.visit_class_body(&node.body);
}

pub fn walk_anonymous_class_body<V: Visitor + ?Sized>(visitor: &mut V, node: &AnonymousClassBody) {
    for item in &node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_anonymous_class_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &AnonymousClassExpression,
) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    if let Some(item) = &node.extends {
        visitor.visit_class_extends(item);
    }
    if let Some(item) = &node.implements {
        visitor.visit_class_implements(item);
    }
    visitor.visit_anonymous_class_body(&node.body);
}

pub fn walk_class_extends<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassExtends) {
    visitor.visit_name(&node.parent);
}

pub fn walk_class_implements<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassImplements) {
    for item in &node.interfaces.inner {
        visitor.visit_name(item);
    }
}

pub fn walk_classish_member<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassishMember) {
    match node {
        ClassishMember::Constant(inner) => visitor.visit_classish_constant(inner),
        ClassishMember::TraitUsage(inner) => visitor.visit_trait_usage(inner),
        ClassishMember::Property(inner) => visitor.visit_property(inner),
        ClassishMember::Method(inner) => visitor.visit_method(inner),
        ClassishMember::Missing(inner) => visitor.visit_missing_classish_member(inner),
        _ => {}
    }
}

pub fn walk_method<V: Visitor + ?Sized>(visitor: &mut V, node: &Method) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_method_modifier_group(&node.modifiers);
    visitor.visit_simple_identifier(&node.name);
    visitor.visit_method_parameter_list(&node.parameters);
    if let Some(item) = &node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_method_body(&node.body);
}

pub fn walk_method_body<V: Visitor + ?Sized>(visitor: &mut V, node: &MethodBody) {
    visitor.visit_method_body_kind(&node.kind);
}

pub fn walk_method_body_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &MethodBodyKind) {
    match node {
        MethodBodyKind::Abstract(inner) => visitor.visit_abstract_method_body(inner),
        MethodBodyKind::Concrete(inner) => visitor.visit_concrete_method_body(inner),
        MethodBodyKind::Missing(inner) => visitor.visit_missing_method_body(inner),
        _ => {}
    }
}

pub fn walk_concrete_method_body<V: Visitor + ?Sized>(visitor: &mut V, node: &ConcreteMethodBody) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_method_parameter_list<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &MethodParameterList,
) {
    for item in &node.parameters.inner {
        visitor.visit_method_parameter(item);
    }
}

pub fn walk_method_parameter<V: Visitor + ?Sized>(visitor: &mut V, node: &MethodParameter) {
    if let Some(item) = &node.modifiers {
        visitor.visit_promoted_property_modifier_group(item);
    }
    visitor.visit_simple_variable(&node.name);
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.default {
        visitor.visit_expression(item);
    }
}

pub fn walk_constant_entry<V: Visitor + ?Sized>(visitor: &mut V, node: &ConstantEntry) {
    visitor.visit_name(&node.name);
    visitor.visit_expression(&node.value);
}

pub fn walk_classish_constant_entry<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ClassishConstantEntry,
) {
    visitor.visit_simple_identifier(&node.name);
    visitor.visit_expression(&node.value);
}

pub fn walk_constant_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ConstantStatement) {
    for item in &node.entries {
        visitor.visit_constant_entry(item);
    }
}

pub fn walk_classish_constant<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassishConstant) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_constant_modifier_group(&node.modifiers);
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
    for item in &node.entries {
        visitor.visit_classish_constant_entry(item);
    }
}

pub fn walk_if_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &IfStatement) {
    visitor.visit_expression(&node.condition);
    visitor.visit_if_statement_body(&node.body);
}

pub fn walk_if_statement_body<V: Visitor + ?Sized>(visitor: &mut V, node: &IfStatementBody) {
    match node {
        IfStatementBody::Statement(inner) => visitor.visit_if_statement_body_statement(inner),
        IfStatementBody::Block(inner) => visitor.visit_if_statement_body_block(inner),
        _ => {}
    }
}

pub fn walk_if_statement_body_statement<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &IfStatementBodyStatement,
) {
    visitor.visit_statement(&node.statement);
    for item in &node.elseifs {
        visitor.visit_if_statement_else_if(item);
    }
    if let Some(item) = &node.r#else {
        visitor.visit_if_statement_else(item);
    }
}

pub fn walk_if_statement_body_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &IfStatementBodyBlock,
) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
    for item in &node.elseifs {
        visitor.visit_if_statement_else_if_block(item);
    }
    if let Some(item) = &node.r#else {
        visitor.visit_if_statement_else_block(item);
    }
    visitor.visit_ending(&node.ending);
}

pub fn walk_if_statement_else_if<V: Visitor + ?Sized>(visitor: &mut V, node: &IfStatementElseIf) {
    visitor.visit_expression(&node.condition);
    visitor.visit_statement(&node.statement);
}

pub fn walk_if_statement_else<V: Visitor + ?Sized>(visitor: &mut V, node: &IfStatementElse) {
    visitor.visit_statement(&node.statement);
}

pub fn walk_if_statement_else_if_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &IfStatementElseIfBlock,
) {
    visitor.visit_expression(&node.condition);
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_if_statement_else_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &IfStatementElseBlock,
) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_data_type<V: Visitor + ?Sized>(visitor: &mut V, node: &DataType) {}

pub fn walk_declare_entry<V: Visitor + ?Sized>(visitor: &mut V, node: &DeclareEntry) {
    visitor.visit_simple_identifier(&node.key);
    visitor.visit_literal(&node.value);
}

pub fn walk_declare_entry_group<V: Visitor + ?Sized>(visitor: &mut V, node: &DeclareEntryGroup) {
    for item in &node.entries {
        visitor.visit_declare_entry(item);
    }
}

pub fn walk_declare_body<V: Visitor + ?Sized>(visitor: &mut V, node: &DeclareBody) {
    match node {
        DeclareBody::Noop(inner) => visitor.visit_declare_body_noop(inner),
        DeclareBody::Braced(inner) => visitor.visit_declare_body_braced(inner),
        DeclareBody::Expression(inner) => visitor.visit_declare_body_expression(inner),
        DeclareBody::Block(inner) => visitor.visit_declare_body_block(inner),
        _ => {}
    }
}

pub fn walk_declare_body_braced<V: Visitor + ?Sized>(visitor: &mut V, node: &DeclareBodyBraced) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_declare_body_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &DeclareBodyExpression,
) {
    visitor.visit_expression(&node.expression);
}

pub fn walk_declare_body_block<V: Visitor + ?Sized>(visitor: &mut V, node: &DeclareBodyBlock) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_declare_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &DeclareStatement) {
    visitor.visit_declare_entry_group(&node.entries);
    visitor.visit_declare_body(&node.body);
}

pub fn walk_unit_enum_case<V: Visitor + ?Sized>(visitor: &mut V, node: &UnitEnumCase) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_simple_identifier(&node.name);
}

pub fn walk_unit_enum_member<V: Visitor + ?Sized>(visitor: &mut V, node: &UnitEnumMember) {
    match node {
        UnitEnumMember::Case(inner) => visitor.visit_unit_enum_case(inner),
        UnitEnumMember::Classish(inner) => visitor.visit_classish_member(inner),
        _ => {}
    }
}

pub fn walk_unit_enum_body<V: Visitor + ?Sized>(visitor: &mut V, node: &UnitEnumBody) {
    for item in &node.members {
        visitor.visit_unit_enum_member(item);
    }
}

pub fn walk_unit_enum_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &UnitEnumStatement) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&node.name);
    for item in &node.implements {
        visitor.visit_name(item);
    }
    visitor.visit_unit_enum_body(&node.body);
}

pub fn walk_backed_enum_case<V: Visitor + ?Sized>(visitor: &mut V, node: &BackedEnumCase) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_simple_identifier(&node.name);
    visitor.visit_expression(&node.value);
}

pub fn walk_backed_enum_member<V: Visitor + ?Sized>(visitor: &mut V, node: &BackedEnumMember) {
    match node {
        BackedEnumMember::Case(inner) => visitor.visit_backed_enum_case(inner),
        BackedEnumMember::Classish(inner) => visitor.visit_classish_member(inner),
        _ => {}
    }
}

pub fn walk_backed_enum_body<V: Visitor + ?Sized>(visitor: &mut V, node: &BackedEnumBody) {
    for item in &node.members {
        visitor.visit_backed_enum_member(item);
    }
}

pub fn walk_backed_enum_statement<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &BackedEnumStatement,
) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&node.name);
    for item in &node.implements {
        visitor.visit_name(item);
    }
    visitor.visit_backed_enum_body(&node.body);
}

pub fn walk_backed_enum_type<V: Visitor + ?Sized>(visitor: &mut V, node: &BackedEnumType) {
    match node {
        BackedEnumType::Invalid => {}
        _ => {}
    }
}

pub fn walk_return_type<V: Visitor + ?Sized>(visitor: &mut V, node: &ReturnType) {
    visitor.visit_data_type(&node.data_type);
}

pub fn walk_function_parameter<V: Visitor + ?Sized>(visitor: &mut V, node: &FunctionParameter) {
    visitor.visit_simple_variable(&node.name);
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.default {
        visitor.visit_expression(item);
    }
}

pub fn walk_function_parameter_list<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &FunctionParameterList,
) {
    for item in &node.parameters.inner {
        visitor.visit_function_parameter(item);
    }
}

pub fn walk_function_body<V: Visitor + ?Sized>(visitor: &mut V, node: &FunctionBody) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_function_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &FunctionStatement) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&node.name);
    visitor.visit_function_parameter_list(&node.parameters);
    if let Some(item) = &node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_function_body(&node.body);
}

pub fn walk_closure_use_variable<V: Visitor + ?Sized>(visitor: &mut V, node: &ClosureUseVariable) {
    visitor.visit_simple_variable(&node.variable);
}

pub fn walk_closure_use<V: Visitor + ?Sized>(visitor: &mut V, node: &ClosureUse) {
    for item in &node.variables.inner {
        visitor.visit_closure_use_variable(item);
    }
}

pub fn walk_closure_expression<V: Visitor + ?Sized>(visitor: &mut V, node: &ClosureExpression) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_function_parameter_list(&node.parameters);
    if let Some(item) = &node.uses {
        visitor.visit_closure_use(item);
    }
    if let Some(item) = &node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_function_body(&node.body);
}

pub fn walk_arrow_function_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArrowFunctionExpression,
) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_function_parameter_list(&node.parameters);
    if let Some(item) = &node.return_type {
        visitor.visit_return_type(item);
    }
    visitor.visit_expression(&node.body);
}

pub fn walk_label_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &LabelStatement) {
    visitor.visit_simple_identifier(&node.label);
}

pub fn walk_goto_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &GotoStatement) {
    visitor.visit_simple_identifier(&node.label);
}

pub fn walk_identifier<V: Visitor + ?Sized>(visitor: &mut V, node: &Identifier) {
    match node {
        Identifier::SimpleIdentifier(inner) => visitor.visit_simple_identifier(inner),
        Identifier::DynamicIdentifier(inner) => visitor.visit_dynamic_identifier(inner),
        _ => {}
    }
}

pub fn walk_dynamic_identifier<V: Visitor + ?Sized>(visitor: &mut V, node: &DynamicIdentifier) {
    visitor.visit_expression(&node.expr);
}

pub fn walk_interface_extends<V: Visitor + ?Sized>(visitor: &mut V, node: &InterfaceExtends) {
    for item in &node.parents.inner {
        visitor.visit_name(item);
    }
}

pub fn walk_interface_body<V: Visitor + ?Sized>(visitor: &mut V, node: &InterfaceBody) {
    for item in &node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_interface_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &InterfaceStatement) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_name(&node.name);
    if let Some(item) = &node.extends {
        visitor.visit_interface_extends(item);
    }
    visitor.visit_interface_body(&node.body);
}

pub fn walk_literal<V: Visitor + ?Sized>(visitor: &mut V, node: &Literal) {
    visitor.visit_literal_kind(&node.kind);
}

pub fn walk_literal_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &LiteralKind) {
    match node {
        LiteralKind::Integer => {}
        LiteralKind::Float => {}
        LiteralKind::String => {}
        LiteralKind::Missing => {}
        _ => {}
    }
}

pub fn walk_foreach_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ForeachStatement) {
    visitor.visit_foreach_statement_iterator(&node.iterator);
    visitor.visit_foreach_statement_body(&node.body);
}

pub fn walk_foreach_statement_iterator<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForeachStatementIterator,
) {
    match node {
        ForeachStatementIterator::Value(inner) => {
            visitor.visit_foreach_statement_iterator_value(inner)
        }
        ForeachStatementIterator::KeyAndValue(inner) => {
            visitor.visit_foreach_statement_iterator_key_and_value(inner)
        }
        _ => {}
    }
}

pub fn walk_foreach_statement_iterator_value<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForeachStatementIteratorValue,
) {
    visitor.visit_expression(&node.expression);
    visitor.visit_expression(&node.value);
}

pub fn walk_foreach_statement_iterator_key_and_value<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForeachStatementIteratorKeyAndValue,
) {
    visitor.visit_expression(&node.expression);
    visitor.visit_expression(&node.key);
    visitor.visit_expression(&node.value);
}

pub fn walk_foreach_statement_body<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForeachStatementBody,
) {
    match node {
        ForeachStatementBody::Statement(inner) => {
            visitor.visit_foreach_statement_body_statement(inner)
        }
        ForeachStatementBody::Block(inner) => visitor.visit_foreach_statement_body_block(inner),
        _ => {}
    }
}

pub fn walk_foreach_statement_body_statement<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForeachStatementBodyStatement,
) {
    visitor.visit_statement(&node.statement);
}

pub fn walk_foreach_statement_body_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForeachStatementBodyBlock,
) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
    visitor.visit_ending(&node.ending);
}

pub fn walk_for_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ForStatement) {
    visitor.visit_for_statement_iterator(&node.iterator);
    visitor.visit_for_statement_body(&node.body);
}

pub fn walk_for_statement_iterator<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForStatementIterator,
) {
    for item in &node.initializations.inner {
        visitor.visit_expression(item);
    }
    for item in &node.conditions.inner {
        visitor.visit_expression(item);
    }
    for item in &node.r#loop.inner {
        visitor.visit_expression(item);
    }
}

pub fn walk_for_statement_body<V: Visitor + ?Sized>(visitor: &mut V, node: &ForStatementBody) {
    match node {
        ForStatementBody::Statement(inner) => visitor.visit_for_statement_body_statement(inner),
        ForStatementBody::Block(inner) => visitor.visit_for_statement_body_block(inner),
        _ => {}
    }
}

pub fn walk_for_statement_body_statement<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForStatementBodyStatement,
) {
    visitor.visit_statement(&node.statement);
}

pub fn walk_for_statement_body_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ForStatementBodyBlock,
) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
    visitor.visit_ending(&node.ending);
}

pub fn walk_do_while_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &DoWhileStatement) {
    visitor.visit_statement(&node.body);
    visitor.visit_expression(&node.condition);
}

pub fn walk_while_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &WhileStatement) {
    visitor.visit_expression(&node.condition);
    visitor.visit_while_statement_body(&node.body);
}

pub fn walk_while_statement_body<V: Visitor + ?Sized>(visitor: &mut V, node: &WhileStatementBody) {
    match node {
        WhileStatementBody::Statement(inner) => visitor.visit_while_statement_body_statement(inner),
        WhileStatementBody::Block(inner) => visitor.visit_while_statement_body_block(inner),
        _ => {}
    }
}

pub fn walk_while_statement_body_statement<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &WhileStatementBodyStatement,
) {
    visitor.visit_statement(&node.statement);
}

pub fn walk_while_statement_body_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &WhileStatementBodyBlock,
) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
    visitor.visit_ending(&node.ending);
}

pub fn walk_level<V: Visitor + ?Sized>(visitor: &mut V, node: &Level) {
    match node {
        Level::Literal(inner) => visitor.visit_literal_level(inner),
        Level::Parenthesized(inner) => visitor.visit_parenthesized_level(inner),
        _ => {}
    }
}

pub fn walk_literal_level<V: Visitor + ?Sized>(visitor: &mut V, node: &LiteralLevel) {
    visitor.visit_literal(&node.literal);
}

pub fn walk_break_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &BreakStatement) {
    visitor.visit_ending(&node.ending);
}

pub fn walk_continue_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ContinueStatement) {
    visitor.visit_ending(&node.ending);
}

pub fn walk_promoted_property_modifier_group<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &PromotedPropertyModifierGroup,
) {
    for item in &node.modifiers {
        visitor.visit_promoted_property_modifier(item);
    }
}

pub fn walk_property_modifier_group<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &PropertyModifierGroup,
) {
    for item in &node.modifiers {
        visitor.visit_property_modifier(item);
    }
}

pub fn walk_method_modifier_group<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &MethodModifierGroup,
) {
    for item in &node.modifiers {
        visitor.visit_method_modifier(item);
    }
}

pub fn walk_class_modifier_group<V: Visitor + ?Sized>(visitor: &mut V, node: &ClassModifierGroup) {
    for item in &node.modifiers {
        visitor.visit_class_modifier(item);
    }
}

pub fn walk_constant_modifier_group<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ConstantModifierGroup,
) {
    for item in &node.modifiers {
        visitor.visit_constant_modifier(item);
    }
}

pub fn walk_unbraced_namespace<V: Visitor + ?Sized>(visitor: &mut V, node: &UnbracedNamespace) {
    visitor.visit_simple_identifier(&node.name);
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_braced_namespace<V: Visitor + ?Sized>(visitor: &mut V, node: &BracedNamespace) {
    if let Some(item) = &node.name {
        visitor.visit_simple_identifier(item);
    }
    visitor.visit_braced_namespace_body(&node.body);
}

pub fn walk_braced_namespace_body<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &BracedNamespaceBody,
) {
    for item in &node.statements {
        visitor.visit_statement(item);
    }
}

pub fn walk_namespace_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &NamespaceStatement) {
    match node {
        NamespaceStatement::Unbraced(inner) => visitor.visit_unbraced_namespace(inner),
        NamespaceStatement::Braced(inner) => visitor.visit_braced_namespace(inner),
        _ => {}
    }
}

pub fn walk_arithmetic_operation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArithmeticOperationExpression,
) {
    visitor.visit_arithmetic_operation_kind(&node.kind);
}

pub fn walk_arithmetic_operation_kind<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ArithmeticOperationKind,
) {
    match node {
        ArithmeticOperationKind::Addition {
            left, plus, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Subtraction {
            left, minus, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Multiplication {
            left,
            asterisk,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Division {
            left, slash, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Modulo {
            left,
            percent,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Exponentiation {
            left, pow, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Negative { minus, right, .. } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::Positive { plus, right, .. } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::PreIncrement {
            increment, right, ..
        } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::PostIncrement {
            left, increment, ..
        } => {
            visitor.visit_expression(left);
        }
        ArithmeticOperationKind::PreDecrement {
            decrement, right, ..
        } => {
            visitor.visit_expression(right);
        }
        ArithmeticOperationKind::PostDecrement {
            left, decrement, ..
        } => {
            visitor.visit_expression(left);
        }
        _ => {}
    }
}

pub fn walk_assignment_operation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &AssignmentOperationExpression,
) {
    visitor.visit_assignment_operation_kind(&node.kind);
}

pub fn walk_assignment_operation_kind<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &AssignmentOperationKind,
) {
    match node {
        AssignmentOperationKind::Assign {
            left,
            equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Addition {
            left,
            plus_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Subtraction {
            left,
            minus_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Multiplication {
            left,
            asterisk_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Division {
            left,
            slash_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Modulo {
            left,
            percent_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Exponentiation {
            left,
            pow_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Concat {
            left,
            dot_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::BitwiseAnd {
            left,
            ampersand_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::BitwiseOr {
            left,
            pipe_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::BitwiseXor {
            left,
            caret_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::LeftShift {
            left,
            left_shift_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::RightShift {
            left,
            right_shift_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        AssignmentOperationKind::Coalesce {
            left,
            coalesce_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_bitwise_operation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &BitwiseOperationExpression,
) {
    visitor.visit_bitwise_operation_kind(&node.kind);
}

pub fn walk_bitwise_operation_kind<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &BitwiseOperationKind,
) {
    match node {
        BitwiseOperationKind::And {
            left, and, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::Or {
            left, or, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::Xor {
            left, xor, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::LeftShift {
            left,
            left_shift,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::RightShift {
            left,
            right_shift,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        BitwiseOperationKind::Not { not, right, .. } => {
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_comparison_operation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ComparisonOperationExpression,
) {
    visitor.visit_comparison_operation_kind(&node.kind);
}

pub fn walk_comparison_operation_kind<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ComparisonOperationKind,
) {
    match node {
        ComparisonOperationKind::Equal {
            left,
            double_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::Identical {
            left,
            triple_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::NotEqual {
            left,
            bang_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::AngledNotEqual {
            left,
            angled_left_right,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::NotIdentical {
            left,
            bang_double_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::LessThan {
            left,
            less_than,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::GreaterThan {
            left,
            greater_than,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::LessThanOrEqual {
            left,
            less_than_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::GreaterThanOrEqual {
            left,
            greater_than_equals,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        ComparisonOperationKind::Spaceship {
            left,
            spaceship,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_logical_operation_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &LogicalOperationExpression,
) {
    visitor.visit_logical_operation_kind(&node.kind);
}

pub fn walk_logical_operation_kind<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &LogicalOperationKind,
) {
    match node {
        LogicalOperationKind::And {
            left,
            double_ampersand,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::Or {
            left,
            double_pipe,
            right,
            ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::Not { bang, right, .. } => {
            visitor.visit_expression(right);
        }
        LogicalOperationKind::LogicalAnd {
            left, and, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::LogicalOr {
            left, or, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        LogicalOperationKind::LogicalXor {
            left, xor, right, ..
        } => {
            visitor.visit_expression(left);
            visitor.visit_expression(right);
        }
        _ => {}
    }
}

pub fn walk_name<V: Visitor + ?Sized>(visitor: &mut V, node: &Name) {
    visitor.visit_name_kind(&node.kind);
}

pub fn walk_name_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &NameKind) {
    match node {
        NameKind::Special(inner) => visitor.visit_special_name(inner),
        NameKind::Unresolved(inner) => visitor.visit_unresolved_name(inner),
        NameKind::Resolved(inner) => visitor.visit_resolved_name(inner),
        _ => {}
    }
}

pub fn walk_special_name<V: Visitor + ?Sized>(visitor: &mut V, node: &SpecialName) {
    visitor.visit_special_name_kind(&node.kind);
}

pub fn walk_property<V: Visitor + ?Sized>(visitor: &mut V, node: &Property) {
    match node {
        Property::Simple(inner) => visitor.visit_simple_property(inner),
        Property::Hooked(inner) => visitor.visit_hooked_property(inner),
        _ => {}
    }
}

pub fn walk_simple_property<V: Visitor + ?Sized>(visitor: &mut V, node: &SimpleProperty) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_property_modifier_group(&node.modifiers);
    if let Some(item) = &node.r#type {
        visitor.visit_data_type(item);
    }
    for item in &node.entries {
        visitor.visit_property_entry(item);
    }
}

pub fn walk_hooked_property<V: Visitor + ?Sized>(visitor: &mut V, node: &HookedProperty) {
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_property_modifier_group(&node.modifiers);
    if let Some(item) = &node.r#type {
        visitor.visit_data_type(item);
    }
    visitor.visit_property_entry(&node.entry);
    visitor.visit_property_hook_list(&node.hooks);
}

pub fn walk_property_hook_list<V: Visitor + ?Sized>(visitor: &mut V, node: &PropertyHookList) {
    for item in &node.hooks {
        visitor.visit_property_hook(item);
    }
}

pub fn walk_property_hook<V: Visitor + ?Sized>(visitor: &mut V, node: &PropertyHook) {
    visitor.visit_property_hook_kind(&node.kind);
    if let Some(item) = &node.parameters {
        visitor.visit_function_parameter_list(item);
    }
    visitor.visit_property_hook_body(&node.body);
}

pub fn walk_property_hook_body<V: Visitor + ?Sized>(visitor: &mut V, node: &PropertyHookBody) {
    match node {
        PropertyHookBody::Concrete(inner) => visitor.visit_concrete_property_hook_body(inner),
        _ => {}
    }
}

pub fn walk_concrete_property_hook_body<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ConcretePropertyHookBody,
) {
    match node {
        ConcretePropertyHookBody::Block(inner) => {
            visitor.visit_concrete_property_hook_body_block(inner)
        }
        ConcretePropertyHookBody::Expression(inner) => {
            visitor.visit_concrete_property_hook_body_expression(inner)
        }
        _ => {}
    }
}

pub fn walk_concrete_property_hook_body_block<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ConcretePropertyHookBodyBlock,
) {
    for item in &node.body {
        visitor.visit_statement(item);
    }
}

pub fn walk_concrete_property_hook_body_expression<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &ConcretePropertyHookBodyExpression,
) {
    visitor.visit_expression(&node.expression);
}

pub fn walk_property_entry<V: Visitor + ?Sized>(visitor: &mut V, node: &PropertyEntry) {
    visitor.visit_property_entry_kind(&node.kind);
}

pub fn walk_property_entry_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &PropertyEntryKind) {
    match node {
        PropertyEntryKind::Uninitialized(inner) => {
            visitor.visit_uninitialized_property_entry(inner)
        }
        PropertyEntryKind::Initialized(inner) => visitor.visit_initialized_property_entry(inner),
        _ => {}
    }
}

pub fn walk_uninitialized_property_entry<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &UninitializedPropertyEntry,
) {
    visitor.visit_simple_variable(&node.variable);
}

pub fn walk_initialized_property_entry<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &InitializedPropertyEntry,
) {
    visitor.visit_simple_variable(&node.variable);
    visitor.visit_expression(&node.value);
}

pub fn walk_trait_body<V: Visitor + ?Sized>(visitor: &mut V, node: &TraitBody) {
    for item in &node.members {
        visitor.visit_classish_member(item);
    }
}

pub fn walk_trait_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &TraitStatement) {
    visitor.visit_name(&node.name);
    for item in &node.attributes {
        visitor.visit_attribute_group(item);
    }
    visitor.visit_trait_body(&node.body);
}

pub fn walk_trait_usage<V: Visitor + ?Sized>(visitor: &mut V, node: &TraitUsage) {
    for item in &node.traits {
        visitor.visit_name(item);
    }
    for item in &node.adaptations {
        visitor.visit_trait_usage_adaptation(item);
    }
}

pub fn walk_trait_usage_adaptation<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &TraitUsageAdaptation,
) {
    visitor.visit_trait_usage_adaptation_kind(&node.kind);
}

pub fn walk_trait_usage_adaptation_kind<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &TraitUsageAdaptationKind,
) {
    match node {
        TraitUsageAdaptationKind::Alias(inner) => visitor.visit_trait_usage_adaptation_alias(inner),
        TraitUsageAdaptationKind::Visibility(inner) => {
            visitor.visit_trait_usage_adaptation_visibility(inner)
        }
        TraitUsageAdaptationKind::Precedence(inner) => {
            visitor.visit_trait_usage_adaptation_precedence(inner)
        }
        _ => {}
    }
}

pub fn walk_trait_usage_adaptation_alias<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &TraitUsageAdaptationAlias,
) {
    if let Some(item) = &node.r#trait {
        visitor.visit_name(item);
    }
    visitor.visit_simple_identifier(&node.method);
    visitor.visit_simple_identifier(&node.alias);
    if let Some(item) = &node.visibility {
        visitor.visit_visibility_modifier(item);
    }
}

pub fn walk_trait_usage_adaptation_visibility<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &TraitUsageAdaptationVisibility,
) {
    if let Some(item) = &node.r#trait {
        visitor.visit_name(item);
    }
    visitor.visit_simple_identifier(&node.method);
    visitor.visit_visibility_modifier(&node.visibility);
}

pub fn walk_trait_usage_adaptation_precedence<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &TraitUsageAdaptationPrecedence,
) {
    if let Some(item) = &node.r#trait {
        visitor.visit_name(item);
    }
    visitor.visit_simple_identifier(&node.method);
    for item in &node.insteadof {
        visitor.visit_simple_identifier(item);
    }
}

pub fn walk_catch_type<V: Visitor + ?Sized>(visitor: &mut V, node: &CatchType) {
    visitor.visit_catch_type_kind(&node.kind);
}

pub fn walk_catch_type_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &CatchTypeKind) {
    match node {
        CatchTypeKind::Identifier(inner) => visitor.visit_catch_type_kind_identifier(inner),
        CatchTypeKind::Union(inner) => visitor.visit_catch_type_kind_union(inner),
        _ => {}
    }
}

pub fn walk_catch_type_kind_identifier<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &CatchTypeKindIdentifier,
) {
    visitor.visit_simple_identifier(&node.identifier);
}

pub fn walk_catch_type_kind_union<V: Visitor + ?Sized>(visitor: &mut V, node: &CatchTypeKindUnion) {
    for item in &node.identifiers {
        visitor.visit_simple_identifier(item);
    }
}

pub fn walk_try_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &TryStatement) {
    visitor.visit(&node.body);
    for item in &node.catches {
        visitor.visit_catch_block(item);
    }
    if let Some(item) = &node.finally {
        visitor.visit_finally_block(item);
    }
}

pub fn walk_catch_block<V: Visitor + ?Sized>(visitor: &mut V, node: &CatchBlock) {
    visitor.visit_catch_type(&node.types);
    if let Some(item) = &node.var {
        visitor.visit_simple_variable(item);
    }
    visitor.visit(&node.body);
}

pub fn walk_finally_block<V: Visitor + ?Sized>(visitor: &mut V, node: &FinallyBlock) {
    visitor.visit(&node.body);
}

pub fn walk_variable<V: Visitor + ?Sized>(visitor: &mut V, node: &Variable) {
    match node {
        Variable::SimpleVariable(inner) => visitor.visit_simple_variable(inner),
        Variable::VariableVariable(inner) => visitor.visit_variable_variable(inner),
        Variable::BracedVariableVariable(inner) => visitor.visit_braced_variable_variable(inner),
        _ => {}
    }
}

pub fn walk_variable_variable<V: Visitor + ?Sized>(visitor: &mut V, node: &VariableVariable) {
    visitor.visit_variable(&node.variable);
}

pub fn walk_braced_variable_variable<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &BracedVariableVariable,
) {
    visitor.visit_expression(&node.variable);
}

pub fn walk_static_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &StaticStatement) {
    for item in &node.vars {
        visitor.visit_static_var(item);
    }
}

pub fn walk_switch_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &SwitchStatement) {
    visitor.visit_expression(&node.condition);
    for item in &node.cases {
        visitor.visit_case(item);
    }
}

pub fn walk_echo_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &EchoStatement) {
    for item in &node.values {
        visitor.visit_expression(item);
    }
    visitor.visit_ending(&node.ending);
}

pub fn walk_return_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &ReturnStatement) {
    if let Some(item) = &node.value {
        visitor.visit_expression(item);
    }
    visitor.visit_ending(&node.ending);
}

pub fn walk_use_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &UseStatement) {
    visitor.visit_use_kind(&node.kind);
    for item in &node.uses {
        visitor.visit_use(item);
    }
}

pub fn walk_group_use_statement<V: Visitor + ?Sized>(visitor: &mut V, node: &GroupUseStatement) {
    visitor.visit_simple_identifier(&node.prefix);
    visitor.visit_use_kind(&node.kind);
    for item in &node.uses {
        visitor.visit_use(item);
    }
}

pub fn walk_static_var<V: Visitor + ?Sized>(visitor: &mut V, node: &StaticVar) {
    visitor.visit_variable(&node.var);
    if let Some(item) = &node.default {
        visitor.visit_expression(item);
    }
}

pub fn walk_comment<V: Visitor + ?Sized>(visitor: &mut V, node: &Comment) {
    visitor.visit_comment_kind(&node.kind);
}

pub fn walk_comment_kind<V: Visitor + ?Sized>(visitor: &mut V, node: &CommentKind) {
    match node {
        CommentKind::SingleLine(inner) => visitor.visit_single_line_comment(inner),
        CommentKind::MultiLine(inner) => visitor.visit_multi_line_comment(inner),
        CommentKind::HashMark(inner) => visitor.visit_hash_mark_comment(inner),
        CommentKind::DocBlock(inner) => visitor.visit_doc_block_comment(inner),
        _ => {}
    }
}

pub fn walk_doc_block_comment<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockComment) {
    visitor.visit_doc_block(&node.doc);
}

pub fn walk_doc_block<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlock) {
    for item in &node.nodes {
        visitor.visit_doc_block_node(item);
    }
}

pub fn walk_doc_block_node<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockNode) {
    match node {
        DocBlockNode::Text(inner) => visitor.visit_doc_block_text_node(inner),
        DocBlockNode::Tag(inner) => visitor.visit_doc_block_tag_node(inner),
        _ => {}
    }
}

pub fn walk_doc_block_tag_node<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockTagNode) {
    visitor.visit_doc_block_tag(&node.tag);
}

pub fn walk_doc_block_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockTag) {
    match node {
        DocBlockTag::ParamClosureThis(inner) => {
            visitor.visit_doc_block_param_closure_this_tag(inner)
        }
        DocBlockTag::Param(inner) => visitor.visit_doc_block_param_tag(inner),
        DocBlockTag::Return(inner) => visitor.visit_doc_block_return_tag(inner),
        DocBlockTag::Throws(inner) => visitor.visit_doc_block_throws_tag(inner),
        DocBlockTag::Var(inner) => visitor.visit_doc_block_var_tag(inner),
        DocBlockTag::Property(inner) => visitor.visit_doc_block_property_tag(inner),
        DocBlockTag::Method(inner) => visitor.visit_doc_block_method_tag(inner),
        DocBlockTag::Template(inner) => visitor.visit_doc_block_template_tag(inner),
        DocBlockTag::Extends(inner) => visitor.visit_doc_block_extends_tag(inner),
        DocBlockTag::Implements(inner) => visitor.visit_doc_block_implements_tag(inner),
        DocBlockTag::Uses(inner) => visitor.visit_doc_block_uses_tag(inner),
        DocBlockTag::Deprecated(inner) => visitor.visit_doc_block_deprecated_tag(inner),
        DocBlockTag::Generic(inner) => visitor.visit_doc_block_generic_tag(inner),
        _ => {}
    }
}

pub fn walk_doc_block_param_closure_this_tag<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &DocBlockParamClosureThisTag,
) {
    visitor.visit_data_type(&node.r#type);
    visitor.visit_simple_variable(&node.variable);
}

pub fn walk_doc_block_param_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockParamTag) {
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.variable {
        visitor.visit_simple_variable(item);
    }
}

pub fn walk_doc_block_return_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockReturnTag) {
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
}

pub fn walk_doc_block_throws_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockThrowsTag) {
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
}

pub fn walk_doc_block_var_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockVarTag) {
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.variable {
        visitor.visit_simple_variable(item);
    }
}

pub fn walk_doc_block_property_tag<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &DocBlockPropertyTag,
) {
    if let Some(item) = &node.data_type {
        visitor.visit_data_type(item);
    }
    visitor.visit_simple_variable(&node.variable);
}

pub fn walk_doc_block_method_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockMethodTag) {
    if let Some(item) = &node.return_type {
        visitor.visit_data_type(item);
    }
    visitor.visit_simple_identifier(&node.name);
    for item in &node.templates {
        visitor.visit_doc_block_template_tag_value(item);
    }
    visitor.visit_function_parameter_list(&node.parameters);
}

pub fn walk_doc_block_template_tag_value<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &DocBlockTemplateTagValue,
) {
    visitor.visit_simple_identifier(&node.template);
    if let Some(item) = &node.bound {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.default {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.lower_bound {
        visitor.visit_data_type(item);
    }
    if let Some(item) = &node.description {
        visitor.visit_doc_block_text_node(item);
    }
}

pub fn walk_doc_block_template_tag<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &DocBlockTemplateTag,
) {
    visitor.visit_doc_block_template_tag_value(&node.value);
}

pub fn walk_doc_block_extends_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockExtendsTag) {
    visitor.visit_data_type(&node.data_type);
}

pub fn walk_doc_block_implements_tag<V: Visitor + ?Sized>(
    visitor: &mut V,
    node: &DocBlockImplementsTag,
) {
    visitor.visit_data_type(&node.data_type);
}

pub fn walk_doc_block_uses_tag<V: Visitor + ?Sized>(visitor: &mut V, node: &DocBlockUsesTag) {
    visitor.visit_data_type(&node.data_type);
}
