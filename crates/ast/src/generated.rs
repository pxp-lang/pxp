#![allow(
    unreachable_code,
    unreachable_patterns,
    unused_variables,
    clippy::single_match,
    clippy::collapsible_match
)]
// This file is generated by meta/scripts/generate-ast.php.
// Do not make modifications to this file directly.

use crate::{name::NameQualification, utils::CommaSeparated, HasId, Node};
use pxp_bytestring::ByteString;
use pxp_span::{IsSpanned, Span};
use pxp_token::OwnedToken;
use pxp_type::Type;
use std::ptr::NonNull;

pub type NodeId = u32;

pub type Block = Vec<Statement>;

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Statement {
    pub id: NodeId,
    pub kind: StatementKind,
    pub span: Span,
    pub comments: CommentGroup,
}

impl HasId for Statement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Statement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StatementKind {
    FullOpeningTag(Box<FullOpeningTagStatement>),
    ShortOpeningTag(Box<ShortOpeningTagStatement>),
    EchoOpeningTag(Box<EchoOpeningTagStatement>),
    ClosingTag(Box<ClosingTagStatement>),
    InlineHtml(Box<InlineHtmlStatement>),
    Label(Box<LabelStatement>),
    Goto(Box<GotoStatement>),
    HaltCompiler(Box<HaltCompilerStatement>),
    Static(Box<StaticStatement>),
    DoWhile(Box<DoWhileStatement>),
    While(Box<WhileStatement>),
    For(Box<ForStatement>),
    Foreach(Box<ForeachStatement>),
    Break(Box<BreakStatement>),
    Continue(Box<ContinueStatement>),
    Constant(Box<ConstantStatement>),
    Function(Box<FunctionStatement>),
    Class(Box<ClassStatement>),
    Trait(Box<TraitStatement>),
    Interface(Box<InterfaceStatement>),
    If(Box<IfStatement>),
    Switch(Box<SwitchStatement>),
    Echo(Box<EchoStatement>),
    Expression(Box<ExpressionStatement>),
    Return(Box<ReturnStatement>),
    Namespace(Box<NamespaceStatement>),
    Use(Box<UseStatement>),
    GroupUse(Box<GroupUseStatement>),
    Comment(Box<CommentStatement>),
    Try(Box<TryStatement>),
    UnitEnum(Box<UnitEnumStatement>),
    BackedEnum(Box<BackedEnumStatement>),
    Block(Box<BlockStatement>),
    Global(Box<GlobalStatement>),
    Declare(Box<DeclareStatement>),
    Noop(Span),
}

impl HasId for StatementKind {
    fn id(&self) -> NodeId {
        match self {
            StatementKind::FullOpeningTag(inner) => inner.id(),
            StatementKind::ShortOpeningTag(inner) => inner.id(),
            StatementKind::EchoOpeningTag(inner) => inner.id(),
            StatementKind::ClosingTag(inner) => inner.id(),
            StatementKind::InlineHtml(inner) => inner.id(),
            StatementKind::Label(inner) => inner.id(),
            StatementKind::Goto(inner) => inner.id(),
            StatementKind::HaltCompiler(inner) => inner.id(),
            StatementKind::Static(inner) => inner.id(),
            StatementKind::DoWhile(inner) => inner.id(),
            StatementKind::While(inner) => inner.id(),
            StatementKind::For(inner) => inner.id(),
            StatementKind::Foreach(inner) => inner.id(),
            StatementKind::Break(inner) => inner.id(),
            StatementKind::Continue(inner) => inner.id(),
            StatementKind::Constant(inner) => inner.id(),
            StatementKind::Function(inner) => inner.id(),
            StatementKind::Class(inner) => inner.id(),
            StatementKind::Trait(inner) => inner.id(),
            StatementKind::Interface(inner) => inner.id(),
            StatementKind::If(inner) => inner.id(),
            StatementKind::Switch(inner) => inner.id(),
            StatementKind::Echo(inner) => inner.id(),
            StatementKind::Expression(inner) => inner.id(),
            StatementKind::Return(inner) => inner.id(),
            StatementKind::Namespace(inner) => inner.id(),
            StatementKind::Use(inner) => inner.id(),
            StatementKind::GroupUse(inner) => inner.id(),
            StatementKind::Comment(inner) => inner.id(),
            StatementKind::Try(inner) => inner.id(),
            StatementKind::UnitEnum(inner) => inner.id(),
            StatementKind::BackedEnum(inner) => inner.id(),
            StatementKind::Block(inner) => inner.id(),
            StatementKind::Global(inner) => inner.id(),
            StatementKind::Declare(inner) => inner.id(),
            StatementKind::Noop(_) => 0,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Expression {
    pub id: NodeId,
    pub kind: ExpressionKind,
    pub span: Span,
    pub comments: CommentGroup,
}

impl HasId for Expression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Expression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExpressionKind {
    Missing(MissingExpression),
    Eval(Box<EvalExpression>),
    Empty(Box<EmptyExpression>),
    Die(Box<DieExpression>),
    Exit(Box<ExitExpression>),
    Isset(Box<IssetExpression>),
    Unset(Box<UnsetExpression>),
    Print(Box<PrintExpression>),
    Literal(Box<Literal>),
    ArithmeticOperation(Box<ArithmeticOperationExpression>),
    AssignmentOperation(Box<AssignmentOperationExpression>),
    BitwiseOperation(Box<BitwiseOperationExpression>),
    ComparisonOperation(Box<ComparisonOperationExpression>),
    LogicalOperation(Box<LogicalOperationExpression>),
    Concat(Box<ConcatExpression>),
    Instanceof(Box<InstanceofExpression>),
    Reference(Box<ReferenceExpression>),
    Parenthesized(Box<ParenthesizedExpression>),
    ErrorSuppress(Box<ErrorSuppressExpression>),
    Identifier(Box<Identifier>),
    Variable(Box<Variable>),
    Include(Box<IncludeExpression>),
    IncludeOnce(Box<IncludeOnceExpression>),
    Require(Box<RequireExpression>),
    RequireOnce(Box<RequireOnceExpression>),
    FunctionCall(Box<FunctionCallExpression>),
    FunctionClosureCreation(Box<FunctionClosureCreationExpression>),
    MethodCall(Box<MethodCallExpression>),
    MethodClosureCreation(Box<MethodClosureCreationExpression>),
    NullsafeMethodCall(Box<NullsafeMethodCallExpression>),
    StaticMethodCall(Box<StaticMethodCallExpression>),
    StaticVariableMethodCall(Box<StaticVariableMethodCallExpression>),
    StaticMethodClosureCreation(Box<StaticMethodClosureCreationExpression>),
    StaticVariableMethodClosureCreation(Box<StaticVariableMethodClosureCreationExpression>),
    PropertyFetch(Box<PropertyFetchExpression>),
    NullsafePropertyFetch(Box<NullsafePropertyFetchExpression>),
    StaticPropertyFetch(Box<StaticPropertyFetchExpression>),
    ConstantFetch(Box<ConstantFetchExpression>),
    Static(Box<StaticExpression>),
    Self_(Box<SelfExpression>),
    Parent(Box<ParentExpression>),
    Array(Box<ArrayExpression>),
    List(Box<ListExpression>),
    Closure(Box<ClosureExpression>),
    ArrowFunction(Box<ArrowFunctionExpression>),
    New(Box<NewExpression>),
    InterpolatedString(Box<InterpolatedStringExpression>),
    Heredoc(Box<HeredocExpression>),
    Nowdoc(Box<NowdocExpression>),
    ShellExec(Box<ShellExecExpression>),
    AnonymousClass(Box<AnonymousClassExpression>),
    Bool(Box<BoolExpression>),
    ArrayIndex(Box<ArrayIndexExpression>),
    Null(Span),
    MagicConstant(Box<MagicConstantExpression>),
    ShortTernary(Box<ShortTernaryExpression>),
    Ternary(Box<TernaryExpression>),
    Coalesce(Box<CoalesceExpression>),
    Clone(Box<CloneExpression>),
    Match(Box<MatchExpression>),
    Throw(Box<ThrowExpression>),
    Yield(Box<YieldExpression>),
    YieldFrom(Box<YieldFromExpression>),
    Cast(Box<CastExpression>),
    Name(Box<Name>),
    Noop(Span),
}

impl HasId for ExpressionKind {
    fn id(&self) -> NodeId {
        match self {
            ExpressionKind::Missing(inner) => inner.id(),
            ExpressionKind::Eval(inner) => inner.id(),
            ExpressionKind::Empty(inner) => inner.id(),
            ExpressionKind::Die(inner) => inner.id(),
            ExpressionKind::Exit(inner) => inner.id(),
            ExpressionKind::Isset(inner) => inner.id(),
            ExpressionKind::Unset(inner) => inner.id(),
            ExpressionKind::Print(inner) => inner.id(),
            ExpressionKind::Literal(inner) => inner.id(),
            ExpressionKind::ArithmeticOperation(inner) => inner.id(),
            ExpressionKind::AssignmentOperation(inner) => inner.id(),
            ExpressionKind::BitwiseOperation(inner) => inner.id(),
            ExpressionKind::ComparisonOperation(inner) => inner.id(),
            ExpressionKind::LogicalOperation(inner) => inner.id(),
            ExpressionKind::Concat(inner) => inner.id(),
            ExpressionKind::Instanceof(inner) => inner.id(),
            ExpressionKind::Reference(inner) => inner.id(),
            ExpressionKind::Parenthesized(inner) => inner.id(),
            ExpressionKind::ErrorSuppress(inner) => inner.id(),
            ExpressionKind::Identifier(inner) => inner.id(),
            ExpressionKind::Variable(inner) => inner.id(),
            ExpressionKind::Include(inner) => inner.id(),
            ExpressionKind::IncludeOnce(inner) => inner.id(),
            ExpressionKind::Require(inner) => inner.id(),
            ExpressionKind::RequireOnce(inner) => inner.id(),
            ExpressionKind::FunctionCall(inner) => inner.id(),
            ExpressionKind::FunctionClosureCreation(inner) => inner.id(),
            ExpressionKind::MethodCall(inner) => inner.id(),
            ExpressionKind::MethodClosureCreation(inner) => inner.id(),
            ExpressionKind::NullsafeMethodCall(inner) => inner.id(),
            ExpressionKind::StaticMethodCall(inner) => inner.id(),
            ExpressionKind::StaticVariableMethodCall(inner) => inner.id(),
            ExpressionKind::StaticMethodClosureCreation(inner) => inner.id(),
            ExpressionKind::StaticVariableMethodClosureCreation(inner) => inner.id(),
            ExpressionKind::PropertyFetch(inner) => inner.id(),
            ExpressionKind::NullsafePropertyFetch(inner) => inner.id(),
            ExpressionKind::StaticPropertyFetch(inner) => inner.id(),
            ExpressionKind::ConstantFetch(inner) => inner.id(),
            ExpressionKind::Static(inner) => inner.id(),
            ExpressionKind::Self_(inner) => inner.id(),
            ExpressionKind::Parent(inner) => inner.id(),
            ExpressionKind::Array(inner) => inner.id(),
            ExpressionKind::List(inner) => inner.id(),
            ExpressionKind::Closure(inner) => inner.id(),
            ExpressionKind::ArrowFunction(inner) => inner.id(),
            ExpressionKind::New(inner) => inner.id(),
            ExpressionKind::InterpolatedString(inner) => inner.id(),
            ExpressionKind::Heredoc(inner) => inner.id(),
            ExpressionKind::Nowdoc(inner) => inner.id(),
            ExpressionKind::ShellExec(inner) => inner.id(),
            ExpressionKind::AnonymousClass(inner) => inner.id(),
            ExpressionKind::Bool(inner) => inner.id(),
            ExpressionKind::ArrayIndex(inner) => inner.id(),
            ExpressionKind::Null(_) => 0,
            ExpressionKind::MagicConstant(inner) => inner.id(),
            ExpressionKind::ShortTernary(inner) => inner.id(),
            ExpressionKind::Ternary(inner) => inner.id(),
            ExpressionKind::Coalesce(inner) => inner.id(),
            ExpressionKind::Clone(inner) => inner.id(),
            ExpressionKind::Match(inner) => inner.id(),
            ExpressionKind::Throw(inner) => inner.id(),
            ExpressionKind::Yield(inner) => inner.id(),
            ExpressionKind::YieldFrom(inner) => inner.id(),
            ExpressionKind::Cast(inner) => inner.id(),
            ExpressionKind::Name(inner) => inner.id(),
            ExpressionKind::Noop(_) => 0,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MissingExpression {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for MissingExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MissingExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticExpression {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for StaticExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SelfExpression {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for SelfExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SelfExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ParentExpression {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for ParentExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ParentExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CommentStatement {
    pub id: NodeId,
    pub span: Span,
    pub comment: Comment,
}

impl HasId for CommentStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CommentStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InlineHtmlStatement {
    pub id: NodeId,
    pub span: Span,
    pub html: OwnedToken,
}

impl HasId for InlineHtmlStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InlineHtmlStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FullOpeningTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for FullOpeningTagStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FullOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortOpeningTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for ShortOpeningTagStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ShortOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EchoOpeningTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for EchoOpeningTagStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for EchoOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosingTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for ClosingTagStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClosingTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExpressionStatement {
    pub id: NodeId,
    pub span: Span,
    pub expression: Expression,
    pub ending: Ending,
}

impl HasId for ExpressionStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ExpressionStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GlobalStatement {
    pub id: NodeId,
    pub span: Span,
    pub global: Span,
    pub variables: Vec<Variable>,
    pub semicolon: Span,
}

impl HasId for GlobalStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for GlobalStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BlockStatement {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl HasId for BlockStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BlockStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CastKind {
    Int(Span),
    Bool(Span),
    Float(Span),
    String(Span),
    Array(Span),
    Object(Span),
    Unset(Span),
}

impl IsSpanned for CastKind {
    fn span(&self) -> Span {
        match self {
            CastKind::Int(span) => *span,
            CastKind::Bool(span) => *span,
            CastKind::Float(span) => *span,
            CastKind::String(span) => *span,
            CastKind::Array(span) => *span,
            CastKind::Object(span) => *span,
            CastKind::Unset(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Case {
    pub id: NodeId,
    pub span: Span,
    pub condition: Option<Expression>,
    pub body: Block,
}

impl HasId for Case {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Case {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Use {
    pub id: NodeId,
    pub span: Span,
    pub name: Name,
    pub alias: Option<SimpleIdentifier>,
    pub kind: UseKind,
}

impl HasId for Use {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Use {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Hash, Copy)]
pub enum UseKind {
    Normal,
    Function,
    Const,
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EvalExpression {
    pub id: NodeId,
    pub span: Span,
    pub eval: Span,
    pub argument: Box<SingleArgument>,
}

impl HasId for EvalExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for EvalExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EmptyExpression {
    pub id: NodeId,
    pub span: Span,
    pub empty: Span,
    pub argument: Box<SingleArgument>,
}

impl HasId for EmptyExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for EmptyExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DieExpression {
    pub id: NodeId,
    pub span: Span,
    pub die: Span,
    pub argument: Option<Box<SingleArgument>>,
}

impl HasId for DieExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DieExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExitExpression {
    pub id: NodeId,
    pub span: Span,
    pub exit: Span,
    pub argument: Option<Box<SingleArgument>>,
}

impl HasId for ExitExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ExitExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IssetExpression {
    pub id: NodeId,
    pub span: Span,
    pub isset: Span,
    pub arguments: ArgumentList,
}

impl HasId for IssetExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IssetExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnsetExpression {
    pub id: NodeId,
    pub span: Span,
    pub unset: Span,
    pub arguments: ArgumentList,
}

impl HasId for UnsetExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UnsetExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PrintExpression {
    pub id: NodeId,
    pub span: Span,
    pub print: Span,
    pub value: Option<Box<Expression>>,
    pub argument: Option<Box<SingleArgument>>,
}

impl HasId for PrintExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PrintExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcatExpression {
    pub id: NodeId,
    pub span: Span,
    pub left: Box<Expression>,
    pub dot: Span,
    pub right: Box<Expression>,
}

impl HasId for ConcatExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConcatExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InstanceofExpression {
    pub id: NodeId,
    pub span: Span,
    pub left: Box<Expression>,
    pub instanceof: Span,
    pub right: Box<Expression>,
}

impl HasId for InstanceofExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InstanceofExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReferenceExpression {
    pub id: NodeId,
    pub span: Span,
    pub ampersand: Span,
    pub right: Box<Expression>,
}

impl HasId for ReferenceExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ReferenceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ParenthesizedExpression {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub expr: Box<Expression>,
    pub end: Span,
}

impl HasId for ParenthesizedExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ParenthesizedExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ErrorSuppressExpression {
    pub id: NodeId,
    pub span: Span,
    pub at: Span,
    pub expr: Box<Expression>,
}

impl HasId for ErrorSuppressExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ErrorSuppressExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IncludeExpression {
    pub id: NodeId,
    pub span: Span,
    pub include: Span,
    pub path: Box<Expression>,
}

impl HasId for IncludeExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IncludeExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IncludeOnceExpression {
    pub id: NodeId,
    pub span: Span,
    pub include_once: Span,
    pub path: Box<Expression>,
}

impl HasId for IncludeOnceExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IncludeOnceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct RequireExpression {
    pub id: NodeId,
    pub span: Span,
    pub require: Span,
    pub path: Box<Expression>,
}

impl HasId for RequireExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for RequireExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct RequireOnceExpression {
    pub id: NodeId,
    pub span: Span,
    pub require_once: Span,
    pub path: Box<Expression>,
}

impl HasId for RequireOnceExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for RequireOnceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arguments: ArgumentList,
}

impl HasId for FunctionCallExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FunctionCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub placeholder: ArgumentPlaceholder,
}

impl HasId for FunctionClosureCreationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FunctionClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arrow: Span,
    pub method: Box<Expression>,
    pub arguments: ArgumentList,
}

impl HasId for MethodCallExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arrow: Span,
    pub method: Box<Expression>,
    pub placeholder: ArgumentPlaceholder,
}

impl HasId for MethodClosureCreationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NullsafeMethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub question_arrow: Span,
    pub method: Box<Expression>,
    pub arguments: ArgumentList,
}

impl HasId for NullsafeMethodCallExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for NullsafeMethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticMethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Identifier,
    pub arguments: ArgumentList,
}

impl HasId for StaticMethodCallExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticMethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVariableMethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Variable,
    pub arguments: ArgumentList,
}

impl HasId for StaticVariableMethodCallExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticVariableMethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticMethodClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Identifier,
    pub placeholder: ArgumentPlaceholder,
}

impl HasId for StaticMethodClosureCreationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticMethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVariableMethodClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Variable,
    pub placeholder: ArgumentPlaceholder,
}

impl HasId for StaticVariableMethodClosureCreationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticVariableMethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arrow: Span,
    pub property: Box<Expression>,
}

impl HasId for PropertyFetchExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PropertyFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NullsafePropertyFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub question_arrow: Span,
    pub property: Box<Expression>,
}

impl HasId for NullsafePropertyFetchExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for NullsafePropertyFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticPropertyFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub property: Variable,
}

impl HasId for StaticPropertyFetchExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticPropertyFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub constant: Identifier,
}

impl HasId for ConstantFetchExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConstantFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: ArrayKind,
    pub items: CommaSeparated<ArrayItem>,
}

impl HasId for ArrayExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArrayKind {
    Short(ArrayKindShort),
    Long(ArrayKindLong),
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayKindShort {
    pub span: Span,
    pub left_bracket: Span,
    pub right_bracket: Span,
}

impl IsSpanned for ArrayKindShort {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayKindLong {
    pub span: Span,
    pub array: Span,
    pub left_parenthesis: Span,
    pub right_parenthesis: Span,
}

impl IsSpanned for ArrayKindLong {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListExpression {
    pub id: NodeId,
    pub span: Span,
    pub list: Span,
    pub start: Span,
    pub items: Vec<ListEntry>,
    pub end: Span,
}

impl HasId for ListExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ListExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NewExpression {
    pub id: NodeId,
    pub span: Span,
    pub new: Span,
    pub target: Box<Expression>,
    pub arguments: Option<ArgumentList>,
}

impl HasId for NewExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for NewExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterpolatedStringExpression {
    pub id: NodeId,
    pub span: Span,
    pub parts: Vec<StringPart>,
}

impl HasId for InterpolatedStringExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InterpolatedStringExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HeredocExpression {
    pub id: NodeId,
    pub span: Span,
    pub label: ByteString,
    pub parts: Vec<StringPart>,
}

impl HasId for HeredocExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for HeredocExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NowdocExpression {
    pub id: NodeId,
    pub span: Span,
    pub label: OwnedToken,
    pub value: OwnedToken,
}

impl HasId for NowdocExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for NowdocExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShellExecExpression {
    pub id: NodeId,
    pub span: Span,
    pub parts: Vec<StringPart>,
}

impl HasId for ShellExecExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ShellExecExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BoolExpression {
    pub id: NodeId,
    pub span: Span,
    pub value: OwnedToken,
}

impl HasId for BoolExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BoolExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayIndexExpression {
    pub id: NodeId,
    pub span: Span,
    pub array: Box<Expression>,
    pub left_bracket: Span,
    pub index: Option<Box<Expression>>,
    pub right_bracket: Span,
}

impl HasId for ArrayIndexExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayIndexExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortTernaryExpression {
    pub id: NodeId,
    pub span: Span,
    pub condition: Box<Expression>,
    pub question_colon: Span,
    pub r#else: Box<Expression>,
}

impl HasId for ShortTernaryExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ShortTernaryExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TernaryExpression {
    pub id: NodeId,
    pub span: Span,
    pub condition: Box<Expression>,
    pub question: Span,
    pub then: Box<Expression>,
    pub colon: Span,
    pub r#else: Box<Expression>,
}

impl HasId for TernaryExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TernaryExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CoalesceExpression {
    pub id: NodeId,
    pub span: Span,
    pub lhs: Box<Expression>,
    pub double_question: Span,
    pub rhs: Box<Expression>,
}

impl HasId for CoalesceExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CoalesceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CloneExpression {
    pub id: NodeId,
    pub span: Span,
    pub clone: Span,
    pub target: Box<Expression>,
}

impl HasId for CloneExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CloneExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MatchExpression {
    pub id: NodeId,
    pub span: Span,
    pub keyword: Span,
    pub left_parenthesis: Span,
    pub condition: Box<Expression>,
    pub right_parenthesis: Span,
    pub left_brace: Span,
    pub default: Option<Box<DefaultMatchArm>>,
    pub arms: Vec<MatchArm>,
    pub right_brace: Span,
}

impl HasId for MatchExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MatchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ThrowExpression {
    pub id: NodeId,
    pub span: Span,
    pub value: Box<Expression>,
}

impl HasId for ThrowExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ThrowExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct YieldExpression {
    pub id: NodeId,
    pub span: Span,
    pub r#yield: Span,
    pub key: Option<Box<Expression>>,
    pub value: Option<Box<Expression>>,
}

impl HasId for YieldExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for YieldExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct YieldFromExpression {
    pub id: NodeId,
    pub span: Span,
    pub r#yield: Span,
    pub from: Span,
    pub value: Box<Expression>,
}

impl HasId for YieldFromExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for YieldFromExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CastExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: CastKind,
    pub value: Box<Expression>,
}

impl HasId for CastExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CastExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DefaultMatchArm {
    pub id: NodeId,
    pub span: Span,
    pub keyword: Span,
    pub double_arrow: Span,
    pub body: Expression,
}

impl HasId for DefaultMatchArm {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DefaultMatchArm {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MatchArm {
    pub id: NodeId,
    pub span: Span,
    pub conditions: Vec<Expression>,
    pub arrow: Span,
    pub body: Expression,
}

impl HasId for MatchArm {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MatchArm {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MagicConstantExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: MagicConstantKind,
}

impl HasId for MagicConstantExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MagicConstantExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MagicConstantKind {
    Directory,
    File,
    Line,
    Function,
    Class,
    Method,
    Namespace,
    Trait,
    CompilerHaltOffset,
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StringPart {
    Literal(LiteralStringPart),
    Expression(ExpressionStringPart),
}

impl HasId for StringPart {
    fn id(&self) -> NodeId {
        match self {
            StringPart::Literal(inner) => inner.id(),
            StringPart::Expression(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LiteralStringPart {
    pub id: NodeId,
    pub span: Span,
    pub value: ByteString,
}

impl HasId for LiteralStringPart {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for LiteralStringPart {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExpressionStringPart {
    pub id: NodeId,
    pub span: Span,
    pub expression: Box<Expression>,
}

impl HasId for ExpressionStringPart {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ExpressionStringPart {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArrayItem {
    Skipped(Span),
    Value(ArrayItemValue),
    ReferencedValue(ArrayItemReferencedValue),
    SpreadValue(ArrayItemSpreadValue),
    KeyValue(ArrayItemKeyValue),
    ReferencedKeyValue(ArrayItemReferencedKeyValue),
}

impl HasId for ArrayItem {
    fn id(&self) -> NodeId {
        match self {
            ArrayItem::Skipped(_) => 0,
            ArrayItem::Value(inner) => inner.id(),
            ArrayItem::ReferencedValue(inner) => inner.id(),
            ArrayItem::SpreadValue(inner) => inner.id(),
            ArrayItem::KeyValue(inner) => inner.id(),
            ArrayItem::ReferencedKeyValue(inner) => inner.id(),
        }
    }
}

impl IsSpanned for ArrayItem {
    fn span(&self) -> Span {
        match self {
            ArrayItem::Skipped(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemValue {
    pub id: NodeId,
    pub span: Span,
    pub value: Expression,
}

impl HasId for ArrayItemValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayItemValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemReferencedValue {
    pub id: NodeId,
    pub span: Span,
    pub ampersand: Span,
    pub value: Expression,
}

impl HasId for ArrayItemReferencedValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayItemReferencedValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemSpreadValue {
    pub id: NodeId,
    pub span: Span,
    pub ellipsis: Span,
    pub value: Expression,
}

impl HasId for ArrayItemSpreadValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayItemSpreadValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemKeyValue {
    pub id: NodeId,
    pub span: Span,
    pub key: Expression,
    pub double_arrow: Span,
    pub value: Expression,
}

impl HasId for ArrayItemKeyValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayItemKeyValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemReferencedKeyValue {
    pub id: NodeId,
    pub span: Span,
    pub key: Expression,
    pub double_arrow: Span,
    pub ampersand: Span,
    pub value: Expression,
}

impl HasId for ArrayItemReferencedKeyValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrayItemReferencedKeyValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ListEntry {
    Skipped(Span),
    Value(ListEntryValue),
    KeyValue(ListEntryKeyValue),
}

impl HasId for ListEntry {
    fn id(&self) -> NodeId {
        match self {
            ListEntry::Skipped(_) => 0,
            ListEntry::Value(inner) => inner.id(),
            ListEntry::KeyValue(inner) => inner.id(),
        }
    }
}

impl IsSpanned for ListEntry {
    fn span(&self) -> Span {
        match self {
            ListEntry::Skipped(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListEntryValue {
    pub id: NodeId,
    pub span: Span,
    pub value: Expression,
}

impl HasId for ListEntryValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ListEntryValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListEntryKeyValue {
    pub id: NodeId,
    pub span: Span,
    pub key: Expression,
    pub double_arrow: Span,
    pub value: Expression,
}

impl HasId for ListEntryKeyValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ListEntryKeyValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PositionalArgument {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub ellipsis: Option<Span>,
    pub value: Expression,
}

impl HasId for PositionalArgument {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PositionalArgument {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NamedArgument {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub name: SimpleIdentifier,
    pub colon: Span,
    pub ellipsis: Option<Span>,
    pub value: Expression,
}

impl HasId for NamedArgument {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for NamedArgument {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Argument {
    Positional(PositionalArgument),
    Named(NamedArgument),
}

impl HasId for Argument {
    fn id(&self) -> NodeId {
        match self {
            Argument::Positional(inner) => inner.id(),
            Argument::Named(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArgumentList {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub arguments: Vec<Argument>,
    pub right_parenthesis: Span,
}

impl HasId for ArgumentList {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArgumentList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SingleArgument {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub argument: Option<Argument>,
    pub right_parenthesis: Span,
}

impl HasId for SingleArgument {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SingleArgument {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArgumentPlaceholder {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub ellipsis: Span,
    pub right_parenthesis: Span,
}

impl HasId for ArgumentPlaceholder {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArgumentPlaceholder {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Attribute {
    pub id: NodeId,
    pub span: Span,
    pub name: Name,
    pub arguments: Option<ArgumentList>,
}

impl HasId for Attribute {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Attribute {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AttributeGroup {
    pub id: NodeId,
    pub span: Span,
    pub members: Vec<Attribute>,
}

impl HasId for AttributeGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for AttributeGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl HasId for ClassBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: ClassModifierGroup,
    pub class: Span,
    pub name: Name,
    pub extends: Option<ClassExtends>,
    pub implements: Option<ClassImplements>,
    pub body: ClassBody,
}

impl HasId for ClassStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AnonymousClassBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl HasId for AnonymousClassBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for AnonymousClassBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AnonymousClassExpression {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub class: Span,
    pub extends: Option<ClassExtends>,
    pub implements: Option<ClassImplements>,
    pub body: Box<AnonymousClassBody>,
}

impl HasId for AnonymousClassExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for AnonymousClassExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassExtends {
    pub id: NodeId,
    pub span: Span,
    pub extends: Span,
    pub parent: Name,
}

impl HasId for ClassExtends {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassExtends {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassImplements {
    pub id: NodeId,
    pub span: Span,
    pub implements: Span,
    pub interfaces: CommaSeparated<Name>,
}

impl HasId for ClassImplements {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassImplements {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClassishMember {
    Constant(ClassishConstant),
    TraitUsage(TraitUsage),
    Property(Property),
    Method(Method),
    Missing(MissingClassishMember),
}

impl HasId for ClassishMember {
    fn id(&self) -> NodeId {
        match self {
            ClassishMember::Constant(inner) => inner.id(),
            ClassishMember::TraitUsage(inner) => inner.id(),
            ClassishMember::Property(inner) => inner.id(),
            ClassishMember::Method(inner) => inner.id(),
            ClassishMember::Missing(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Method {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: MethodParameterList,
    pub return_type: Option<ReturnType>,
    pub body: MethodBody,
}

impl HasId for Method {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Method {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodBody {
    pub id: NodeId,
    pub span: Span,
    pub kind: MethodBodyKind,
}

impl HasId for MethodBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MethodBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MethodBodyKind {
    Abstract(AbstractMethodBody),
    Concrete(ConcreteMethodBody),
    Missing(MissingMethodBody),
}

impl HasId for MethodBodyKind {
    fn id(&self) -> NodeId {
        match self {
            MethodBodyKind::Abstract(inner) => inner.id(),
            MethodBodyKind::Concrete(inner) => inner.id(),
            MethodBodyKind::Missing(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MissingMethodBody {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for MissingMethodBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MissingMethodBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AbstractMethodBody {
    pub id: NodeId,
    pub span: Span,
    pub semicolon: Span,
}

impl HasId for AbstractMethodBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for AbstractMethodBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcreteMethodBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl HasId for ConcreteMethodBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConcreteMethodBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodParameterList {
    pub id: NodeId,
    pub span: Span,
    pub left_parenthesis: Span,
    pub parameters: CommaSeparated<MethodParameter>,
    pub right_parenthesis: Span,
}

impl HasId for MethodParameterList {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MethodParameterList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodParameter {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Option<PromotedPropertyModifierGroup>,
    pub name: SimpleVariable,
    pub attributes: Vec<AttributeGroup>,
    pub data_type: Option<DataType>,
    pub ellipsis: Option<Span>,
    pub default: Option<Expression>,
    pub ampersand: Option<Span>,
}

impl HasId for MethodParameter {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MethodParameter {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MissingClassishMember {
    pub id: NodeId,
    pub span: Span,
}

impl HasId for MissingClassishMember {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MissingClassishMember {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantEntry {
    pub id: NodeId,
    pub span: Span,
    pub name: Name,
    pub equals: Span,
    pub value: Expression,
}

impl HasId for ConstantEntry {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConstantEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassishConstantEntry {
    pub id: NodeId,
    pub span: Span,
    pub name: SimpleIdentifier,
    pub equals: Span,
    pub value: Expression,
}

impl HasId for ClassishConstantEntry {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassishConstantEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub r#const: Span,
    pub entries: Vec<ConstantEntry>,
    pub semicolon: Span,
}

impl HasId for ConstantStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConstantStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassishConstant {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: ConstantModifierGroup,
    pub r#const: Span,
    pub data_type: Option<DataType>,
    pub entries: Vec<ClassishConstantEntry>,
    pub semicolon: Span,
}

impl HasId for ClassishConstant {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassishConstant {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#if: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub body: IfStatementBody,
}

impl HasId for IfStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum IfStatementBody {
    Statement(IfStatementBodyStatement),
    Block(IfStatementBodyBlock),
}

impl HasId for IfStatementBody {
    fn id(&self) -> NodeId {
        match self {
            IfStatementBody::Statement(inner) => inner.id(),
            IfStatementBody::Block(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementBodyStatement {
    pub id: NodeId,
    pub span: Span,
    pub statement: Box<Statement>,
    pub elseifs: Vec<IfStatementElseIf>,
    pub r#else: Option<IfStatementElse>,
}

impl HasId for IfStatementBodyStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatementBodyStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementBodyBlock {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
    pub elseifs: Vec<IfStatementElseIfBlock>,
    pub r#else: Option<Box<IfStatementElseBlock>>,
    pub endif: Span,
    pub ending: Ending,
}

impl HasId for IfStatementBodyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatementBodyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseIf {
    pub id: NodeId,
    pub span: Span,
    pub elseif: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub statement: Box<Statement>,
}

impl HasId for IfStatementElseIf {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatementElseIf {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElse {
    pub id: NodeId,
    pub span: Span,
    pub r#else: Span,
    pub statement: Box<Statement>,
}

impl HasId for IfStatementElse {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatementElse {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseIfBlock {
    pub id: NodeId,
    pub span: Span,
    pub elseif: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
}

impl HasId for IfStatementElseIfBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatementElseIfBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseBlock {
    pub id: NodeId,
    pub span: Span,
    pub r#else: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
}

impl HasId for IfStatementElseBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for IfStatementElseBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DataType {
    pub id: NodeId,
    pub kind: Type<ResolvedName>,
    pub span: Span,
}

impl HasId for DataType {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DataType {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareEntry {
    pub id: NodeId,
    pub span: Span,
    pub key: SimpleIdentifier,
    pub equals: Span,
    pub value: Literal,
}

impl HasId for DeclareEntry {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareEntryGroup {
    pub id: NodeId,
    pub span: Span,
    pub left_parenthesis: Span,
    pub right_parenthesis: Span,
    pub entries: Vec<DeclareEntry>,
}

impl HasId for DeclareEntryGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareEntryGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DeclareBody {
    Noop(DeclareBodyNoop),
    Braced(DeclareBodyBraced),
    Expression(DeclareBodyExpression),
    Block(DeclareBodyBlock),
}

impl HasId for DeclareBody {
    fn id(&self) -> NodeId {
        match self {
            DeclareBody::Noop(inner) => inner.id(),
            DeclareBody::Braced(inner) => inner.id(),
            DeclareBody::Expression(inner) => inner.id(),
            DeclareBody::Block(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareBodyNoop {
    pub id: NodeId,
    pub span: Span,
    pub semicolon: Span,
}

impl HasId for DeclareBodyNoop {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareBodyNoop {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareBodyBraced {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl HasId for DeclareBodyBraced {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareBodyBraced {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareBodyExpression {
    pub id: NodeId,
    pub span: Span,
    pub expression: Expression,
    pub semicolon: Span,
}

impl HasId for DeclareBodyExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareBodyExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareBodyBlock {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
    pub enddeclare: Span,
    pub semicolon: Span,
}

impl HasId for DeclareBodyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareBodyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareStatement {
    pub id: NodeId,
    pub span: Span,
    pub declare: Span,
    pub entries: DeclareEntryGroup,
    pub body: DeclareBody,
}

impl HasId for DeclareStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DeclareStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumCase {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub start: Span,
    pub name: SimpleIdentifier,
    pub end: Span,
}

impl HasId for UnitEnumCase {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UnitEnumCase {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum UnitEnumMember {
    Case(UnitEnumCase),
    Classish(ClassishMember),
}

impl HasId for UnitEnumMember {
    fn id(&self) -> NodeId {
        match self {
            UnitEnumMember::Case(inner) => inner.id(),
            UnitEnumMember::Classish(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<UnitEnumMember>,
    pub right_brace: Span,
}

impl HasId for UnitEnumBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UnitEnumBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub r#enum: Span,
    pub name: Name,
    pub implements: Vec<Name>,
    pub body: UnitEnumBody,
}

impl HasId for UnitEnumStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UnitEnumStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumCase {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub case: Span,
    pub name: SimpleIdentifier,
    pub equals: Span,
    pub value: Expression,
    pub semicolon: Span,
}

impl HasId for BackedEnumCase {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BackedEnumCase {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BackedEnumMember {
    Case(BackedEnumCase),
    Classish(ClassishMember),
}

impl HasId for BackedEnumMember {
    fn id(&self) -> NodeId {
        match self {
            BackedEnumMember::Case(inner) => inner.id(),
            BackedEnumMember::Classish(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<BackedEnumMember>,
    pub right_brace: Span,
}

impl HasId for BackedEnumBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BackedEnumBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub r#enum: Span,
    pub name: Name,
    pub colon: Span,
    pub backed_type: BackedEnumType,
    pub implements: Vec<Name>,
    pub body: BackedEnumBody,
}

impl HasId for BackedEnumStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BackedEnumStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BackedEnumType {
    String(Span),
    Int(Span),
    Invalid,
}

impl IsSpanned for BackedEnumType {
    fn span(&self) -> Span {
        match self {
            BackedEnumType::String(span) => *span,
            BackedEnumType::Int(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReturnType {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub data_type: DataType,
}

impl HasId for ReturnType {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ReturnType {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionParameter {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub name: SimpleVariable,
    pub attributes: Vec<AttributeGroup>,
    pub data_type: Option<DataType>,
    pub ellipsis: Option<Span>,
    pub default: Option<Expression>,
    pub ampersand: Option<Span>,
}

impl HasId for FunctionParameter {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FunctionParameter {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionParameterList {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub parameters: CommaSeparated<FunctionParameter>,
    pub right_parenthesis: Span,
}

impl HasId for FunctionParameterList {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FunctionParameterList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionBody {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl HasId for FunctionBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FunctionBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: Name,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub body: FunctionBody,
}

impl HasId for FunctionStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FunctionStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureUseVariable {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub ampersand: Option<Span>,
    pub variable: SimpleVariable,
}

impl HasId for ClosureUseVariable {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClosureUseVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureUse {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub r#use: Span,
    pub left_parenthesis: Span,
    pub variables: CommaSeparated<ClosureUseVariable>,
    pub right_parenthesis: Span,
}

impl HasId for ClosureUse {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClosureUse {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureExpression {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub r#static: Option<Span>,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub parameters: FunctionParameterList,
    pub uses: Option<ClosureUse>,
    pub return_type: Option<ReturnType>,
    pub body: FunctionBody,
}

impl HasId for ClosureExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClosureExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrowFunctionExpression {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub r#static: Option<Span>,
    pub ampersand: Option<Span>,
    pub r#fn: Span,
    pub attributes: Vec<AttributeGroup>,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub double_arrow: Span,
    pub body: Box<Expression>,
}

impl HasId for ArrowFunctionExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArrowFunctionExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LabelStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub label: SimpleIdentifier,
    pub colon: Span,
}

impl HasId for LabelStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for LabelStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GotoStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub keyword: Span,
    pub label: SimpleIdentifier,
    pub semicolon: Span,
}

impl HasId for GotoStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for GotoStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Identifier {
    SimpleIdentifier(SimpleIdentifier),
    DynamicIdentifier(DynamicIdentifier),
}

impl HasId for Identifier {
    fn id(&self) -> NodeId {
        match self {
            Identifier::SimpleIdentifier(inner) => inner.id(),
            Identifier::DynamicIdentifier(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SimpleIdentifier {
    pub id: NodeId,
    pub symbol: ByteString,
    pub span: Span,
}

impl HasId for SimpleIdentifier {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SimpleIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DynamicIdentifier {
    pub id: NodeId,
    pub span: Span,
    pub expr: Box<Expression>,
}

impl HasId for DynamicIdentifier {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DynamicIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceExtends {
    pub id: NodeId,
    pub span: Span,
    pub extends: Span,
    pub parents: CommaSeparated<Name>,
}

impl HasId for InterfaceExtends {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InterfaceExtends {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl HasId for InterfaceBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InterfaceBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub interface: Span,
    pub name: Name,
    pub extends: Option<InterfaceExtends>,
    pub body: InterfaceBody,
}

impl HasId for InterfaceStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InterfaceStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Literal {
    pub id: NodeId,
    pub span: Span,
    pub kind: LiteralKind,
    pub token: OwnedToken,
}

impl HasId for Literal {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Literal {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LiteralKind {
    Integer,
    Float,
    String,
    Missing,
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatement {
    pub id: NodeId,
    pub span: Span,
    pub foreach: Span,
    pub left_parenthesis: Span,
    pub iterator: ForeachStatementIterator,
    pub right_parenthesis: Span,
    pub body: ForeachStatementBody,
}

impl HasId for ForeachStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForeachStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForeachStatementIterator {
    Value(ForeachStatementIteratorValue),
    KeyAndValue(ForeachStatementIteratorKeyAndValue),
}

impl HasId for ForeachStatementIterator {
    fn id(&self) -> NodeId {
        match self {
            ForeachStatementIterator::Value(inner) => inner.id(),
            ForeachStatementIterator::KeyAndValue(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatementIteratorValue {
    pub id: NodeId,
    pub span: Span,
    pub expression: Expression,
    pub r#as: Span,
    pub ampersand: Option<Span>,
    pub value: Expression,
}

impl HasId for ForeachStatementIteratorValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForeachStatementIteratorValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatementIteratorKeyAndValue {
    pub id: NodeId,
    pub span: Span,
    pub expression: Expression,
    pub r#as: Span,
    pub ampersand: Option<Span>,
    pub key: Expression,
    pub double_arrow: Span,
    pub value: Expression,
}

impl HasId for ForeachStatementIteratorKeyAndValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForeachStatementIteratorKeyAndValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForeachStatementBody {
    Statement(ForeachStatementBodyStatement),
    Block(ForeachStatementBodyBlock),
}

impl HasId for ForeachStatementBody {
    fn id(&self) -> NodeId {
        match self {
            ForeachStatementBody::Statement(inner) => inner.id(),
            ForeachStatementBody::Block(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatementBodyStatement {
    pub id: NodeId,
    pub span: Span,
    pub statement: Box<Statement>,
}

impl HasId for ForeachStatementBodyStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForeachStatementBodyStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatementBodyBlock {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
    pub endforeach: Span,
    pub ending: Ending,
}

impl HasId for ForeachStatementBodyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForeachStatementBodyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#for: Span,
    pub left_parenthesis: Span,
    pub iterator: ForStatementIterator,
    pub right_parenthesis: Span,
    pub body: ForStatementBody,
}

impl HasId for ForStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatementIterator {
    pub id: NodeId,
    pub span: Span,
    pub initializations: CommaSeparated<Expression>,
    pub initializations_semicolon: Span,
    pub conditions: CommaSeparated<Expression>,
    pub conditions_semicolon: Span,
    pub r#loop: CommaSeparated<Expression>,
}

impl HasId for ForStatementIterator {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForStatementIterator {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForStatementBody {
    Statement(ForStatementBodyStatement),
    Block(ForStatementBodyBlock),
}

impl HasId for ForStatementBody {
    fn id(&self) -> NodeId {
        match self {
            ForStatementBody::Statement(inner) => inner.id(),
            ForStatementBody::Block(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatementBodyStatement {
    pub id: NodeId,
    pub span: Span,
    pub statement: Box<Statement>,
}

impl HasId for ForStatementBodyStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForStatementBodyStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatementBodyBlock {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
    pub endfor: Span,
    pub ending: Ending,
}

impl HasId for ForStatementBodyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ForStatementBodyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DoWhileStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#do: Span,
    pub body: Box<Statement>,
    pub r#while: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub semicolon: Span,
}

impl HasId for DoWhileStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DoWhileStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct WhileStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#while: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub body: WhileStatementBody,
}

impl HasId for WhileStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for WhileStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum WhileStatementBody {
    Statement(WhileStatementBodyStatement),
    Block(WhileStatementBodyBlock),
}

impl HasId for WhileStatementBody {
    fn id(&self) -> NodeId {
        match self {
            WhileStatementBody::Statement(inner) => inner.id(),
            WhileStatementBody::Block(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct WhileStatementBodyStatement {
    pub id: NodeId,
    pub span: Span,
    pub statement: Box<Statement>,
}

impl HasId for WhileStatementBodyStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for WhileStatementBodyStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct WhileStatementBodyBlock {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
    pub endwhile: Span,
    pub ending: Ending,
}

impl HasId for WhileStatementBodyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for WhileStatementBodyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Level {
    Literal(LiteralLevel),
    Parenthesized(ParenthesizedLevel),
}

impl HasId for Level {
    fn id(&self) -> NodeId {
        match self {
            Level::Literal(inner) => inner.id(),
            Level::Parenthesized(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LiteralLevel {
    pub id: NodeId,
    pub literal: Literal,
}

impl HasId for LiteralLevel {
    fn id(&self) -> NodeId {
        self.id
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ParenthesizedLevel {
    pub id: NodeId,
    pub span: Span,
    pub left_parenthesis: Span,
    pub level: Box<Level>,
    pub right_parenthesis: Span,
}

impl HasId for ParenthesizedLevel {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ParenthesizedLevel {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BreakStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#break: Span,
    pub level: Option<Level>,
    pub ending: Ending,
}

impl HasId for BreakStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BreakStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ContinueStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#continue: Span,
    pub level: Option<Level>,
    pub ending: Ending,
}

impl HasId for ContinueStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ContinueStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum VisibilityModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
}

impl IsSpanned for VisibilityModifier {
    fn span(&self) -> Span {
        match self {
            VisibilityModifier::Public(span) => *span,
            VisibilityModifier::Protected(span) => *span,
            VisibilityModifier::Private(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PromotedPropertyModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    PublicSet(Span),
    ProtectedSet(Span),
    PrivateSet(Span),
    Readonly(Span),
}

impl IsSpanned for PromotedPropertyModifier {
    fn span(&self) -> Span {
        match self {
            PromotedPropertyModifier::Public(span) => *span,
            PromotedPropertyModifier::Protected(span) => *span,
            PromotedPropertyModifier::Private(span) => *span,
            PromotedPropertyModifier::PublicSet(span) => *span,
            PromotedPropertyModifier::ProtectedSet(span) => *span,
            PromotedPropertyModifier::PrivateSet(span) => *span,
            PromotedPropertyModifier::Readonly(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct PromotedPropertyModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<PromotedPropertyModifier>,
}

impl HasId for PromotedPropertyModifierGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PromotedPropertyModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    PublicSet(Span),
    ProtectedSet(Span),
    PrivateSet(Span),
    Static(Span),
    Readonly(Span),
}

impl IsSpanned for PropertyModifier {
    fn span(&self) -> Span {
        match self {
            PropertyModifier::Public(span) => *span,
            PropertyModifier::Protected(span) => *span,
            PropertyModifier::Private(span) => *span,
            PropertyModifier::PublicSet(span) => *span,
            PropertyModifier::ProtectedSet(span) => *span,
            PropertyModifier::PrivateSet(span) => *span,
            PropertyModifier::Static(span) => *span,
            PropertyModifier::Readonly(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct PropertyModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<PropertyModifier>,
}

impl HasId for PropertyModifierGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PropertyModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MethodModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Static(Span),
    Abstract(Span),
    Final(Span),
}

impl IsSpanned for MethodModifier {
    fn span(&self) -> Span {
        match self {
            MethodModifier::Public(span) => *span,
            MethodModifier::Protected(span) => *span,
            MethodModifier::Private(span) => *span,
            MethodModifier::Static(span) => *span,
            MethodModifier::Abstract(span) => *span,
            MethodModifier::Final(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct MethodModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<MethodModifier>,
}

impl HasId for MethodModifierGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MethodModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClassModifier {
    Abstract(Span),
    Final(Span),
    Readonly(Span),
}

impl IsSpanned for ClassModifier {
    fn span(&self) -> Span {
        match self {
            ClassModifier::Abstract(span) => *span,
            ClassModifier::Final(span) => *span,
            ClassModifier::Readonly(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct ClassModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<ClassModifier>,
}

impl HasId for ClassModifierGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ClassModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConstantModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Final(Span),
}

impl IsSpanned for ConstantModifier {
    fn span(&self) -> Span {
        match self {
            ConstantModifier::Public(span) => *span,
            ConstantModifier::Protected(span) => *span,
            ConstantModifier::Private(span) => *span,
            ConstantModifier::Final(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<ConstantModifier>,
}

impl HasId for ConstantModifierGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConstantModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnbracedNamespace {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub name: SimpleIdentifier,
    pub end: Span,
    pub statements: Vec<Statement>,
}

impl HasId for UnbracedNamespace {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UnbracedNamespace {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedNamespace {
    pub id: NodeId,
    pub span: Span,
    pub namespace: Span,
    pub name: Option<SimpleIdentifier>,
    pub body: BracedNamespaceBody,
}

impl HasId for BracedNamespace {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BracedNamespace {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedNamespaceBody {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub statements: Vec<Statement>,
}

impl HasId for BracedNamespaceBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BracedNamespaceBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum NamespaceStatement {
    Unbraced(UnbracedNamespace),
    Braced(BracedNamespace),
}

impl HasId for NamespaceStatement {
    fn id(&self) -> NodeId {
        match self {
            NamespaceStatement::Unbraced(inner) => inner.id(),
            NamespaceStatement::Braced(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArithmeticOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: ArithmeticOperationKind,
}

impl HasId for ArithmeticOperationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ArithmeticOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArithmeticOperationKind {
    Addition {
        id: NodeId,
        left: Box<Expression>,
        plus: Span,
        right: Box<Expression>,
    },
    Subtraction {
        id: NodeId,
        left: Box<Expression>,
        minus: Span,
        right: Box<Expression>,
    },
    Multiplication {
        id: NodeId,
        left: Box<Expression>,
        asterisk: Span,
        right: Box<Expression>,
    },
    Division {
        id: NodeId,
        left: Box<Expression>,
        slash: Span,
        right: Box<Expression>,
    },
    Modulo {
        id: NodeId,
        left: Box<Expression>,
        percent: Span,
        right: Box<Expression>,
    },
    Exponentiation {
        id: NodeId,
        left: Box<Expression>,
        pow: Span,
        right: Box<Expression>,
    },
    Negative {
        id: NodeId,
        minus: Span,
        right: Box<Expression>,
    },
    Positive {
        id: NodeId,
        plus: Span,
        right: Box<Expression>,
    },
    PreIncrement {
        id: NodeId,
        increment: Span,
        right: Box<Expression>,
    },
    PostIncrement {
        id: NodeId,
        left: Box<Expression>,
        increment: Span,
    },
    PreDecrement {
        id: NodeId,
        decrement: Span,
        right: Box<Expression>,
    },
    PostDecrement {
        id: NodeId,
        left: Box<Expression>,
        decrement: Span,
    },
}

impl HasId for ArithmeticOperationKind {
    fn id(&self) -> NodeId {
        match self {
            ArithmeticOperationKind::Addition { id, .. } => *id,
            ArithmeticOperationKind::Subtraction { id, .. } => *id,
            ArithmeticOperationKind::Multiplication { id, .. } => *id,
            ArithmeticOperationKind::Division { id, .. } => *id,
            ArithmeticOperationKind::Modulo { id, .. } => *id,
            ArithmeticOperationKind::Exponentiation { id, .. } => *id,
            ArithmeticOperationKind::Negative { id, .. } => *id,
            ArithmeticOperationKind::Positive { id, .. } => *id,
            ArithmeticOperationKind::PreIncrement { id, .. } => *id,
            ArithmeticOperationKind::PostIncrement { id, .. } => *id,
            ArithmeticOperationKind::PreDecrement { id, .. } => *id,
            ArithmeticOperationKind::PostDecrement { id, .. } => *id,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AssignmentOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub left: Box<Expression>,
    pub kind: AssignmentOperationKind,
    pub right: Box<Expression>,
}

impl HasId for AssignmentOperationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for AssignmentOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum AssignmentOperationKind {
    Assign(Span),
    Addition(Span),
    Subtraction(Span),
    Multiplication(Span),
    Division(Span),
    Modulo(Span),
    Exponentiation(Span),
    Concat(Span),
    BitwiseAnd(Span),
    BitwiseOr(Span),
    BitwiseXor(Span),
    LeftShift(Span),
    RightShift(Span),
    Coalesce(Span),
}

impl IsSpanned for AssignmentOperationKind {
    fn span(&self) -> Span {
        match self {
            AssignmentOperationKind::Assign(span) => *span,
            AssignmentOperationKind::Addition(span) => *span,
            AssignmentOperationKind::Subtraction(span) => *span,
            AssignmentOperationKind::Multiplication(span) => *span,
            AssignmentOperationKind::Division(span) => *span,
            AssignmentOperationKind::Modulo(span) => *span,
            AssignmentOperationKind::Exponentiation(span) => *span,
            AssignmentOperationKind::Concat(span) => *span,
            AssignmentOperationKind::BitwiseAnd(span) => *span,
            AssignmentOperationKind::BitwiseOr(span) => *span,
            AssignmentOperationKind::BitwiseXor(span) => *span,
            AssignmentOperationKind::LeftShift(span) => *span,
            AssignmentOperationKind::RightShift(span) => *span,
            AssignmentOperationKind::Coalesce(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BitwiseOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: BitwiseOperationKind,
}

impl HasId for BitwiseOperationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BitwiseOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BitwiseOperationKind {
    And {
        id: NodeId,
        left: Box<Expression>,
        and: Span,
        right: Box<Expression>,
    },
    Or {
        id: NodeId,
        left: Box<Expression>,
        or: Span,
        right: Box<Expression>,
    },
    Xor {
        id: NodeId,
        left: Box<Expression>,
        xor: Span,
        right: Box<Expression>,
    },
    LeftShift {
        id: NodeId,
        left: Box<Expression>,
        left_shift: Span,
        right: Box<Expression>,
    },
    RightShift {
        id: NodeId,
        left: Box<Expression>,
        right_shift: Span,
        right: Box<Expression>,
    },
    Not {
        id: NodeId,
        not: Span,
        right: Box<Expression>,
    },
}

impl HasId for BitwiseOperationKind {
    fn id(&self) -> NodeId {
        match self {
            BitwiseOperationKind::And { id, .. } => *id,
            BitwiseOperationKind::Or { id, .. } => *id,
            BitwiseOperationKind::Xor { id, .. } => *id,
            BitwiseOperationKind::LeftShift { id, .. } => *id,
            BitwiseOperationKind::RightShift { id, .. } => *id,
            BitwiseOperationKind::Not { id, .. } => *id,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ComparisonOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: ComparisonOperationKind,
}

impl HasId for ComparisonOperationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ComparisonOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ComparisonOperationKind {
    Equal {
        id: NodeId,
        left: Box<Expression>,
        double_equals: Span,
        right: Box<Expression>,
    },
    Identical {
        id: NodeId,
        left: Box<Expression>,
        triple_equals: Span,
        right: Box<Expression>,
    },
    NotEqual {
        id: NodeId,
        left: Box<Expression>,
        bang_equals: Span,
        right: Box<Expression>,
    },
    AngledNotEqual {
        id: NodeId,
        left: Box<Expression>,
        angled_left_right: Span,
        right: Box<Expression>,
    },
    NotIdentical {
        id: NodeId,
        left: Box<Expression>,
        bang_double_equals: Span,
        right: Box<Expression>,
    },
    LessThan {
        id: NodeId,
        left: Box<Expression>,
        less_than: Span,
        right: Box<Expression>,
    },
    GreaterThan {
        id: NodeId,
        left: Box<Expression>,
        greater_than: Span,
        right: Box<Expression>,
    },
    LessThanOrEqual {
        id: NodeId,
        left: Box<Expression>,
        less_than_equals: Span,
        right: Box<Expression>,
    },
    GreaterThanOrEqual {
        id: NodeId,
        left: Box<Expression>,
        greater_than_equals: Span,
        right: Box<Expression>,
    },
    Spaceship {
        id: NodeId,
        left: Box<Expression>,
        spaceship: Span,
        right: Box<Expression>,
    },
}

impl HasId for ComparisonOperationKind {
    fn id(&self) -> NodeId {
        match self {
            ComparisonOperationKind::Equal { id, .. } => *id,
            ComparisonOperationKind::Identical { id, .. } => *id,
            ComparisonOperationKind::NotEqual { id, .. } => *id,
            ComparisonOperationKind::AngledNotEqual { id, .. } => *id,
            ComparisonOperationKind::NotIdentical { id, .. } => *id,
            ComparisonOperationKind::LessThan { id, .. } => *id,
            ComparisonOperationKind::GreaterThan { id, .. } => *id,
            ComparisonOperationKind::LessThanOrEqual { id, .. } => *id,
            ComparisonOperationKind::GreaterThanOrEqual { id, .. } => *id,
            ComparisonOperationKind::Spaceship { id, .. } => *id,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LogicalOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: LogicalOperationKind,
}

impl HasId for LogicalOperationExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for LogicalOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LogicalOperationKind {
    And {
        id: NodeId,
        left: Box<Expression>,
        double_ampersand: Span,
        right: Box<Expression>,
    },
    Or {
        id: NodeId,
        left: Box<Expression>,
        double_pipe: Span,
        right: Box<Expression>,
    },
    Not {
        id: NodeId,
        bang: Span,
        right: Box<Expression>,
    },
    LogicalAnd {
        id: NodeId,
        left: Box<Expression>,
        and: Span,
        right: Box<Expression>,
    },
    LogicalOr {
        id: NodeId,
        left: Box<Expression>,
        or: Span,
        right: Box<Expression>,
    },
    LogicalXor {
        id: NodeId,
        left: Box<Expression>,
        xor: Span,
        right: Box<Expression>,
    },
}

impl HasId for LogicalOperationKind {
    fn id(&self) -> NodeId {
        match self {
            LogicalOperationKind::And { id, .. } => *id,
            LogicalOperationKind::Or { id, .. } => *id,
            LogicalOperationKind::Not { id, .. } => *id,
            LogicalOperationKind::LogicalAnd { id, .. } => *id,
            LogicalOperationKind::LogicalOr { id, .. } => *id,
            LogicalOperationKind::LogicalXor { id, .. } => *id,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Name {
    pub id: NodeId,
    pub kind: NameKind,
    pub span: Span,
}

impl HasId for Name {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Name {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum NameKind {
    Special(SpecialName),
    Unresolved(UnresolvedName),
    Resolved(ResolvedName),
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SpecialName {
    pub kind: SpecialNameKind,
    pub symbol: ByteString,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum SpecialNameKind {
    Self_,
    Parent,
    Static,
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub struct UnresolvedName {
    pub symbol: ByteString,
    pub qualification: NameQualification,
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub struct ResolvedName {
    pub resolved: ByteString,
    pub original: ByteString,
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Property {
    Simple(SimpleProperty),
    Hooked(HookedProperty),
}

impl HasId for Property {
    fn id(&self) -> NodeId {
        match self {
            Property::Simple(inner) => inner.id(),
            Property::Hooked(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SimpleProperty {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: PropertyModifierGroup,
    pub var: Option<Span>,
    pub r#type: Option<DataType>,
    pub entries: Vec<PropertyEntry>,
    pub semicolon: Span,
}

impl HasId for SimpleProperty {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SimpleProperty {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HookedProperty {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: PropertyModifierGroup,
    pub r#type: Option<DataType>,
    pub entry: PropertyEntry,
    pub hooks: PropertyHookList,
}

impl HasId for HookedProperty {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for HookedProperty {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyHookList {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub hooks: Vec<PropertyHook>,
    pub right_brace: Span,
}

impl HasId for PropertyHookList {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PropertyHookList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyHook {
    pub id: NodeId,
    pub span: Span,
    pub kind: PropertyHookKind,
    pub parameters: Option<FunctionParameterList>,
    pub body: PropertyHookBody,
}

impl HasId for PropertyHook {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PropertyHook {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyHookBody {
    Abstract(Span),
    Concrete(ConcretePropertyHookBody),
    Invalid(Span),
}

impl HasId for PropertyHookBody {
    fn id(&self) -> NodeId {
        match self {
            PropertyHookBody::Abstract(_) => 0,
            PropertyHookBody::Concrete(inner) => inner.id(),
            PropertyHookBody::Invalid(_) => 0,
        }
    }
}

impl IsSpanned for PropertyHookBody {
    fn span(&self) -> Span {
        match self {
            PropertyHookBody::Abstract(span) => *span,
            PropertyHookBody::Invalid(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConcretePropertyHookBody {
    Block(ConcretePropertyHookBodyBlock),
    Expression(ConcretePropertyHookBodyExpression),
}

impl HasId for ConcretePropertyHookBody {
    fn id(&self) -> NodeId {
        match self {
            ConcretePropertyHookBody::Block(inner) => inner.id(),
            ConcretePropertyHookBody::Expression(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcretePropertyHookBodyBlock {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub body: Vec<Statement>,
    pub right_brace: Span,
}

impl HasId for ConcretePropertyHookBodyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConcretePropertyHookBodyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcretePropertyHookBodyExpression {
    pub id: NodeId,
    pub span: Span,
    pub arrow: Span,
    pub expression: Expression,
    pub semicolon: Span,
}

impl HasId for ConcretePropertyHookBodyExpression {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ConcretePropertyHookBodyExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyHookKind {
    Get(Span),
    Set(Span),
    Invalid(Span),
}

impl IsSpanned for PropertyHookKind {
    fn span(&self) -> Span {
        match self {
            PropertyHookKind::Get(span) => *span,
            PropertyHookKind::Set(span) => *span,
            PropertyHookKind::Invalid(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyEntry {
    pub id: NodeId,
    pub span: Span,
    pub kind: PropertyEntryKind,
}

impl HasId for PropertyEntry {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for PropertyEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyEntryKind {
    Uninitialized(UninitializedPropertyEntry),
    Initialized(InitializedPropertyEntry),
}

impl HasId for PropertyEntryKind {
    fn id(&self) -> NodeId {
        match self {
            PropertyEntryKind::Uninitialized(inner) => inner.id(),
            PropertyEntryKind::Initialized(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UninitializedPropertyEntry {
    pub id: NodeId,
    pub span: Span,
    pub variable: SimpleVariable,
}

impl HasId for UninitializedPropertyEntry {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UninitializedPropertyEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InitializedPropertyEntry {
    pub id: NodeId,
    pub span: Span,
    pub variable: SimpleVariable,
    pub equals: Span,
    pub value: Expression,
}

impl HasId for InitializedPropertyEntry {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for InitializedPropertyEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl HasId for TraitBody {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#trait: Span,
    pub name: Name,
    pub attributes: Vec<AttributeGroup>,
    pub body: TraitBody,
}

impl HasId for TraitStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsage {
    pub id: NodeId,
    pub span: Span,
    pub r#use: Span,
    pub traits: Vec<Name>,
    pub adaptations: Vec<TraitUsageAdaptation>,
}

impl HasId for TraitUsage {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitUsage {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsageAdaptation {
    pub id: NodeId,
    pub span: Span,
    pub kind: TraitUsageAdaptationKind,
}

impl HasId for TraitUsageAdaptation {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitUsageAdaptation {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TraitUsageAdaptationKind {
    Alias(TraitUsageAdaptationAlias),
    Visibility(TraitUsageAdaptationVisibility),
    Precedence(TraitUsageAdaptationPrecedence),
}

impl HasId for TraitUsageAdaptationKind {
    fn id(&self) -> NodeId {
        match self {
            TraitUsageAdaptationKind::Alias(inner) => inner.id(),
            TraitUsageAdaptationKind::Visibility(inner) => inner.id(),
            TraitUsageAdaptationKind::Precedence(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsageAdaptationAlias {
    pub id: NodeId,
    pub span: Span,
    pub r#trait: Option<Name>,
    pub method: SimpleIdentifier,
    pub alias: SimpleIdentifier,
    pub visibility: Option<VisibilityModifier>,
}

impl HasId for TraitUsageAdaptationAlias {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitUsageAdaptationAlias {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsageAdaptationVisibility {
    pub id: NodeId,
    pub span: Span,
    pub r#trait: Option<Name>,
    pub method: SimpleIdentifier,
    pub visibility: VisibilityModifier,
}

impl HasId for TraitUsageAdaptationVisibility {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitUsageAdaptationVisibility {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsageAdaptationPrecedence {
    pub id: NodeId,
    pub span: Span,
    pub r#trait: Option<Name>,
    pub method: SimpleIdentifier,
    pub insteadof: Vec<SimpleIdentifier>,
}

impl HasId for TraitUsageAdaptationPrecedence {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TraitUsageAdaptationPrecedence {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchType {
    pub id: NodeId,
    pub span: Span,
    pub kind: CatchTypeKind,
}

impl HasId for CatchType {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CatchType {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CatchTypeKind {
    Identifier(CatchTypeKindIdentifier),
    Union(CatchTypeKindUnion),
}

impl HasId for CatchTypeKind {
    fn id(&self) -> NodeId {
        match self {
            CatchTypeKind::Identifier(inner) => inner.id(),
            CatchTypeKind::Union(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchTypeKindIdentifier {
    pub id: NodeId,
    pub span: Span,
    pub identifier: SimpleIdentifier,
}

impl HasId for CatchTypeKindIdentifier {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CatchTypeKindIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchTypeKindUnion {
    pub id: NodeId,
    pub span: Span,
    pub identifiers: Vec<SimpleIdentifier>,
}

impl HasId for CatchTypeKindUnion {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CatchTypeKindUnion {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TryStatement {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub body: Block,
    pub catches: Vec<CatchBlock>,
    pub finally: Option<FinallyBlock>,
}

impl HasId for TryStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for TryStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchBlock {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub types: CatchType,
    pub var: Option<SimpleVariable>,
    pub body: Block,
}

impl HasId for CatchBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for CatchBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FinallyBlock {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub body: Block,
}

impl HasId for FinallyBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for FinallyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Variable {
    SimpleVariable(SimpleVariable),
    VariableVariable(VariableVariable),
    BracedVariableVariable(BracedVariableVariable),
}

impl HasId for Variable {
    fn id(&self) -> NodeId {
        match self {
            Variable::SimpleVariable(inner) => inner.id(),
            Variable::VariableVariable(inner) => inner.id(),
            Variable::BracedVariableVariable(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub struct SimpleVariable {
    pub id: NodeId,
    pub symbol: ByteString,
    pub stripped: ByteString,
    pub span: Span,
}

impl HasId for SimpleVariable {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SimpleVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct VariableVariable {
    pub id: NodeId,
    pub span: Span,
    pub variable: Box<Variable>,
}

impl HasId for VariableVariable {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for VariableVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedVariableVariable {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub variable: Box<Expression>,
    pub end: Span,
}

impl HasId for BracedVariableVariable {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for BracedVariableVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Ending {
    Missing(Span),
    Semicolon(Span),
    CloseTag(Span),
}

impl IsSpanned for Ending {
    fn span(&self) -> Span {
        match self {
            Ending::Missing(span) => *span,
            Ending::Semicolon(span) => *span,
            Ending::CloseTag(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticStatement {
    pub id: NodeId,
    pub span: Span,
    pub vars: Vec<StaticVar>,
    pub semicolon: Span,
}

impl HasId for StaticStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SwitchStatement {
    pub id: NodeId,
    pub span: Span,
    pub switch: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub cases: Vec<Case>,
}

impl HasId for SwitchStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SwitchStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EchoStatement {
    pub id: NodeId,
    pub span: Span,
    pub echo: Span,
    pub values: Vec<Expression>,
    pub ending: Ending,
}

impl HasId for EchoStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for EchoStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReturnStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#return: Span,
    pub value: Option<Expression>,
    pub ending: Ending,
}

impl HasId for ReturnStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for ReturnStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UseStatement {
    pub id: NodeId,
    pub span: Span,
    pub kind: UseKind,
    pub uses: Vec<Use>,
}

impl HasId for UseStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for UseStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GroupUseStatement {
    pub id: NodeId,
    pub span: Span,
    pub prefix: SimpleIdentifier,
    pub kind: UseKind,
    pub uses: Vec<Use>,
}

impl HasId for GroupUseStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for GroupUseStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HaltCompilerStatement {
    pub id: NodeId,
    pub span: Span,
    pub content: Option<OwnedToken>,
}

impl HasId for HaltCompilerStatement {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for HaltCompilerStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVar {
    pub id: NodeId,
    pub span: Span,
    pub var: Variable,
    pub default: Option<Expression>,
}

impl HasId for StaticVar {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for StaticVar {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Comment {
    pub id: NodeId,
    pub span: Span,
    pub kind: CommentKind,
}

impl HasId for Comment {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for Comment {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CommentKind {
    SingleLine(SingleLineComment),
    MultiLine(MultiLineComment),
    HashMark(HashMarkComment),
    DocBlock(DocBlockComment),
}

impl HasId for CommentKind {
    fn id(&self) -> NodeId {
        match self {
            CommentKind::SingleLine(inner) => inner.id(),
            CommentKind::MultiLine(inner) => inner.id(),
            CommentKind::HashMark(inner) => inner.id(),
            CommentKind::DocBlock(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SingleLineComment {
    pub id: NodeId,
    pub span: Span,
    pub content: ByteString,
}

impl HasId for SingleLineComment {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for SingleLineComment {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MultiLineComment {
    pub id: NodeId,
    pub span: Span,
    pub content: ByteString,
}

impl HasId for MultiLineComment {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for MultiLineComment {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HashMarkComment {
    pub id: NodeId,
    pub span: Span,
    pub content: ByteString,
}

impl HasId for HashMarkComment {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for HashMarkComment {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockComment {
    pub id: NodeId,
    pub span: Span,
    pub doc: DocBlock,
}

impl HasId for DocBlockComment {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockComment {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlock {
    pub id: NodeId,
    pub span: Span,
    pub nodes: Vec<DocBlockNode>,
}

impl HasId for DocBlock {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DocBlockNode {
    Text(DocBlockTextNode),
    Tag(DocBlockTagNode),
}

impl HasId for DocBlockNode {
    fn id(&self) -> NodeId {
        match self {
            DocBlockNode::Text(inner) => inner.id(),
            DocBlockNode::Tag(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockTextNode {
    pub id: NodeId,
    pub span: Span,
    pub content: ByteString,
}

impl HasId for DocBlockTextNode {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockTextNode {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockTagNode {
    pub id: NodeId,
    pub span: Span,
    pub tag: DocBlockTag,
}

impl HasId for DocBlockTagNode {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockTagNode {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DocBlockTag {
    ParamClosureThis(DocBlockParamClosureThisTag),
    Param(DocBlockParamTag),
    Return(DocBlockReturnTag),
    Throws(DocBlockThrowsTag),
    Var(DocBlockVarTag),
    Property(DocBlockPropertyTag),
    Method(DocBlockMethodTag),
    Template(DocBlockTemplateTag),
    Extends(DocBlockExtendsTag),
    Implements(DocBlockImplementsTag),
    Uses(DocBlockUsesTag),
    Deprecated(DocBlockDeprecatedTag),
    Generic(DocBlockGenericTag),
}

impl HasId for DocBlockTag {
    fn id(&self) -> NodeId {
        match self {
            DocBlockTag::ParamClosureThis(inner) => inner.id(),
            DocBlockTag::Param(inner) => inner.id(),
            DocBlockTag::Return(inner) => inner.id(),
            DocBlockTag::Throws(inner) => inner.id(),
            DocBlockTag::Var(inner) => inner.id(),
            DocBlockTag::Property(inner) => inner.id(),
            DocBlockTag::Method(inner) => inner.id(),
            DocBlockTag::Template(inner) => inner.id(),
            DocBlockTag::Extends(inner) => inner.id(),
            DocBlockTag::Implements(inner) => inner.id(),
            DocBlockTag::Uses(inner) => inner.id(),
            DocBlockTag::Deprecated(inner) => inner.id(),
            DocBlockTag::Generic(inner) => inner.id(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockParamClosureThisTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub r#type: DataType,
    pub variable: SimpleVariable,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockParamClosureThisTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockParamClosureThisTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockParamTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: Option<DataType>,
    pub ampersand: Option<Span>,
    pub ellipsis: Option<Span>,
    pub variable: Option<SimpleVariable>,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockParamTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockParamTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockReturnTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: Option<DataType>,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockReturnTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockReturnTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockThrowsTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: Option<DataType>,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockThrowsTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockThrowsTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockVarTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: Option<DataType>,
    pub variable: Option<SimpleVariable>,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockVarTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockVarTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockPropertyTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: Option<DataType>,
    pub variable: SimpleVariable,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockPropertyTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockPropertyTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockMethodTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub r#static: Option<Span>,
    pub return_type: Option<DataType>,
    pub name: SimpleIdentifier,
    pub templates: Vec<DocBlockTemplateTagValue>,
    pub parameters: FunctionParameterList,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockMethodTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockMethodTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockTemplateTagValue {
    pub id: NodeId,
    pub span: Span,
    pub template: SimpleIdentifier,
    pub bound: Option<DataType>,
    pub default: Option<DataType>,
    pub lower_bound: Option<DataType>,
    pub description: Option<DocBlockTextNode>,
}

impl HasId for DocBlockTemplateTagValue {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockTemplateTagValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockTemplateTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub value: DocBlockTemplateTagValue,
}

impl HasId for DocBlockTemplateTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockTemplateTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockExtendsTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: DataType,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockExtendsTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockExtendsTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockImplementsTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: DataType,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockImplementsTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockImplementsTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockUsesTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub data_type: DataType,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockUsesTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockUsesTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockDeprecatedTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockDeprecatedTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockDeprecatedTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DocBlockGenericTag {
    pub id: NodeId,
    pub span: Span,
    pub tag: OwnedToken,
    pub text: Option<ByteString>,
}

impl HasId for DocBlockGenericTag {
    fn id(&self) -> NodeId {
        self.id
    }
}

impl IsSpanned for DocBlockGenericTag {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct CommentGroup {
    pub id: NodeId,
    pub comments: Vec<Comment>,
}

impl HasId for CommentGroup {
    fn id(&self) -> NodeId {
        self.id
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum NodeKind<'a> {
    Block(&'a Block),
    Statement(&'a Statement),
    StatementKind(&'a StatementKind),
    Expression(&'a Expression),
    ExpressionKind(&'a ExpressionKind),
    MissingExpression(&'a MissingExpression),
    StaticExpression(&'a StaticExpression),
    SelfExpression(&'a SelfExpression),
    ParentExpression(&'a ParentExpression),
    CommentStatement(&'a CommentStatement),
    InlineHtmlStatement(&'a InlineHtmlStatement),
    FullOpeningTagStatement(&'a FullOpeningTagStatement),
    ShortOpeningTagStatement(&'a ShortOpeningTagStatement),
    EchoOpeningTagStatement(&'a EchoOpeningTagStatement),
    ClosingTagStatement(&'a ClosingTagStatement),
    ExpressionStatement(&'a ExpressionStatement),
    GlobalStatement(&'a GlobalStatement),
    BlockStatement(&'a BlockStatement),
    Case(&'a Case),
    Use(&'a Use),
    EvalExpression(&'a EvalExpression),
    EmptyExpression(&'a EmptyExpression),
    DieExpression(&'a DieExpression),
    ExitExpression(&'a ExitExpression),
    IssetExpression(&'a IssetExpression),
    UnsetExpression(&'a UnsetExpression),
    PrintExpression(&'a PrintExpression),
    ConcatExpression(&'a ConcatExpression),
    InstanceofExpression(&'a InstanceofExpression),
    ReferenceExpression(&'a ReferenceExpression),
    ParenthesizedExpression(&'a ParenthesizedExpression),
    ErrorSuppressExpression(&'a ErrorSuppressExpression),
    IncludeExpression(&'a IncludeExpression),
    IncludeOnceExpression(&'a IncludeOnceExpression),
    RequireExpression(&'a RequireExpression),
    RequireOnceExpression(&'a RequireOnceExpression),
    FunctionCallExpression(&'a FunctionCallExpression),
    FunctionClosureCreationExpression(&'a FunctionClosureCreationExpression),
    MethodCallExpression(&'a MethodCallExpression),
    MethodClosureCreationExpression(&'a MethodClosureCreationExpression),
    NullsafeMethodCallExpression(&'a NullsafeMethodCallExpression),
    StaticMethodCallExpression(&'a StaticMethodCallExpression),
    StaticVariableMethodCallExpression(&'a StaticVariableMethodCallExpression),
    StaticMethodClosureCreationExpression(&'a StaticMethodClosureCreationExpression),
    StaticVariableMethodClosureCreationExpression(
        &'a StaticVariableMethodClosureCreationExpression,
    ),
    PropertyFetchExpression(&'a PropertyFetchExpression),
    NullsafePropertyFetchExpression(&'a NullsafePropertyFetchExpression),
    StaticPropertyFetchExpression(&'a StaticPropertyFetchExpression),
    ConstantFetchExpression(&'a ConstantFetchExpression),
    ArrayExpression(&'a ArrayExpression),
    ListExpression(&'a ListExpression),
    NewExpression(&'a NewExpression),
    InterpolatedStringExpression(&'a InterpolatedStringExpression),
    HeredocExpression(&'a HeredocExpression),
    NowdocExpression(&'a NowdocExpression),
    ShellExecExpression(&'a ShellExecExpression),
    BoolExpression(&'a BoolExpression),
    ArrayIndexExpression(&'a ArrayIndexExpression),
    ShortTernaryExpression(&'a ShortTernaryExpression),
    TernaryExpression(&'a TernaryExpression),
    CoalesceExpression(&'a CoalesceExpression),
    CloneExpression(&'a CloneExpression),
    MatchExpression(&'a MatchExpression),
    ThrowExpression(&'a ThrowExpression),
    YieldExpression(&'a YieldExpression),
    YieldFromExpression(&'a YieldFromExpression),
    CastExpression(&'a CastExpression),
    DefaultMatchArm(&'a DefaultMatchArm),
    MatchArm(&'a MatchArm),
    MagicConstantExpression(&'a MagicConstantExpression),
    StringPart(&'a StringPart),
    LiteralStringPart(&'a LiteralStringPart),
    ExpressionStringPart(&'a ExpressionStringPart),
    ArrayItem(&'a ArrayItem),
    ArrayItemValue(&'a ArrayItemValue),
    ArrayItemReferencedValue(&'a ArrayItemReferencedValue),
    ArrayItemSpreadValue(&'a ArrayItemSpreadValue),
    ArrayItemKeyValue(&'a ArrayItemKeyValue),
    ArrayItemReferencedKeyValue(&'a ArrayItemReferencedKeyValue),
    ListEntry(&'a ListEntry),
    ListEntryValue(&'a ListEntryValue),
    ListEntryKeyValue(&'a ListEntryKeyValue),
    PositionalArgument(&'a PositionalArgument),
    NamedArgument(&'a NamedArgument),
    Argument(&'a Argument),
    ArgumentList(&'a ArgumentList),
    SingleArgument(&'a SingleArgument),
    ArgumentPlaceholder(&'a ArgumentPlaceholder),
    Attribute(&'a Attribute),
    AttributeGroup(&'a AttributeGroup),
    ClassBody(&'a ClassBody),
    ClassStatement(&'a ClassStatement),
    AnonymousClassBody(&'a AnonymousClassBody),
    AnonymousClassExpression(&'a AnonymousClassExpression),
    ClassExtends(&'a ClassExtends),
    ClassImplements(&'a ClassImplements),
    ClassishMember(&'a ClassishMember),
    Method(&'a Method),
    MethodBody(&'a MethodBody),
    MethodBodyKind(&'a MethodBodyKind),
    MissingMethodBody(&'a MissingMethodBody),
    AbstractMethodBody(&'a AbstractMethodBody),
    ConcreteMethodBody(&'a ConcreteMethodBody),
    MethodParameterList(&'a MethodParameterList),
    MethodParameter(&'a MethodParameter),
    MissingClassishMember(&'a MissingClassishMember),
    ConstantEntry(&'a ConstantEntry),
    ClassishConstantEntry(&'a ClassishConstantEntry),
    ConstantStatement(&'a ConstantStatement),
    ClassishConstant(&'a ClassishConstant),
    IfStatement(&'a IfStatement),
    IfStatementBody(&'a IfStatementBody),
    IfStatementBodyStatement(&'a IfStatementBodyStatement),
    IfStatementBodyBlock(&'a IfStatementBodyBlock),
    IfStatementElseIf(&'a IfStatementElseIf),
    IfStatementElse(&'a IfStatementElse),
    IfStatementElseIfBlock(&'a IfStatementElseIfBlock),
    IfStatementElseBlock(&'a IfStatementElseBlock),
    DataType(&'a DataType),
    DeclareEntry(&'a DeclareEntry),
    DeclareEntryGroup(&'a DeclareEntryGroup),
    DeclareBody(&'a DeclareBody),
    DeclareBodyNoop(&'a DeclareBodyNoop),
    DeclareBodyBraced(&'a DeclareBodyBraced),
    DeclareBodyExpression(&'a DeclareBodyExpression),
    DeclareBodyBlock(&'a DeclareBodyBlock),
    DeclareStatement(&'a DeclareStatement),
    UnitEnumCase(&'a UnitEnumCase),
    UnitEnumMember(&'a UnitEnumMember),
    UnitEnumBody(&'a UnitEnumBody),
    UnitEnumStatement(&'a UnitEnumStatement),
    BackedEnumCase(&'a BackedEnumCase),
    BackedEnumMember(&'a BackedEnumMember),
    BackedEnumBody(&'a BackedEnumBody),
    BackedEnumStatement(&'a BackedEnumStatement),
    ReturnType(&'a ReturnType),
    FunctionParameter(&'a FunctionParameter),
    FunctionParameterList(&'a FunctionParameterList),
    FunctionBody(&'a FunctionBody),
    FunctionStatement(&'a FunctionStatement),
    ClosureUseVariable(&'a ClosureUseVariable),
    ClosureUse(&'a ClosureUse),
    ClosureExpression(&'a ClosureExpression),
    ArrowFunctionExpression(&'a ArrowFunctionExpression),
    LabelStatement(&'a LabelStatement),
    GotoStatement(&'a GotoStatement),
    Identifier(&'a Identifier),
    SimpleIdentifier(&'a SimpleIdentifier),
    DynamicIdentifier(&'a DynamicIdentifier),
    InterfaceExtends(&'a InterfaceExtends),
    InterfaceBody(&'a InterfaceBody),
    InterfaceStatement(&'a InterfaceStatement),
    Literal(&'a Literal),
    ForeachStatement(&'a ForeachStatement),
    ForeachStatementIterator(&'a ForeachStatementIterator),
    ForeachStatementIteratorValue(&'a ForeachStatementIteratorValue),
    ForeachStatementIteratorKeyAndValue(&'a ForeachStatementIteratorKeyAndValue),
    ForeachStatementBody(&'a ForeachStatementBody),
    ForeachStatementBodyStatement(&'a ForeachStatementBodyStatement),
    ForeachStatementBodyBlock(&'a ForeachStatementBodyBlock),
    ForStatement(&'a ForStatement),
    ForStatementIterator(&'a ForStatementIterator),
    ForStatementBody(&'a ForStatementBody),
    ForStatementBodyStatement(&'a ForStatementBodyStatement),
    ForStatementBodyBlock(&'a ForStatementBodyBlock),
    DoWhileStatement(&'a DoWhileStatement),
    WhileStatement(&'a WhileStatement),
    WhileStatementBody(&'a WhileStatementBody),
    WhileStatementBodyStatement(&'a WhileStatementBodyStatement),
    WhileStatementBodyBlock(&'a WhileStatementBodyBlock),
    Level(&'a Level),
    LiteralLevel(&'a LiteralLevel),
    ParenthesizedLevel(&'a ParenthesizedLevel),
    BreakStatement(&'a BreakStatement),
    ContinueStatement(&'a ContinueStatement),
    PromotedPropertyModifierGroup(&'a PromotedPropertyModifierGroup),
    PropertyModifierGroup(&'a PropertyModifierGroup),
    MethodModifierGroup(&'a MethodModifierGroup),
    ClassModifierGroup(&'a ClassModifierGroup),
    ConstantModifierGroup(&'a ConstantModifierGroup),
    UnbracedNamespace(&'a UnbracedNamespace),
    BracedNamespace(&'a BracedNamespace),
    BracedNamespaceBody(&'a BracedNamespaceBody),
    NamespaceStatement(&'a NamespaceStatement),
    ArithmeticOperationExpression(&'a ArithmeticOperationExpression),
    ArithmeticOperationKind(&'a ArithmeticOperationKind),
    AssignmentOperationExpression(&'a AssignmentOperationExpression),
    BitwiseOperationExpression(&'a BitwiseOperationExpression),
    BitwiseOperationKind(&'a BitwiseOperationKind),
    ComparisonOperationExpression(&'a ComparisonOperationExpression),
    ComparisonOperationKind(&'a ComparisonOperationKind),
    LogicalOperationExpression(&'a LogicalOperationExpression),
    LogicalOperationKind(&'a LogicalOperationKind),
    Name(&'a Name),
    Property(&'a Property),
    SimpleProperty(&'a SimpleProperty),
    HookedProperty(&'a HookedProperty),
    PropertyHookList(&'a PropertyHookList),
    PropertyHook(&'a PropertyHook),
    PropertyHookBody(&'a PropertyHookBody),
    ConcretePropertyHookBody(&'a ConcretePropertyHookBody),
    ConcretePropertyHookBodyBlock(&'a ConcretePropertyHookBodyBlock),
    ConcretePropertyHookBodyExpression(&'a ConcretePropertyHookBodyExpression),
    PropertyEntry(&'a PropertyEntry),
    PropertyEntryKind(&'a PropertyEntryKind),
    UninitializedPropertyEntry(&'a UninitializedPropertyEntry),
    InitializedPropertyEntry(&'a InitializedPropertyEntry),
    TraitBody(&'a TraitBody),
    TraitStatement(&'a TraitStatement),
    TraitUsage(&'a TraitUsage),
    TraitUsageAdaptation(&'a TraitUsageAdaptation),
    TraitUsageAdaptationKind(&'a TraitUsageAdaptationKind),
    TraitUsageAdaptationAlias(&'a TraitUsageAdaptationAlias),
    TraitUsageAdaptationVisibility(&'a TraitUsageAdaptationVisibility),
    TraitUsageAdaptationPrecedence(&'a TraitUsageAdaptationPrecedence),
    CatchType(&'a CatchType),
    CatchTypeKind(&'a CatchTypeKind),
    CatchTypeKindIdentifier(&'a CatchTypeKindIdentifier),
    CatchTypeKindUnion(&'a CatchTypeKindUnion),
    TryStatement(&'a TryStatement),
    CatchBlock(&'a CatchBlock),
    FinallyBlock(&'a FinallyBlock),
    Variable(&'a Variable),
    SimpleVariable(&'a SimpleVariable),
    VariableVariable(&'a VariableVariable),
    BracedVariableVariable(&'a BracedVariableVariable),
    StaticStatement(&'a StaticStatement),
    SwitchStatement(&'a SwitchStatement),
    EchoStatement(&'a EchoStatement),
    ReturnStatement(&'a ReturnStatement),
    UseStatement(&'a UseStatement),
    GroupUseStatement(&'a GroupUseStatement),
    HaltCompilerStatement(&'a HaltCompilerStatement),
    StaticVar(&'a StaticVar),
    Comment(&'a Comment),
    CommentKind(&'a CommentKind),
    SingleLineComment(&'a SingleLineComment),
    MultiLineComment(&'a MultiLineComment),
    HashMarkComment(&'a HashMarkComment),
    DocBlockComment(&'a DocBlockComment),
    DocBlock(&'a DocBlock),
    DocBlockNode(&'a DocBlockNode),
    DocBlockTextNode(&'a DocBlockTextNode),
    DocBlockTagNode(&'a DocBlockTagNode),
    DocBlockTag(&'a DocBlockTag),
    DocBlockParamClosureThisTag(&'a DocBlockParamClosureThisTag),
    DocBlockParamTag(&'a DocBlockParamTag),
    DocBlockReturnTag(&'a DocBlockReturnTag),
    DocBlockThrowsTag(&'a DocBlockThrowsTag),
    DocBlockVarTag(&'a DocBlockVarTag),
    DocBlockPropertyTag(&'a DocBlockPropertyTag),
    DocBlockMethodTag(&'a DocBlockMethodTag),
    DocBlockTemplateTagValue(&'a DocBlockTemplateTagValue),
    DocBlockTemplateTag(&'a DocBlockTemplateTag),
    DocBlockExtendsTag(&'a DocBlockExtendsTag),
    DocBlockImplementsTag(&'a DocBlockImplementsTag),
    DocBlockUsesTag(&'a DocBlockUsesTag),
    DocBlockDeprecatedTag(&'a DocBlockDeprecatedTag),
    DocBlockGenericTag(&'a DocBlockGenericTag),
    CommentGroup(&'a CommentGroup),
}

impl<'a> Node<'a> {
    pub fn as_block(self) -> Option<&'a Block> {
        match &self.kind {
            NodeKind::Block(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_block(&self) -> bool {
        matches!(&self.kind, NodeKind::Block(_))
    }

    pub fn as_statement(self) -> Option<&'a Statement> {
        match &self.kind {
            NodeKind::Statement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::Statement(_))
    }

    pub fn as_statement_kind(self) -> Option<&'a StatementKind> {
        match &self.kind {
            NodeKind::StatementKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_statement_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::StatementKind(_))
    }

    pub fn as_expression(self) -> Option<&'a Expression> {
        match &self.kind {
            NodeKind::Expression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::Expression(_))
    }

    pub fn as_expression_kind(self) -> Option<&'a ExpressionKind> {
        match &self.kind {
            NodeKind::ExpressionKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::ExpressionKind(_))
    }

    pub fn as_missing_expression(self) -> Option<&'a MissingExpression> {
        match &self.kind {
            NodeKind::MissingExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_missing_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::MissingExpression(_))
    }

    pub fn as_static_expression(self) -> Option<&'a StaticExpression> {
        match &self.kind {
            NodeKind::StaticExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::StaticExpression(_))
    }

    pub fn as_self_expression(self) -> Option<&'a SelfExpression> {
        match &self.kind {
            NodeKind::SelfExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_self_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::SelfExpression(_))
    }

    pub fn as_parent_expression(self) -> Option<&'a ParentExpression> {
        match &self.kind {
            NodeKind::ParentExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_parent_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ParentExpression(_))
    }

    pub fn as_comment_statement(self) -> Option<&'a CommentStatement> {
        match &self.kind {
            NodeKind::CommentStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comment_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::CommentStatement(_))
    }

    pub fn as_inline_html_statement(self) -> Option<&'a InlineHtmlStatement> {
        match &self.kind {
            NodeKind::InlineHtmlStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_inline_html_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::InlineHtmlStatement(_))
    }

    pub fn as_full_opening_tag_statement(self) -> Option<&'a FullOpeningTagStatement> {
        match &self.kind {
            NodeKind::FullOpeningTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_full_opening_tag_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::FullOpeningTagStatement(_))
    }

    pub fn as_short_opening_tag_statement(self) -> Option<&'a ShortOpeningTagStatement> {
        match &self.kind {
            NodeKind::ShortOpeningTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_short_opening_tag_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ShortOpeningTagStatement(_))
    }

    pub fn as_echo_opening_tag_statement(self) -> Option<&'a EchoOpeningTagStatement> {
        match &self.kind {
            NodeKind::EchoOpeningTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_echo_opening_tag_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::EchoOpeningTagStatement(_))
    }

    pub fn as_closing_tag_statement(self) -> Option<&'a ClosingTagStatement> {
        match &self.kind {
            NodeKind::ClosingTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closing_tag_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ClosingTagStatement(_))
    }

    pub fn as_expression_statement(self) -> Option<&'a ExpressionStatement> {
        match &self.kind {
            NodeKind::ExpressionStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ExpressionStatement(_))
    }

    pub fn as_global_statement(self) -> Option<&'a GlobalStatement> {
        match &self.kind {
            NodeKind::GlobalStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_global_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::GlobalStatement(_))
    }

    pub fn as_block_statement(self) -> Option<&'a BlockStatement> {
        match &self.kind {
            NodeKind::BlockStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_block_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::BlockStatement(_))
    }

    pub fn as_case(self) -> Option<&'a Case> {
        match &self.kind {
            NodeKind::Case(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_case(&self) -> bool {
        matches!(&self.kind, NodeKind::Case(_))
    }

    pub fn as_use(self) -> Option<&'a Use> {
        match &self.kind {
            NodeKind::Use(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_use(&self) -> bool {
        matches!(&self.kind, NodeKind::Use(_))
    }

    pub fn as_eval_expression(self) -> Option<&'a EvalExpression> {
        match &self.kind {
            NodeKind::EvalExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_eval_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::EvalExpression(_))
    }

    pub fn as_empty_expression(self) -> Option<&'a EmptyExpression> {
        match &self.kind {
            NodeKind::EmptyExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_empty_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::EmptyExpression(_))
    }

    pub fn as_die_expression(self) -> Option<&'a DieExpression> {
        match &self.kind {
            NodeKind::DieExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_die_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::DieExpression(_))
    }

    pub fn as_exit_expression(self) -> Option<&'a ExitExpression> {
        match &self.kind {
            NodeKind::ExitExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_exit_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ExitExpression(_))
    }

    pub fn as_isset_expression(self) -> Option<&'a IssetExpression> {
        match &self.kind {
            NodeKind::IssetExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_isset_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::IssetExpression(_))
    }

    pub fn as_unset_expression(self) -> Option<&'a UnsetExpression> {
        match &self.kind {
            NodeKind::UnsetExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unset_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::UnsetExpression(_))
    }

    pub fn as_print_expression(self) -> Option<&'a PrintExpression> {
        match &self.kind {
            NodeKind::PrintExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_print_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::PrintExpression(_))
    }

    pub fn as_concat_expression(self) -> Option<&'a ConcatExpression> {
        match &self.kind {
            NodeKind::ConcatExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concat_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ConcatExpression(_))
    }

    pub fn as_instanceof_expression(self) -> Option<&'a InstanceofExpression> {
        match &self.kind {
            NodeKind::InstanceofExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_instanceof_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::InstanceofExpression(_))
    }

    pub fn as_reference_expression(self) -> Option<&'a ReferenceExpression> {
        match &self.kind {
            NodeKind::ReferenceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_reference_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ReferenceExpression(_))
    }

    pub fn as_parenthesized_expression(self) -> Option<&'a ParenthesizedExpression> {
        match &self.kind {
            NodeKind::ParenthesizedExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_parenthesized_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ParenthesizedExpression(_))
    }

    pub fn as_error_suppress_expression(self) -> Option<&'a ErrorSuppressExpression> {
        match &self.kind {
            NodeKind::ErrorSuppressExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_error_suppress_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ErrorSuppressExpression(_))
    }

    pub fn as_include_expression(self) -> Option<&'a IncludeExpression> {
        match &self.kind {
            NodeKind::IncludeExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_include_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::IncludeExpression(_))
    }

    pub fn as_include_once_expression(self) -> Option<&'a IncludeOnceExpression> {
        match &self.kind {
            NodeKind::IncludeOnceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_include_once_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::IncludeOnceExpression(_))
    }

    pub fn as_require_expression(self) -> Option<&'a RequireExpression> {
        match &self.kind {
            NodeKind::RequireExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_require_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::RequireExpression(_))
    }

    pub fn as_require_once_expression(self) -> Option<&'a RequireOnceExpression> {
        match &self.kind {
            NodeKind::RequireOnceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_require_once_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::RequireOnceExpression(_))
    }

    pub fn as_function_call_expression(self) -> Option<&'a FunctionCallExpression> {
        match &self.kind {
            NodeKind::FunctionCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_call_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::FunctionCallExpression(_))
    }

    pub fn as_function_closure_creation_expression(
        self,
    ) -> Option<&'a FunctionClosureCreationExpression> {
        match &self.kind {
            NodeKind::FunctionClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_closure_creation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::FunctionClosureCreationExpression(_))
    }

    pub fn as_method_call_expression(self) -> Option<&'a MethodCallExpression> {
        match &self.kind {
            NodeKind::MethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_call_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodCallExpression(_))
    }

    pub fn as_method_closure_creation_expression(
        self,
    ) -> Option<&'a MethodClosureCreationExpression> {
        match &self.kind {
            NodeKind::MethodClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_closure_creation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodClosureCreationExpression(_))
    }

    pub fn as_nullsafe_method_call_expression(self) -> Option<&'a NullsafeMethodCallExpression> {
        match &self.kind {
            NodeKind::NullsafeMethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_nullsafe_method_call_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::NullsafeMethodCallExpression(_))
    }

    pub fn as_static_method_call_expression(self) -> Option<&'a StaticMethodCallExpression> {
        match &self.kind {
            NodeKind::StaticMethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_method_call_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::StaticMethodCallExpression(_))
    }

    pub fn as_static_variable_method_call_expression(
        self,
    ) -> Option<&'a StaticVariableMethodCallExpression> {
        match &self.kind {
            NodeKind::StaticVariableMethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_variable_method_call_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::StaticVariableMethodCallExpression(_))
    }

    pub fn as_static_method_closure_creation_expression(
        self,
    ) -> Option<&'a StaticMethodClosureCreationExpression> {
        match &self.kind {
            NodeKind::StaticMethodClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_method_closure_creation_expression(&self) -> bool {
        matches!(
            &self.kind,
            NodeKind::StaticMethodClosureCreationExpression(_)
        )
    }

    pub fn as_static_variable_method_closure_creation_expression(
        self,
    ) -> Option<&'a StaticVariableMethodClosureCreationExpression> {
        match &self.kind {
            NodeKind::StaticVariableMethodClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_variable_method_closure_creation_expression(&self) -> bool {
        matches!(
            &self.kind,
            NodeKind::StaticVariableMethodClosureCreationExpression(_)
        )
    }

    pub fn as_property_fetch_expression(self) -> Option<&'a PropertyFetchExpression> {
        match &self.kind {
            NodeKind::PropertyFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_fetch_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyFetchExpression(_))
    }

    pub fn as_nullsafe_property_fetch_expression(
        self,
    ) -> Option<&'a NullsafePropertyFetchExpression> {
        match &self.kind {
            NodeKind::NullsafePropertyFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_nullsafe_property_fetch_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::NullsafePropertyFetchExpression(_))
    }

    pub fn as_static_property_fetch_expression(self) -> Option<&'a StaticPropertyFetchExpression> {
        match &self.kind {
            NodeKind::StaticPropertyFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_property_fetch_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::StaticPropertyFetchExpression(_))
    }

    pub fn as_constant_fetch_expression(self) -> Option<&'a ConstantFetchExpression> {
        match &self.kind {
            NodeKind::ConstantFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_fetch_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ConstantFetchExpression(_))
    }

    pub fn as_array_expression(self) -> Option<&'a ArrayExpression> {
        match &self.kind {
            NodeKind::ArrayExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayExpression(_))
    }

    pub fn as_list_expression(self) -> Option<&'a ListExpression> {
        match &self.kind {
            NodeKind::ListExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ListExpression(_))
    }

    pub fn as_new_expression(self) -> Option<&'a NewExpression> {
        match &self.kind {
            NodeKind::NewExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_new_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::NewExpression(_))
    }

    pub fn as_interpolated_string_expression(self) -> Option<&'a InterpolatedStringExpression> {
        match &self.kind {
            NodeKind::InterpolatedStringExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interpolated_string_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::InterpolatedStringExpression(_))
    }

    pub fn as_heredoc_expression(self) -> Option<&'a HeredocExpression> {
        match &self.kind {
            NodeKind::HeredocExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_heredoc_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::HeredocExpression(_))
    }

    pub fn as_nowdoc_expression(self) -> Option<&'a NowdocExpression> {
        match &self.kind {
            NodeKind::NowdocExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_nowdoc_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::NowdocExpression(_))
    }

    pub fn as_shell_exec_expression(self) -> Option<&'a ShellExecExpression> {
        match &self.kind {
            NodeKind::ShellExecExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_shell_exec_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ShellExecExpression(_))
    }

    pub fn as_bool_expression(self) -> Option<&'a BoolExpression> {
        match &self.kind {
            NodeKind::BoolExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_bool_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::BoolExpression(_))
    }

    pub fn as_array_index_expression(self) -> Option<&'a ArrayIndexExpression> {
        match &self.kind {
            NodeKind::ArrayIndexExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_index_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayIndexExpression(_))
    }

    pub fn as_short_ternary_expression(self) -> Option<&'a ShortTernaryExpression> {
        match &self.kind {
            NodeKind::ShortTernaryExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_short_ternary_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ShortTernaryExpression(_))
    }

    pub fn as_ternary_expression(self) -> Option<&'a TernaryExpression> {
        match &self.kind {
            NodeKind::TernaryExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_ternary_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::TernaryExpression(_))
    }

    pub fn as_coalesce_expression(self) -> Option<&'a CoalesceExpression> {
        match &self.kind {
            NodeKind::CoalesceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_coalesce_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::CoalesceExpression(_))
    }

    pub fn as_clone_expression(self) -> Option<&'a CloneExpression> {
        match &self.kind {
            NodeKind::CloneExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_clone_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::CloneExpression(_))
    }

    pub fn as_match_expression(self) -> Option<&'a MatchExpression> {
        match &self.kind {
            NodeKind::MatchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_match_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::MatchExpression(_))
    }

    pub fn as_throw_expression(self) -> Option<&'a ThrowExpression> {
        match &self.kind {
            NodeKind::ThrowExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_throw_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ThrowExpression(_))
    }

    pub fn as_yield_expression(self) -> Option<&'a YieldExpression> {
        match &self.kind {
            NodeKind::YieldExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_yield_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::YieldExpression(_))
    }

    pub fn as_yield_from_expression(self) -> Option<&'a YieldFromExpression> {
        match &self.kind {
            NodeKind::YieldFromExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_yield_from_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::YieldFromExpression(_))
    }

    pub fn as_cast_expression(self) -> Option<&'a CastExpression> {
        match &self.kind {
            NodeKind::CastExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_cast_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::CastExpression(_))
    }

    pub fn as_default_match_arm(self) -> Option<&'a DefaultMatchArm> {
        match &self.kind {
            NodeKind::DefaultMatchArm(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_default_match_arm(&self) -> bool {
        matches!(&self.kind, NodeKind::DefaultMatchArm(_))
    }

    pub fn as_match_arm(self) -> Option<&'a MatchArm> {
        match &self.kind {
            NodeKind::MatchArm(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_match_arm(&self) -> bool {
        matches!(&self.kind, NodeKind::MatchArm(_))
    }

    pub fn as_magic_constant_expression(self) -> Option<&'a MagicConstantExpression> {
        match &self.kind {
            NodeKind::MagicConstantExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_magic_constant_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::MagicConstantExpression(_))
    }

    pub fn as_string_part(self) -> Option<&'a StringPart> {
        match &self.kind {
            NodeKind::StringPart(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_string_part(&self) -> bool {
        matches!(&self.kind, NodeKind::StringPart(_))
    }

    pub fn as_literal_string_part(self) -> Option<&'a LiteralStringPart> {
        match &self.kind {
            NodeKind::LiteralStringPart(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_literal_string_part(&self) -> bool {
        matches!(&self.kind, NodeKind::LiteralStringPart(_))
    }

    pub fn as_expression_string_part(self) -> Option<&'a ExpressionStringPart> {
        match &self.kind {
            NodeKind::ExpressionStringPart(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression_string_part(&self) -> bool {
        matches!(&self.kind, NodeKind::ExpressionStringPart(_))
    }

    pub fn as_array_item(self) -> Option<&'a ArrayItem> {
        match &self.kind {
            NodeKind::ArrayItem(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayItem(_))
    }

    pub fn as_array_item_value(self) -> Option<&'a ArrayItemValue> {
        match &self.kind {
            NodeKind::ArrayItemValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayItemValue(_))
    }

    pub fn as_array_item_referenced_value(self) -> Option<&'a ArrayItemReferencedValue> {
        match &self.kind {
            NodeKind::ArrayItemReferencedValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_referenced_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayItemReferencedValue(_))
    }

    pub fn as_array_item_spread_value(self) -> Option<&'a ArrayItemSpreadValue> {
        match &self.kind {
            NodeKind::ArrayItemSpreadValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_spread_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayItemSpreadValue(_))
    }

    pub fn as_array_item_key_value(self) -> Option<&'a ArrayItemKeyValue> {
        match &self.kind {
            NodeKind::ArrayItemKeyValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_key_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayItemKeyValue(_))
    }

    pub fn as_array_item_referenced_key_value(self) -> Option<&'a ArrayItemReferencedKeyValue> {
        match &self.kind {
            NodeKind::ArrayItemReferencedKeyValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_referenced_key_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrayItemReferencedKeyValue(_))
    }

    pub fn as_list_entry(self) -> Option<&'a ListEntry> {
        match &self.kind {
            NodeKind::ListEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::ListEntry(_))
    }

    pub fn as_list_entry_value(self) -> Option<&'a ListEntryValue> {
        match &self.kind {
            NodeKind::ListEntryValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_entry_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ListEntryValue(_))
    }

    pub fn as_list_entry_key_value(self) -> Option<&'a ListEntryKeyValue> {
        match &self.kind {
            NodeKind::ListEntryKeyValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_entry_key_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ListEntryKeyValue(_))
    }

    pub fn as_positional_argument(self) -> Option<&'a PositionalArgument> {
        match &self.kind {
            NodeKind::PositionalArgument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_positional_argument(&self) -> bool {
        matches!(&self.kind, NodeKind::PositionalArgument(_))
    }

    pub fn as_named_argument(self) -> Option<&'a NamedArgument> {
        match &self.kind {
            NodeKind::NamedArgument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_named_argument(&self) -> bool {
        matches!(&self.kind, NodeKind::NamedArgument(_))
    }

    pub fn as_argument(self) -> Option<&'a Argument> {
        match &self.kind {
            NodeKind::Argument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_argument(&self) -> bool {
        matches!(&self.kind, NodeKind::Argument(_))
    }

    pub fn as_argument_list(self) -> Option<&'a ArgumentList> {
        match &self.kind {
            NodeKind::ArgumentList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_argument_list(&self) -> bool {
        matches!(&self.kind, NodeKind::ArgumentList(_))
    }

    pub fn as_single_argument(self) -> Option<&'a SingleArgument> {
        match &self.kind {
            NodeKind::SingleArgument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_single_argument(&self) -> bool {
        matches!(&self.kind, NodeKind::SingleArgument(_))
    }

    pub fn as_argument_placeholder(self) -> Option<&'a ArgumentPlaceholder> {
        match &self.kind {
            NodeKind::ArgumentPlaceholder(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_argument_placeholder(&self) -> bool {
        matches!(&self.kind, NodeKind::ArgumentPlaceholder(_))
    }

    pub fn as_attribute(self) -> Option<&'a Attribute> {
        match &self.kind {
            NodeKind::Attribute(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_attribute(&self) -> bool {
        matches!(&self.kind, NodeKind::Attribute(_))
    }

    pub fn as_attribute_group(self) -> Option<&'a AttributeGroup> {
        match &self.kind {
            NodeKind::AttributeGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_attribute_group(&self) -> bool {
        matches!(&self.kind, NodeKind::AttributeGroup(_))
    }

    pub fn as_class_body(self) -> Option<&'a ClassBody> {
        match &self.kind {
            NodeKind::ClassBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_body(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassBody(_))
    }

    pub fn as_class_statement(self) -> Option<&'a ClassStatement> {
        match &self.kind {
            NodeKind::ClassStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassStatement(_))
    }

    pub fn as_anonymous_class_body(self) -> Option<&'a AnonymousClassBody> {
        match &self.kind {
            NodeKind::AnonymousClassBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_anonymous_class_body(&self) -> bool {
        matches!(&self.kind, NodeKind::AnonymousClassBody(_))
    }

    pub fn as_anonymous_class_expression(self) -> Option<&'a AnonymousClassExpression> {
        match &self.kind {
            NodeKind::AnonymousClassExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_anonymous_class_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::AnonymousClassExpression(_))
    }

    pub fn as_class_extends(self) -> Option<&'a ClassExtends> {
        match &self.kind {
            NodeKind::ClassExtends(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_extends(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassExtends(_))
    }

    pub fn as_class_implements(self) -> Option<&'a ClassImplements> {
        match &self.kind {
            NodeKind::ClassImplements(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_implements(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassImplements(_))
    }

    pub fn as_classish_member(self) -> Option<&'a ClassishMember> {
        match &self.kind {
            NodeKind::ClassishMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_classish_member(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassishMember(_))
    }

    pub fn as_method(self) -> Option<&'a Method> {
        match &self.kind {
            NodeKind::Method(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method(&self) -> bool {
        matches!(&self.kind, NodeKind::Method(_))
    }

    pub fn as_method_body(self) -> Option<&'a MethodBody> {
        match &self.kind {
            NodeKind::MethodBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_body(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodBody(_))
    }

    pub fn as_method_body_kind(self) -> Option<&'a MethodBodyKind> {
        match &self.kind {
            NodeKind::MethodBodyKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_body_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodBodyKind(_))
    }

    pub fn as_missing_method_body(self) -> Option<&'a MissingMethodBody> {
        match &self.kind {
            NodeKind::MissingMethodBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_missing_method_body(&self) -> bool {
        matches!(&self.kind, NodeKind::MissingMethodBody(_))
    }

    pub fn as_abstract_method_body(self) -> Option<&'a AbstractMethodBody> {
        match &self.kind {
            NodeKind::AbstractMethodBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_abstract_method_body(&self) -> bool {
        matches!(&self.kind, NodeKind::AbstractMethodBody(_))
    }

    pub fn as_concrete_method_body(self) -> Option<&'a ConcreteMethodBody> {
        match &self.kind {
            NodeKind::ConcreteMethodBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concrete_method_body(&self) -> bool {
        matches!(&self.kind, NodeKind::ConcreteMethodBody(_))
    }

    pub fn as_method_parameter_list(self) -> Option<&'a MethodParameterList> {
        match &self.kind {
            NodeKind::MethodParameterList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_parameter_list(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodParameterList(_))
    }

    pub fn as_method_parameter(self) -> Option<&'a MethodParameter> {
        match &self.kind {
            NodeKind::MethodParameter(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_parameter(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodParameter(_))
    }

    pub fn as_missing_classish_member(self) -> Option<&'a MissingClassishMember> {
        match &self.kind {
            NodeKind::MissingClassishMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_missing_classish_member(&self) -> bool {
        matches!(&self.kind, NodeKind::MissingClassishMember(_))
    }

    pub fn as_constant_entry(self) -> Option<&'a ConstantEntry> {
        match &self.kind {
            NodeKind::ConstantEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::ConstantEntry(_))
    }

    pub fn as_classish_constant_entry(self) -> Option<&'a ClassishConstantEntry> {
        match &self.kind {
            NodeKind::ClassishConstantEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_classish_constant_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassishConstantEntry(_))
    }

    pub fn as_constant_statement(self) -> Option<&'a ConstantStatement> {
        match &self.kind {
            NodeKind::ConstantStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ConstantStatement(_))
    }

    pub fn as_classish_constant(self) -> Option<&'a ClassishConstant> {
        match &self.kind {
            NodeKind::ClassishConstant(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_classish_constant(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassishConstant(_))
    }

    pub fn as_if_statement(self) -> Option<&'a IfStatement> {
        match &self.kind {
            NodeKind::IfStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatement(_))
    }

    pub fn as_if_statement_body(self) -> Option<&'a IfStatementBody> {
        match &self.kind {
            NodeKind::IfStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_body(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementBody(_))
    }

    pub fn as_if_statement_body_statement(self) -> Option<&'a IfStatementBodyStatement> {
        match &self.kind {
            NodeKind::IfStatementBodyStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_body_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementBodyStatement(_))
    }

    pub fn as_if_statement_body_block(self) -> Option<&'a IfStatementBodyBlock> {
        match &self.kind {
            NodeKind::IfStatementBodyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_body_block(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementBodyBlock(_))
    }

    pub fn as_if_statement_else_if(self) -> Option<&'a IfStatementElseIf> {
        match &self.kind {
            NodeKind::IfStatementElseIf(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else_if(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementElseIf(_))
    }

    pub fn as_if_statement_else(self) -> Option<&'a IfStatementElse> {
        match &self.kind {
            NodeKind::IfStatementElse(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementElse(_))
    }

    pub fn as_if_statement_else_if_block(self) -> Option<&'a IfStatementElseIfBlock> {
        match &self.kind {
            NodeKind::IfStatementElseIfBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else_if_block(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementElseIfBlock(_))
    }

    pub fn as_if_statement_else_block(self) -> Option<&'a IfStatementElseBlock> {
        match &self.kind {
            NodeKind::IfStatementElseBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else_block(&self) -> bool {
        matches!(&self.kind, NodeKind::IfStatementElseBlock(_))
    }

    pub fn as_data_type(self) -> Option<&'a DataType> {
        match &self.kind {
            NodeKind::DataType(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_data_type(&self) -> bool {
        matches!(&self.kind, NodeKind::DataType(_))
    }

    pub fn as_declare_entry(self) -> Option<&'a DeclareEntry> {
        match &self.kind {
            NodeKind::DeclareEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareEntry(_))
    }

    pub fn as_declare_entry_group(self) -> Option<&'a DeclareEntryGroup> {
        match &self.kind {
            NodeKind::DeclareEntryGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_entry_group(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareEntryGroup(_))
    }

    pub fn as_declare_body(self) -> Option<&'a DeclareBody> {
        match &self.kind {
            NodeKind::DeclareBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_body(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareBody(_))
    }

    pub fn as_declare_body_noop(self) -> Option<&'a DeclareBodyNoop> {
        match &self.kind {
            NodeKind::DeclareBodyNoop(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_body_noop(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareBodyNoop(_))
    }

    pub fn as_declare_body_braced(self) -> Option<&'a DeclareBodyBraced> {
        match &self.kind {
            NodeKind::DeclareBodyBraced(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_body_braced(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareBodyBraced(_))
    }

    pub fn as_declare_body_expression(self) -> Option<&'a DeclareBodyExpression> {
        match &self.kind {
            NodeKind::DeclareBodyExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_body_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareBodyExpression(_))
    }

    pub fn as_declare_body_block(self) -> Option<&'a DeclareBodyBlock> {
        match &self.kind {
            NodeKind::DeclareBodyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_body_block(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareBodyBlock(_))
    }

    pub fn as_declare_statement(self) -> Option<&'a DeclareStatement> {
        match &self.kind {
            NodeKind::DeclareStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::DeclareStatement(_))
    }

    pub fn as_unit_enum_case(self) -> Option<&'a UnitEnumCase> {
        match &self.kind {
            NodeKind::UnitEnumCase(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_case(&self) -> bool {
        matches!(&self.kind, NodeKind::UnitEnumCase(_))
    }

    pub fn as_unit_enum_member(self) -> Option<&'a UnitEnumMember> {
        match &self.kind {
            NodeKind::UnitEnumMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_member(&self) -> bool {
        matches!(&self.kind, NodeKind::UnitEnumMember(_))
    }

    pub fn as_unit_enum_body(self) -> Option<&'a UnitEnumBody> {
        match &self.kind {
            NodeKind::UnitEnumBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_body(&self) -> bool {
        matches!(&self.kind, NodeKind::UnitEnumBody(_))
    }

    pub fn as_unit_enum_statement(self) -> Option<&'a UnitEnumStatement> {
        match &self.kind {
            NodeKind::UnitEnumStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::UnitEnumStatement(_))
    }

    pub fn as_backed_enum_case(self) -> Option<&'a BackedEnumCase> {
        match &self.kind {
            NodeKind::BackedEnumCase(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_case(&self) -> bool {
        matches!(&self.kind, NodeKind::BackedEnumCase(_))
    }

    pub fn as_backed_enum_member(self) -> Option<&'a BackedEnumMember> {
        match &self.kind {
            NodeKind::BackedEnumMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_member(&self) -> bool {
        matches!(&self.kind, NodeKind::BackedEnumMember(_))
    }

    pub fn as_backed_enum_body(self) -> Option<&'a BackedEnumBody> {
        match &self.kind {
            NodeKind::BackedEnumBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_body(&self) -> bool {
        matches!(&self.kind, NodeKind::BackedEnumBody(_))
    }

    pub fn as_backed_enum_statement(self) -> Option<&'a BackedEnumStatement> {
        match &self.kind {
            NodeKind::BackedEnumStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::BackedEnumStatement(_))
    }

    pub fn as_return_type(self) -> Option<&'a ReturnType> {
        match &self.kind {
            NodeKind::ReturnType(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_return_type(&self) -> bool {
        matches!(&self.kind, NodeKind::ReturnType(_))
    }

    pub fn as_function_parameter(self) -> Option<&'a FunctionParameter> {
        match &self.kind {
            NodeKind::FunctionParameter(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_parameter(&self) -> bool {
        matches!(&self.kind, NodeKind::FunctionParameter(_))
    }

    pub fn as_function_parameter_list(self) -> Option<&'a FunctionParameterList> {
        match &self.kind {
            NodeKind::FunctionParameterList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_parameter_list(&self) -> bool {
        matches!(&self.kind, NodeKind::FunctionParameterList(_))
    }

    pub fn as_function_body(self) -> Option<&'a FunctionBody> {
        match &self.kind {
            NodeKind::FunctionBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_body(&self) -> bool {
        matches!(&self.kind, NodeKind::FunctionBody(_))
    }

    pub fn as_function_statement(self) -> Option<&'a FunctionStatement> {
        match &self.kind {
            NodeKind::FunctionStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::FunctionStatement(_))
    }

    pub fn as_closure_use_variable(self) -> Option<&'a ClosureUseVariable> {
        match &self.kind {
            NodeKind::ClosureUseVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closure_use_variable(&self) -> bool {
        matches!(&self.kind, NodeKind::ClosureUseVariable(_))
    }

    pub fn as_closure_use(self) -> Option<&'a ClosureUse> {
        match &self.kind {
            NodeKind::ClosureUse(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closure_use(&self) -> bool {
        matches!(&self.kind, NodeKind::ClosureUse(_))
    }

    pub fn as_closure_expression(self) -> Option<&'a ClosureExpression> {
        match &self.kind {
            NodeKind::ClosureExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closure_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ClosureExpression(_))
    }

    pub fn as_arrow_function_expression(self) -> Option<&'a ArrowFunctionExpression> {
        match &self.kind {
            NodeKind::ArrowFunctionExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_arrow_function_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ArrowFunctionExpression(_))
    }

    pub fn as_label_statement(self) -> Option<&'a LabelStatement> {
        match &self.kind {
            NodeKind::LabelStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_label_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::LabelStatement(_))
    }

    pub fn as_goto_statement(self) -> Option<&'a GotoStatement> {
        match &self.kind {
            NodeKind::GotoStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_goto_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::GotoStatement(_))
    }

    pub fn as_identifier(self) -> Option<&'a Identifier> {
        match &self.kind {
            NodeKind::Identifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_identifier(&self) -> bool {
        matches!(&self.kind, NodeKind::Identifier(_))
    }

    pub fn as_simple_identifier(self) -> Option<&'a SimpleIdentifier> {
        match &self.kind {
            NodeKind::SimpleIdentifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_simple_identifier(&self) -> bool {
        matches!(&self.kind, NodeKind::SimpleIdentifier(_))
    }

    pub fn as_dynamic_identifier(self) -> Option<&'a DynamicIdentifier> {
        match &self.kind {
            NodeKind::DynamicIdentifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_dynamic_identifier(&self) -> bool {
        matches!(&self.kind, NodeKind::DynamicIdentifier(_))
    }

    pub fn as_interface_extends(self) -> Option<&'a InterfaceExtends> {
        match &self.kind {
            NodeKind::InterfaceExtends(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interface_extends(&self) -> bool {
        matches!(&self.kind, NodeKind::InterfaceExtends(_))
    }

    pub fn as_interface_body(self) -> Option<&'a InterfaceBody> {
        match &self.kind {
            NodeKind::InterfaceBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interface_body(&self) -> bool {
        matches!(&self.kind, NodeKind::InterfaceBody(_))
    }

    pub fn as_interface_statement(self) -> Option<&'a InterfaceStatement> {
        match &self.kind {
            NodeKind::InterfaceStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interface_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::InterfaceStatement(_))
    }

    pub fn as_literal(self) -> Option<&'a Literal> {
        match &self.kind {
            NodeKind::Literal(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_literal(&self) -> bool {
        matches!(&self.kind, NodeKind::Literal(_))
    }

    pub fn as_foreach_statement(self) -> Option<&'a ForeachStatement> {
        match &self.kind {
            NodeKind::ForeachStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatement(_))
    }

    pub fn as_foreach_statement_iterator(self) -> Option<&'a ForeachStatementIterator> {
        match &self.kind {
            NodeKind::ForeachStatementIterator(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_iterator(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatementIterator(_))
    }

    pub fn as_foreach_statement_iterator_value(self) -> Option<&'a ForeachStatementIteratorValue> {
        match &self.kind {
            NodeKind::ForeachStatementIteratorValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_iterator_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatementIteratorValue(_))
    }

    pub fn as_foreach_statement_iterator_key_and_value(
        self,
    ) -> Option<&'a ForeachStatementIteratorKeyAndValue> {
        match &self.kind {
            NodeKind::ForeachStatementIteratorKeyAndValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_iterator_key_and_value(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatementIteratorKeyAndValue(_))
    }

    pub fn as_foreach_statement_body(self) -> Option<&'a ForeachStatementBody> {
        match &self.kind {
            NodeKind::ForeachStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_body(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatementBody(_))
    }

    pub fn as_foreach_statement_body_statement(self) -> Option<&'a ForeachStatementBodyStatement> {
        match &self.kind {
            NodeKind::ForeachStatementBodyStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_body_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatementBodyStatement(_))
    }

    pub fn as_foreach_statement_body_block(self) -> Option<&'a ForeachStatementBodyBlock> {
        match &self.kind {
            NodeKind::ForeachStatementBodyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_body_block(&self) -> bool {
        matches!(&self.kind, NodeKind::ForeachStatementBodyBlock(_))
    }

    pub fn as_for_statement(self) -> Option<&'a ForStatement> {
        match &self.kind {
            NodeKind::ForStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ForStatement(_))
    }

    pub fn as_for_statement_iterator(self) -> Option<&'a ForStatementIterator> {
        match &self.kind {
            NodeKind::ForStatementIterator(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement_iterator(&self) -> bool {
        matches!(&self.kind, NodeKind::ForStatementIterator(_))
    }

    pub fn as_for_statement_body(self) -> Option<&'a ForStatementBody> {
        match &self.kind {
            NodeKind::ForStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement_body(&self) -> bool {
        matches!(&self.kind, NodeKind::ForStatementBody(_))
    }

    pub fn as_for_statement_body_statement(self) -> Option<&'a ForStatementBodyStatement> {
        match &self.kind {
            NodeKind::ForStatementBodyStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement_body_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ForStatementBodyStatement(_))
    }

    pub fn as_for_statement_body_block(self) -> Option<&'a ForStatementBodyBlock> {
        match &self.kind {
            NodeKind::ForStatementBodyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement_body_block(&self) -> bool {
        matches!(&self.kind, NodeKind::ForStatementBodyBlock(_))
    }

    pub fn as_do_while_statement(self) -> Option<&'a DoWhileStatement> {
        match &self.kind {
            NodeKind::DoWhileStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_do_while_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::DoWhileStatement(_))
    }

    pub fn as_while_statement(self) -> Option<&'a WhileStatement> {
        match &self.kind {
            NodeKind::WhileStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_while_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::WhileStatement(_))
    }

    pub fn as_while_statement_body(self) -> Option<&'a WhileStatementBody> {
        match &self.kind {
            NodeKind::WhileStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_while_statement_body(&self) -> bool {
        matches!(&self.kind, NodeKind::WhileStatementBody(_))
    }

    pub fn as_while_statement_body_statement(self) -> Option<&'a WhileStatementBodyStatement> {
        match &self.kind {
            NodeKind::WhileStatementBodyStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_while_statement_body_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::WhileStatementBodyStatement(_))
    }

    pub fn as_while_statement_body_block(self) -> Option<&'a WhileStatementBodyBlock> {
        match &self.kind {
            NodeKind::WhileStatementBodyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_while_statement_body_block(&self) -> bool {
        matches!(&self.kind, NodeKind::WhileStatementBodyBlock(_))
    }

    pub fn as_level(self) -> Option<&'a Level> {
        match &self.kind {
            NodeKind::Level(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_level(&self) -> bool {
        matches!(&self.kind, NodeKind::Level(_))
    }

    pub fn as_literal_level(self) -> Option<&'a LiteralLevel> {
        match &self.kind {
            NodeKind::LiteralLevel(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_literal_level(&self) -> bool {
        matches!(&self.kind, NodeKind::LiteralLevel(_))
    }

    pub fn as_parenthesized_level(self) -> Option<&'a ParenthesizedLevel> {
        match &self.kind {
            NodeKind::ParenthesizedLevel(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_parenthesized_level(&self) -> bool {
        matches!(&self.kind, NodeKind::ParenthesizedLevel(_))
    }

    pub fn as_break_statement(self) -> Option<&'a BreakStatement> {
        match &self.kind {
            NodeKind::BreakStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_break_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::BreakStatement(_))
    }

    pub fn as_continue_statement(self) -> Option<&'a ContinueStatement> {
        match &self.kind {
            NodeKind::ContinueStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_continue_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ContinueStatement(_))
    }

    pub fn as_promoted_property_modifier_group(self) -> Option<&'a PromotedPropertyModifierGroup> {
        match &self.kind {
            NodeKind::PromotedPropertyModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_promoted_property_modifier_group(&self) -> bool {
        matches!(&self.kind, NodeKind::PromotedPropertyModifierGroup(_))
    }

    pub fn as_property_modifier_group(self) -> Option<&'a PropertyModifierGroup> {
        match &self.kind {
            NodeKind::PropertyModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_modifier_group(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyModifierGroup(_))
    }

    pub fn as_method_modifier_group(self) -> Option<&'a MethodModifierGroup> {
        match &self.kind {
            NodeKind::MethodModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_modifier_group(&self) -> bool {
        matches!(&self.kind, NodeKind::MethodModifierGroup(_))
    }

    pub fn as_class_modifier_group(self) -> Option<&'a ClassModifierGroup> {
        match &self.kind {
            NodeKind::ClassModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_modifier_group(&self) -> bool {
        matches!(&self.kind, NodeKind::ClassModifierGroup(_))
    }

    pub fn as_constant_modifier_group(self) -> Option<&'a ConstantModifierGroup> {
        match &self.kind {
            NodeKind::ConstantModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_modifier_group(&self) -> bool {
        matches!(&self.kind, NodeKind::ConstantModifierGroup(_))
    }

    pub fn as_unbraced_namespace(self) -> Option<&'a UnbracedNamespace> {
        match &self.kind {
            NodeKind::UnbracedNamespace(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unbraced_namespace(&self) -> bool {
        matches!(&self.kind, NodeKind::UnbracedNamespace(_))
    }

    pub fn as_braced_namespace(self) -> Option<&'a BracedNamespace> {
        match &self.kind {
            NodeKind::BracedNamespace(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_braced_namespace(&self) -> bool {
        matches!(&self.kind, NodeKind::BracedNamespace(_))
    }

    pub fn as_braced_namespace_body(self) -> Option<&'a BracedNamespaceBody> {
        match &self.kind {
            NodeKind::BracedNamespaceBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_braced_namespace_body(&self) -> bool {
        matches!(&self.kind, NodeKind::BracedNamespaceBody(_))
    }

    pub fn as_namespace_statement(self) -> Option<&'a NamespaceStatement> {
        match &self.kind {
            NodeKind::NamespaceStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_namespace_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::NamespaceStatement(_))
    }

    pub fn as_arithmetic_operation_expression(self) -> Option<&'a ArithmeticOperationExpression> {
        match &self.kind {
            NodeKind::ArithmeticOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_arithmetic_operation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ArithmeticOperationExpression(_))
    }

    pub fn as_arithmetic_operation_kind(self) -> Option<&'a ArithmeticOperationKind> {
        match &self.kind {
            NodeKind::ArithmeticOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_arithmetic_operation_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::ArithmeticOperationKind(_))
    }

    pub fn as_assignment_operation_expression(self) -> Option<&'a AssignmentOperationExpression> {
        match &self.kind {
            NodeKind::AssignmentOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_assignment_operation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::AssignmentOperationExpression(_))
    }

    pub fn as_bitwise_operation_expression(self) -> Option<&'a BitwiseOperationExpression> {
        match &self.kind {
            NodeKind::BitwiseOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_bitwise_operation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::BitwiseOperationExpression(_))
    }

    pub fn as_bitwise_operation_kind(self) -> Option<&'a BitwiseOperationKind> {
        match &self.kind {
            NodeKind::BitwiseOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_bitwise_operation_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::BitwiseOperationKind(_))
    }

    pub fn as_comparison_operation_expression(self) -> Option<&'a ComparisonOperationExpression> {
        match &self.kind {
            NodeKind::ComparisonOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comparison_operation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ComparisonOperationExpression(_))
    }

    pub fn as_comparison_operation_kind(self) -> Option<&'a ComparisonOperationKind> {
        match &self.kind {
            NodeKind::ComparisonOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comparison_operation_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::ComparisonOperationKind(_))
    }

    pub fn as_logical_operation_expression(self) -> Option<&'a LogicalOperationExpression> {
        match &self.kind {
            NodeKind::LogicalOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_logical_operation_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::LogicalOperationExpression(_))
    }

    pub fn as_logical_operation_kind(self) -> Option<&'a LogicalOperationKind> {
        match &self.kind {
            NodeKind::LogicalOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_logical_operation_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::LogicalOperationKind(_))
    }

    pub fn as_name(self) -> Option<&'a Name> {
        match &self.kind {
            NodeKind::Name(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_name(&self) -> bool {
        matches!(&self.kind, NodeKind::Name(_))
    }

    pub fn as_property(self) -> Option<&'a Property> {
        match &self.kind {
            NodeKind::Property(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property(&self) -> bool {
        matches!(&self.kind, NodeKind::Property(_))
    }

    pub fn as_simple_property(self) -> Option<&'a SimpleProperty> {
        match &self.kind {
            NodeKind::SimpleProperty(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_simple_property(&self) -> bool {
        matches!(&self.kind, NodeKind::SimpleProperty(_))
    }

    pub fn as_hooked_property(self) -> Option<&'a HookedProperty> {
        match &self.kind {
            NodeKind::HookedProperty(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_hooked_property(&self) -> bool {
        matches!(&self.kind, NodeKind::HookedProperty(_))
    }

    pub fn as_property_hook_list(self) -> Option<&'a PropertyHookList> {
        match &self.kind {
            NodeKind::PropertyHookList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_hook_list(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyHookList(_))
    }

    pub fn as_property_hook(self) -> Option<&'a PropertyHook> {
        match &self.kind {
            NodeKind::PropertyHook(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_hook(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyHook(_))
    }

    pub fn as_property_hook_body(self) -> Option<&'a PropertyHookBody> {
        match &self.kind {
            NodeKind::PropertyHookBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_hook_body(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyHookBody(_))
    }

    pub fn as_concrete_property_hook_body(self) -> Option<&'a ConcretePropertyHookBody> {
        match &self.kind {
            NodeKind::ConcretePropertyHookBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concrete_property_hook_body(&self) -> bool {
        matches!(&self.kind, NodeKind::ConcretePropertyHookBody(_))
    }

    pub fn as_concrete_property_hook_body_block(self) -> Option<&'a ConcretePropertyHookBodyBlock> {
        match &self.kind {
            NodeKind::ConcretePropertyHookBodyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concrete_property_hook_body_block(&self) -> bool {
        matches!(&self.kind, NodeKind::ConcretePropertyHookBodyBlock(_))
    }

    pub fn as_concrete_property_hook_body_expression(
        self,
    ) -> Option<&'a ConcretePropertyHookBodyExpression> {
        match &self.kind {
            NodeKind::ConcretePropertyHookBodyExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concrete_property_hook_body_expression(&self) -> bool {
        matches!(&self.kind, NodeKind::ConcretePropertyHookBodyExpression(_))
    }

    pub fn as_property_entry(self) -> Option<&'a PropertyEntry> {
        match &self.kind {
            NodeKind::PropertyEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyEntry(_))
    }

    pub fn as_property_entry_kind(self) -> Option<&'a PropertyEntryKind> {
        match &self.kind {
            NodeKind::PropertyEntryKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_entry_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::PropertyEntryKind(_))
    }

    pub fn as_uninitialized_property_entry(self) -> Option<&'a UninitializedPropertyEntry> {
        match &self.kind {
            NodeKind::UninitializedPropertyEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_uninitialized_property_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::UninitializedPropertyEntry(_))
    }

    pub fn as_initialized_property_entry(self) -> Option<&'a InitializedPropertyEntry> {
        match &self.kind {
            NodeKind::InitializedPropertyEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_initialized_property_entry(&self) -> bool {
        matches!(&self.kind, NodeKind::InitializedPropertyEntry(_))
    }

    pub fn as_trait_body(self) -> Option<&'a TraitBody> {
        match &self.kind {
            NodeKind::TraitBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_body(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitBody(_))
    }

    pub fn as_trait_statement(self) -> Option<&'a TraitStatement> {
        match &self.kind {
            NodeKind::TraitStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitStatement(_))
    }

    pub fn as_trait_usage(self) -> Option<&'a TraitUsage> {
        match &self.kind {
            NodeKind::TraitUsage(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitUsage(_))
    }

    pub fn as_trait_usage_adaptation(self) -> Option<&'a TraitUsageAdaptation> {
        match &self.kind {
            NodeKind::TraitUsageAdaptation(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitUsageAdaptation(_))
    }

    pub fn as_trait_usage_adaptation_kind(self) -> Option<&'a TraitUsageAdaptationKind> {
        match &self.kind {
            NodeKind::TraitUsageAdaptationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitUsageAdaptationKind(_))
    }

    pub fn as_trait_usage_adaptation_alias(self) -> Option<&'a TraitUsageAdaptationAlias> {
        match &self.kind {
            NodeKind::TraitUsageAdaptationAlias(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation_alias(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitUsageAdaptationAlias(_))
    }

    pub fn as_trait_usage_adaptation_visibility(
        self,
    ) -> Option<&'a TraitUsageAdaptationVisibility> {
        match &self.kind {
            NodeKind::TraitUsageAdaptationVisibility(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation_visibility(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitUsageAdaptationVisibility(_))
    }

    pub fn as_trait_usage_adaptation_precedence(
        self,
    ) -> Option<&'a TraitUsageAdaptationPrecedence> {
        match &self.kind {
            NodeKind::TraitUsageAdaptationPrecedence(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation_precedence(&self) -> bool {
        matches!(&self.kind, NodeKind::TraitUsageAdaptationPrecedence(_))
    }

    pub fn as_catch_type(self) -> Option<&'a CatchType> {
        match &self.kind {
            NodeKind::CatchType(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_type(&self) -> bool {
        matches!(&self.kind, NodeKind::CatchType(_))
    }

    pub fn as_catch_type_kind(self) -> Option<&'a CatchTypeKind> {
        match &self.kind {
            NodeKind::CatchTypeKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_type_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::CatchTypeKind(_))
    }

    pub fn as_catch_type_kind_identifier(self) -> Option<&'a CatchTypeKindIdentifier> {
        match &self.kind {
            NodeKind::CatchTypeKindIdentifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_type_kind_identifier(&self) -> bool {
        matches!(&self.kind, NodeKind::CatchTypeKindIdentifier(_))
    }

    pub fn as_catch_type_kind_union(self) -> Option<&'a CatchTypeKindUnion> {
        match &self.kind {
            NodeKind::CatchTypeKindUnion(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_type_kind_union(&self) -> bool {
        matches!(&self.kind, NodeKind::CatchTypeKindUnion(_))
    }

    pub fn as_try_statement(self) -> Option<&'a TryStatement> {
        match &self.kind {
            NodeKind::TryStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_try_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::TryStatement(_))
    }

    pub fn as_catch_block(self) -> Option<&'a CatchBlock> {
        match &self.kind {
            NodeKind::CatchBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_block(&self) -> bool {
        matches!(&self.kind, NodeKind::CatchBlock(_))
    }

    pub fn as_finally_block(self) -> Option<&'a FinallyBlock> {
        match &self.kind {
            NodeKind::FinallyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_finally_block(&self) -> bool {
        matches!(&self.kind, NodeKind::FinallyBlock(_))
    }

    pub fn as_variable(self) -> Option<&'a Variable> {
        match &self.kind {
            NodeKind::Variable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_variable(&self) -> bool {
        matches!(&self.kind, NodeKind::Variable(_))
    }

    pub fn as_simple_variable(self) -> Option<&'a SimpleVariable> {
        match &self.kind {
            NodeKind::SimpleVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_simple_variable(&self) -> bool {
        matches!(&self.kind, NodeKind::SimpleVariable(_))
    }

    pub fn as_variable_variable(self) -> Option<&'a VariableVariable> {
        match &self.kind {
            NodeKind::VariableVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_variable_variable(&self) -> bool {
        matches!(&self.kind, NodeKind::VariableVariable(_))
    }

    pub fn as_braced_variable_variable(self) -> Option<&'a BracedVariableVariable> {
        match &self.kind {
            NodeKind::BracedVariableVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_braced_variable_variable(&self) -> bool {
        matches!(&self.kind, NodeKind::BracedVariableVariable(_))
    }

    pub fn as_static_statement(self) -> Option<&'a StaticStatement> {
        match &self.kind {
            NodeKind::StaticStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::StaticStatement(_))
    }

    pub fn as_switch_statement(self) -> Option<&'a SwitchStatement> {
        match &self.kind {
            NodeKind::SwitchStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_switch_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::SwitchStatement(_))
    }

    pub fn as_echo_statement(self) -> Option<&'a EchoStatement> {
        match &self.kind {
            NodeKind::EchoStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_echo_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::EchoStatement(_))
    }

    pub fn as_return_statement(self) -> Option<&'a ReturnStatement> {
        match &self.kind {
            NodeKind::ReturnStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_return_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::ReturnStatement(_))
    }

    pub fn as_use_statement(self) -> Option<&'a UseStatement> {
        match &self.kind {
            NodeKind::UseStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_use_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::UseStatement(_))
    }

    pub fn as_group_use_statement(self) -> Option<&'a GroupUseStatement> {
        match &self.kind {
            NodeKind::GroupUseStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_group_use_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::GroupUseStatement(_))
    }

    pub fn as_halt_compiler_statement(self) -> Option<&'a HaltCompilerStatement> {
        match &self.kind {
            NodeKind::HaltCompilerStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_halt_compiler_statement(&self) -> bool {
        matches!(&self.kind, NodeKind::HaltCompilerStatement(_))
    }

    pub fn as_static_var(self) -> Option<&'a StaticVar> {
        match &self.kind {
            NodeKind::StaticVar(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_var(&self) -> bool {
        matches!(&self.kind, NodeKind::StaticVar(_))
    }

    pub fn as_comment(self) -> Option<&'a Comment> {
        match &self.kind {
            NodeKind::Comment(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comment(&self) -> bool {
        matches!(&self.kind, NodeKind::Comment(_))
    }

    pub fn as_comment_kind(self) -> Option<&'a CommentKind> {
        match &self.kind {
            NodeKind::CommentKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comment_kind(&self) -> bool {
        matches!(&self.kind, NodeKind::CommentKind(_))
    }

    pub fn as_single_line_comment(self) -> Option<&'a SingleLineComment> {
        match &self.kind {
            NodeKind::SingleLineComment(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_single_line_comment(&self) -> bool {
        matches!(&self.kind, NodeKind::SingleLineComment(_))
    }

    pub fn as_multi_line_comment(self) -> Option<&'a MultiLineComment> {
        match &self.kind {
            NodeKind::MultiLineComment(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_multi_line_comment(&self) -> bool {
        matches!(&self.kind, NodeKind::MultiLineComment(_))
    }

    pub fn as_hash_mark_comment(self) -> Option<&'a HashMarkComment> {
        match &self.kind {
            NodeKind::HashMarkComment(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_hash_mark_comment(&self) -> bool {
        matches!(&self.kind, NodeKind::HashMarkComment(_))
    }

    pub fn as_doc_block_comment(self) -> Option<&'a DocBlockComment> {
        match &self.kind {
            NodeKind::DocBlockComment(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_comment(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockComment(_))
    }

    pub fn as_doc_block(self) -> Option<&'a DocBlock> {
        match &self.kind {
            NodeKind::DocBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlock(_))
    }

    pub fn as_doc_block_node(self) -> Option<&'a DocBlockNode> {
        match &self.kind {
            NodeKind::DocBlockNode(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_node(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockNode(_))
    }

    pub fn as_doc_block_text_node(self) -> Option<&'a DocBlockTextNode> {
        match &self.kind {
            NodeKind::DocBlockTextNode(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_text_node(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockTextNode(_))
    }

    pub fn as_doc_block_tag_node(self) -> Option<&'a DocBlockTagNode> {
        match &self.kind {
            NodeKind::DocBlockTagNode(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_tag_node(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockTagNode(_))
    }

    pub fn as_doc_block_tag(self) -> Option<&'a DocBlockTag> {
        match &self.kind {
            NodeKind::DocBlockTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockTag(_))
    }

    pub fn as_doc_block_param_closure_this_tag(self) -> Option<&'a DocBlockParamClosureThisTag> {
        match &self.kind {
            NodeKind::DocBlockParamClosureThisTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_param_closure_this_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockParamClosureThisTag(_))
    }

    pub fn as_doc_block_param_tag(self) -> Option<&'a DocBlockParamTag> {
        match &self.kind {
            NodeKind::DocBlockParamTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_param_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockParamTag(_))
    }

    pub fn as_doc_block_return_tag(self) -> Option<&'a DocBlockReturnTag> {
        match &self.kind {
            NodeKind::DocBlockReturnTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_return_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockReturnTag(_))
    }

    pub fn as_doc_block_throws_tag(self) -> Option<&'a DocBlockThrowsTag> {
        match &self.kind {
            NodeKind::DocBlockThrowsTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_throws_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockThrowsTag(_))
    }

    pub fn as_doc_block_var_tag(self) -> Option<&'a DocBlockVarTag> {
        match &self.kind {
            NodeKind::DocBlockVarTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_var_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockVarTag(_))
    }

    pub fn as_doc_block_property_tag(self) -> Option<&'a DocBlockPropertyTag> {
        match &self.kind {
            NodeKind::DocBlockPropertyTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_property_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockPropertyTag(_))
    }

    pub fn as_doc_block_method_tag(self) -> Option<&'a DocBlockMethodTag> {
        match &self.kind {
            NodeKind::DocBlockMethodTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_method_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockMethodTag(_))
    }

    pub fn as_doc_block_template_tag_value(self) -> Option<&'a DocBlockTemplateTagValue> {
        match &self.kind {
            NodeKind::DocBlockTemplateTagValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_template_tag_value(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockTemplateTagValue(_))
    }

    pub fn as_doc_block_template_tag(self) -> Option<&'a DocBlockTemplateTag> {
        match &self.kind {
            NodeKind::DocBlockTemplateTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_template_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockTemplateTag(_))
    }

    pub fn as_doc_block_extends_tag(self) -> Option<&'a DocBlockExtendsTag> {
        match &self.kind {
            NodeKind::DocBlockExtendsTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_extends_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockExtendsTag(_))
    }

    pub fn as_doc_block_implements_tag(self) -> Option<&'a DocBlockImplementsTag> {
        match &self.kind {
            NodeKind::DocBlockImplementsTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_implements_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockImplementsTag(_))
    }

    pub fn as_doc_block_uses_tag(self) -> Option<&'a DocBlockUsesTag> {
        match &self.kind {
            NodeKind::DocBlockUsesTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_uses_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockUsesTag(_))
    }

    pub fn as_doc_block_deprecated_tag(self) -> Option<&'a DocBlockDeprecatedTag> {
        match &self.kind {
            NodeKind::DocBlockDeprecatedTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_deprecated_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockDeprecatedTag(_))
    }

    pub fn as_doc_block_generic_tag(self) -> Option<&'a DocBlockGenericTag> {
        match &self.kind {
            NodeKind::DocBlockGenericTag(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_doc_block_generic_tag(&self) -> bool {
        matches!(&self.kind, NodeKind::DocBlockGenericTag(_))
    }

    pub fn as_comment_group(self) -> Option<&'a CommentGroup> {
        match &self.kind {
            NodeKind::CommentGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comment_group(&self) -> bool {
        matches!(&self.kind, NodeKind::CommentGroup(_))
    }

    pub fn name(&self) -> &'static str {
        match &self.kind {
            NodeKind::Block(_) => "Block",
            NodeKind::Statement(_) => "Statement",
            NodeKind::StatementKind(_) => "StatementKind",
            NodeKind::Expression(_) => "Expression",
            NodeKind::ExpressionKind(_) => "ExpressionKind",
            NodeKind::MissingExpression(_) => "MissingExpression",
            NodeKind::StaticExpression(_) => "StaticExpression",
            NodeKind::SelfExpression(_) => "SelfExpression",
            NodeKind::ParentExpression(_) => "ParentExpression",
            NodeKind::CommentStatement(_) => "CommentStatement",
            NodeKind::InlineHtmlStatement(_) => "InlineHtmlStatement",
            NodeKind::FullOpeningTagStatement(_) => "FullOpeningTagStatement",
            NodeKind::ShortOpeningTagStatement(_) => "ShortOpeningTagStatement",
            NodeKind::EchoOpeningTagStatement(_) => "EchoOpeningTagStatement",
            NodeKind::ClosingTagStatement(_) => "ClosingTagStatement",
            NodeKind::ExpressionStatement(_) => "ExpressionStatement",
            NodeKind::GlobalStatement(_) => "GlobalStatement",
            NodeKind::BlockStatement(_) => "BlockStatement",
            NodeKind::Case(_) => "Case",
            NodeKind::Use(_) => "Use",
            NodeKind::EvalExpression(_) => "EvalExpression",
            NodeKind::EmptyExpression(_) => "EmptyExpression",
            NodeKind::DieExpression(_) => "DieExpression",
            NodeKind::ExitExpression(_) => "ExitExpression",
            NodeKind::IssetExpression(_) => "IssetExpression",
            NodeKind::UnsetExpression(_) => "UnsetExpression",
            NodeKind::PrintExpression(_) => "PrintExpression",
            NodeKind::ConcatExpression(_) => "ConcatExpression",
            NodeKind::InstanceofExpression(_) => "InstanceofExpression",
            NodeKind::ReferenceExpression(_) => "ReferenceExpression",
            NodeKind::ParenthesizedExpression(_) => "ParenthesizedExpression",
            NodeKind::ErrorSuppressExpression(_) => "ErrorSuppressExpression",
            NodeKind::IncludeExpression(_) => "IncludeExpression",
            NodeKind::IncludeOnceExpression(_) => "IncludeOnceExpression",
            NodeKind::RequireExpression(_) => "RequireExpression",
            NodeKind::RequireOnceExpression(_) => "RequireOnceExpression",
            NodeKind::FunctionCallExpression(_) => "FunctionCallExpression",
            NodeKind::FunctionClosureCreationExpression(_) => "FunctionClosureCreationExpression",
            NodeKind::MethodCallExpression(_) => "MethodCallExpression",
            NodeKind::MethodClosureCreationExpression(_) => "MethodClosureCreationExpression",
            NodeKind::NullsafeMethodCallExpression(_) => "NullsafeMethodCallExpression",
            NodeKind::StaticMethodCallExpression(_) => "StaticMethodCallExpression",
            NodeKind::StaticVariableMethodCallExpression(_) => "StaticVariableMethodCallExpression",
            NodeKind::StaticMethodClosureCreationExpression(_) => {
                "StaticMethodClosureCreationExpression"
            }
            NodeKind::StaticVariableMethodClosureCreationExpression(_) => {
                "StaticVariableMethodClosureCreationExpression"
            }
            NodeKind::PropertyFetchExpression(_) => "PropertyFetchExpression",
            NodeKind::NullsafePropertyFetchExpression(_) => "NullsafePropertyFetchExpression",
            NodeKind::StaticPropertyFetchExpression(_) => "StaticPropertyFetchExpression",
            NodeKind::ConstantFetchExpression(_) => "ConstantFetchExpression",
            NodeKind::ArrayExpression(_) => "ArrayExpression",
            NodeKind::ListExpression(_) => "ListExpression",
            NodeKind::NewExpression(_) => "NewExpression",
            NodeKind::InterpolatedStringExpression(_) => "InterpolatedStringExpression",
            NodeKind::HeredocExpression(_) => "HeredocExpression",
            NodeKind::NowdocExpression(_) => "NowdocExpression",
            NodeKind::ShellExecExpression(_) => "ShellExecExpression",
            NodeKind::BoolExpression(_) => "BoolExpression",
            NodeKind::ArrayIndexExpression(_) => "ArrayIndexExpression",
            NodeKind::ShortTernaryExpression(_) => "ShortTernaryExpression",
            NodeKind::TernaryExpression(_) => "TernaryExpression",
            NodeKind::CoalesceExpression(_) => "CoalesceExpression",
            NodeKind::CloneExpression(_) => "CloneExpression",
            NodeKind::MatchExpression(_) => "MatchExpression",
            NodeKind::ThrowExpression(_) => "ThrowExpression",
            NodeKind::YieldExpression(_) => "YieldExpression",
            NodeKind::YieldFromExpression(_) => "YieldFromExpression",
            NodeKind::CastExpression(_) => "CastExpression",
            NodeKind::DefaultMatchArm(_) => "DefaultMatchArm",
            NodeKind::MatchArm(_) => "MatchArm",
            NodeKind::MagicConstantExpression(_) => "MagicConstantExpression",
            NodeKind::StringPart(_) => "StringPart",
            NodeKind::LiteralStringPart(_) => "LiteralStringPart",
            NodeKind::ExpressionStringPart(_) => "ExpressionStringPart",
            NodeKind::ArrayItem(_) => "ArrayItem",
            NodeKind::ArrayItemValue(_) => "ArrayItemValue",
            NodeKind::ArrayItemReferencedValue(_) => "ArrayItemReferencedValue",
            NodeKind::ArrayItemSpreadValue(_) => "ArrayItemSpreadValue",
            NodeKind::ArrayItemKeyValue(_) => "ArrayItemKeyValue",
            NodeKind::ArrayItemReferencedKeyValue(_) => "ArrayItemReferencedKeyValue",
            NodeKind::ListEntry(_) => "ListEntry",
            NodeKind::ListEntryValue(_) => "ListEntryValue",
            NodeKind::ListEntryKeyValue(_) => "ListEntryKeyValue",
            NodeKind::PositionalArgument(_) => "PositionalArgument",
            NodeKind::NamedArgument(_) => "NamedArgument",
            NodeKind::Argument(_) => "Argument",
            NodeKind::ArgumentList(_) => "ArgumentList",
            NodeKind::SingleArgument(_) => "SingleArgument",
            NodeKind::ArgumentPlaceholder(_) => "ArgumentPlaceholder",
            NodeKind::Attribute(_) => "Attribute",
            NodeKind::AttributeGroup(_) => "AttributeGroup",
            NodeKind::ClassBody(_) => "ClassBody",
            NodeKind::ClassStatement(_) => "ClassStatement",
            NodeKind::AnonymousClassBody(_) => "AnonymousClassBody",
            NodeKind::AnonymousClassExpression(_) => "AnonymousClassExpression",
            NodeKind::ClassExtends(_) => "ClassExtends",
            NodeKind::ClassImplements(_) => "ClassImplements",
            NodeKind::ClassishMember(_) => "ClassishMember",
            NodeKind::Method(_) => "Method",
            NodeKind::MethodBody(_) => "MethodBody",
            NodeKind::MethodBodyKind(_) => "MethodBodyKind",
            NodeKind::MissingMethodBody(_) => "MissingMethodBody",
            NodeKind::AbstractMethodBody(_) => "AbstractMethodBody",
            NodeKind::ConcreteMethodBody(_) => "ConcreteMethodBody",
            NodeKind::MethodParameterList(_) => "MethodParameterList",
            NodeKind::MethodParameter(_) => "MethodParameter",
            NodeKind::MissingClassishMember(_) => "MissingClassishMember",
            NodeKind::ConstantEntry(_) => "ConstantEntry",
            NodeKind::ClassishConstantEntry(_) => "ClassishConstantEntry",
            NodeKind::ConstantStatement(_) => "ConstantStatement",
            NodeKind::ClassishConstant(_) => "ClassishConstant",
            NodeKind::IfStatement(_) => "IfStatement",
            NodeKind::IfStatementBody(_) => "IfStatementBody",
            NodeKind::IfStatementBodyStatement(_) => "IfStatementBodyStatement",
            NodeKind::IfStatementBodyBlock(_) => "IfStatementBodyBlock",
            NodeKind::IfStatementElseIf(_) => "IfStatementElseIf",
            NodeKind::IfStatementElse(_) => "IfStatementElse",
            NodeKind::IfStatementElseIfBlock(_) => "IfStatementElseIfBlock",
            NodeKind::IfStatementElseBlock(_) => "IfStatementElseBlock",
            NodeKind::DataType(_) => "DataType",
            NodeKind::DeclareEntry(_) => "DeclareEntry",
            NodeKind::DeclareEntryGroup(_) => "DeclareEntryGroup",
            NodeKind::DeclareBody(_) => "DeclareBody",
            NodeKind::DeclareBodyNoop(_) => "DeclareBodyNoop",
            NodeKind::DeclareBodyBraced(_) => "DeclareBodyBraced",
            NodeKind::DeclareBodyExpression(_) => "DeclareBodyExpression",
            NodeKind::DeclareBodyBlock(_) => "DeclareBodyBlock",
            NodeKind::DeclareStatement(_) => "DeclareStatement",
            NodeKind::UnitEnumCase(_) => "UnitEnumCase",
            NodeKind::UnitEnumMember(_) => "UnitEnumMember",
            NodeKind::UnitEnumBody(_) => "UnitEnumBody",
            NodeKind::UnitEnumStatement(_) => "UnitEnumStatement",
            NodeKind::BackedEnumCase(_) => "BackedEnumCase",
            NodeKind::BackedEnumMember(_) => "BackedEnumMember",
            NodeKind::BackedEnumBody(_) => "BackedEnumBody",
            NodeKind::BackedEnumStatement(_) => "BackedEnumStatement",
            NodeKind::ReturnType(_) => "ReturnType",
            NodeKind::FunctionParameter(_) => "FunctionParameter",
            NodeKind::FunctionParameterList(_) => "FunctionParameterList",
            NodeKind::FunctionBody(_) => "FunctionBody",
            NodeKind::FunctionStatement(_) => "FunctionStatement",
            NodeKind::ClosureUseVariable(_) => "ClosureUseVariable",
            NodeKind::ClosureUse(_) => "ClosureUse",
            NodeKind::ClosureExpression(_) => "ClosureExpression",
            NodeKind::ArrowFunctionExpression(_) => "ArrowFunctionExpression",
            NodeKind::LabelStatement(_) => "LabelStatement",
            NodeKind::GotoStatement(_) => "GotoStatement",
            NodeKind::Identifier(_) => "Identifier",
            NodeKind::SimpleIdentifier(_) => "SimpleIdentifier",
            NodeKind::DynamicIdentifier(_) => "DynamicIdentifier",
            NodeKind::InterfaceExtends(_) => "InterfaceExtends",
            NodeKind::InterfaceBody(_) => "InterfaceBody",
            NodeKind::InterfaceStatement(_) => "InterfaceStatement",
            NodeKind::Literal(_) => "Literal",
            NodeKind::ForeachStatement(_) => "ForeachStatement",
            NodeKind::ForeachStatementIterator(_) => "ForeachStatementIterator",
            NodeKind::ForeachStatementIteratorValue(_) => "ForeachStatementIteratorValue",
            NodeKind::ForeachStatementIteratorKeyAndValue(_) => {
                "ForeachStatementIteratorKeyAndValue"
            }
            NodeKind::ForeachStatementBody(_) => "ForeachStatementBody",
            NodeKind::ForeachStatementBodyStatement(_) => "ForeachStatementBodyStatement",
            NodeKind::ForeachStatementBodyBlock(_) => "ForeachStatementBodyBlock",
            NodeKind::ForStatement(_) => "ForStatement",
            NodeKind::ForStatementIterator(_) => "ForStatementIterator",
            NodeKind::ForStatementBody(_) => "ForStatementBody",
            NodeKind::ForStatementBodyStatement(_) => "ForStatementBodyStatement",
            NodeKind::ForStatementBodyBlock(_) => "ForStatementBodyBlock",
            NodeKind::DoWhileStatement(_) => "DoWhileStatement",
            NodeKind::WhileStatement(_) => "WhileStatement",
            NodeKind::WhileStatementBody(_) => "WhileStatementBody",
            NodeKind::WhileStatementBodyStatement(_) => "WhileStatementBodyStatement",
            NodeKind::WhileStatementBodyBlock(_) => "WhileStatementBodyBlock",
            NodeKind::Level(_) => "Level",
            NodeKind::LiteralLevel(_) => "LiteralLevel",
            NodeKind::ParenthesizedLevel(_) => "ParenthesizedLevel",
            NodeKind::BreakStatement(_) => "BreakStatement",
            NodeKind::ContinueStatement(_) => "ContinueStatement",
            NodeKind::PromotedPropertyModifierGroup(_) => "PromotedPropertyModifierGroup",
            NodeKind::PropertyModifierGroup(_) => "PropertyModifierGroup",
            NodeKind::MethodModifierGroup(_) => "MethodModifierGroup",
            NodeKind::ClassModifierGroup(_) => "ClassModifierGroup",
            NodeKind::ConstantModifierGroup(_) => "ConstantModifierGroup",
            NodeKind::UnbracedNamespace(_) => "UnbracedNamespace",
            NodeKind::BracedNamespace(_) => "BracedNamespace",
            NodeKind::BracedNamespaceBody(_) => "BracedNamespaceBody",
            NodeKind::NamespaceStatement(_) => "NamespaceStatement",
            NodeKind::ArithmeticOperationExpression(_) => "ArithmeticOperationExpression",
            NodeKind::ArithmeticOperationKind(_) => "ArithmeticOperationKind",
            NodeKind::AssignmentOperationExpression(_) => "AssignmentOperationExpression",
            NodeKind::BitwiseOperationExpression(_) => "BitwiseOperationExpression",
            NodeKind::BitwiseOperationKind(_) => "BitwiseOperationKind",
            NodeKind::ComparisonOperationExpression(_) => "ComparisonOperationExpression",
            NodeKind::ComparisonOperationKind(_) => "ComparisonOperationKind",
            NodeKind::LogicalOperationExpression(_) => "LogicalOperationExpression",
            NodeKind::LogicalOperationKind(_) => "LogicalOperationKind",
            NodeKind::Name(_) => "Name",
            NodeKind::Property(_) => "Property",
            NodeKind::SimpleProperty(_) => "SimpleProperty",
            NodeKind::HookedProperty(_) => "HookedProperty",
            NodeKind::PropertyHookList(_) => "PropertyHookList",
            NodeKind::PropertyHook(_) => "PropertyHook",
            NodeKind::PropertyHookBody(_) => "PropertyHookBody",
            NodeKind::ConcretePropertyHookBody(_) => "ConcretePropertyHookBody",
            NodeKind::ConcretePropertyHookBodyBlock(_) => "ConcretePropertyHookBodyBlock",
            NodeKind::ConcretePropertyHookBodyExpression(_) => "ConcretePropertyHookBodyExpression",
            NodeKind::PropertyEntry(_) => "PropertyEntry",
            NodeKind::PropertyEntryKind(_) => "PropertyEntryKind",
            NodeKind::UninitializedPropertyEntry(_) => "UninitializedPropertyEntry",
            NodeKind::InitializedPropertyEntry(_) => "InitializedPropertyEntry",
            NodeKind::TraitBody(_) => "TraitBody",
            NodeKind::TraitStatement(_) => "TraitStatement",
            NodeKind::TraitUsage(_) => "TraitUsage",
            NodeKind::TraitUsageAdaptation(_) => "TraitUsageAdaptation",
            NodeKind::TraitUsageAdaptationKind(_) => "TraitUsageAdaptationKind",
            NodeKind::TraitUsageAdaptationAlias(_) => "TraitUsageAdaptationAlias",
            NodeKind::TraitUsageAdaptationVisibility(_) => "TraitUsageAdaptationVisibility",
            NodeKind::TraitUsageAdaptationPrecedence(_) => "TraitUsageAdaptationPrecedence",
            NodeKind::CatchType(_) => "CatchType",
            NodeKind::CatchTypeKind(_) => "CatchTypeKind",
            NodeKind::CatchTypeKindIdentifier(_) => "CatchTypeKindIdentifier",
            NodeKind::CatchTypeKindUnion(_) => "CatchTypeKindUnion",
            NodeKind::TryStatement(_) => "TryStatement",
            NodeKind::CatchBlock(_) => "CatchBlock",
            NodeKind::FinallyBlock(_) => "FinallyBlock",
            NodeKind::Variable(_) => "Variable",
            NodeKind::SimpleVariable(_) => "SimpleVariable",
            NodeKind::VariableVariable(_) => "VariableVariable",
            NodeKind::BracedVariableVariable(_) => "BracedVariableVariable",
            NodeKind::StaticStatement(_) => "StaticStatement",
            NodeKind::SwitchStatement(_) => "SwitchStatement",
            NodeKind::EchoStatement(_) => "EchoStatement",
            NodeKind::ReturnStatement(_) => "ReturnStatement",
            NodeKind::UseStatement(_) => "UseStatement",
            NodeKind::GroupUseStatement(_) => "GroupUseStatement",
            NodeKind::HaltCompilerStatement(_) => "HaltCompilerStatement",
            NodeKind::StaticVar(_) => "StaticVar",
            NodeKind::Comment(_) => "Comment",
            NodeKind::CommentKind(_) => "CommentKind",
            NodeKind::SingleLineComment(_) => "SingleLineComment",
            NodeKind::MultiLineComment(_) => "MultiLineComment",
            NodeKind::HashMarkComment(_) => "HashMarkComment",
            NodeKind::DocBlockComment(_) => "DocBlockComment",
            NodeKind::DocBlock(_) => "DocBlock",
            NodeKind::DocBlockNode(_) => "DocBlockNode",
            NodeKind::DocBlockTextNode(_) => "DocBlockTextNode",
            NodeKind::DocBlockTagNode(_) => "DocBlockTagNode",
            NodeKind::DocBlockTag(_) => "DocBlockTag",
            NodeKind::DocBlockParamClosureThisTag(_) => "DocBlockParamClosureThisTag",
            NodeKind::DocBlockParamTag(_) => "DocBlockParamTag",
            NodeKind::DocBlockReturnTag(_) => "DocBlockReturnTag",
            NodeKind::DocBlockThrowsTag(_) => "DocBlockThrowsTag",
            NodeKind::DocBlockVarTag(_) => "DocBlockVarTag",
            NodeKind::DocBlockPropertyTag(_) => "DocBlockPropertyTag",
            NodeKind::DocBlockMethodTag(_) => "DocBlockMethodTag",
            NodeKind::DocBlockTemplateTagValue(_) => "DocBlockTemplateTagValue",
            NodeKind::DocBlockTemplateTag(_) => "DocBlockTemplateTag",
            NodeKind::DocBlockExtendsTag(_) => "DocBlockExtendsTag",
            NodeKind::DocBlockImplementsTag(_) => "DocBlockImplementsTag",
            NodeKind::DocBlockUsesTag(_) => "DocBlockUsesTag",
            NodeKind::DocBlockDeprecatedTag(_) => "DocBlockDeprecatedTag",
            NodeKind::DocBlockGenericTag(_) => "DocBlockGenericTag",
            NodeKind::CommentGroup(_) => "CommentGroup",
        }
    }
    pub fn children(&self) -> Vec<Node<'a>> {
        let mut children: Vec<Node<'a>> = Vec::new();
        match &self.kind {
            NodeKind::Statement(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::StatementKind(node) => match node {
                StatementKind::FullOpeningTag(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::ShortOpeningTag(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::EchoOpeningTag(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::ClosingTag(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::InlineHtml(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Label(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Goto(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::HaltCompiler(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Static(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::DoWhile(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::While(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::For(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Foreach(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Break(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Continue(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Constant(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Function(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Class(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Trait(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Interface(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::If(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Switch(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Echo(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Expression(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Return(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Namespace(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Use(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::GroupUse(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Comment(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Try(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::UnitEnum(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::BackedEnum(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Block(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Global(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                StatementKind::Declare(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                _ => {}
            },
            NodeKind::Expression(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::ExpressionKind(node) => match node {
                ExpressionKind::Missing(inner) => {
                    children.push(inner.into());
                }
                ExpressionKind::Eval(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Empty(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Die(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Exit(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Isset(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Unset(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Print(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Literal(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ArithmeticOperation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::AssignmentOperation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::BitwiseOperation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ComparisonOperation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::LogicalOperation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Concat(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Instanceof(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Reference(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Parenthesized(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ErrorSuppress(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Identifier(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Variable(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Include(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::IncludeOnce(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Require(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::RequireOnce(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::FunctionCall(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::FunctionClosureCreation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::MethodCall(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::MethodClosureCreation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::NullsafeMethodCall(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::StaticMethodCall(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::StaticVariableMethodCall(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::StaticMethodClosureCreation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::StaticVariableMethodClosureCreation(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::PropertyFetch(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::NullsafePropertyFetch(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::StaticPropertyFetch(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ConstantFetch(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Static(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Self_(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Parent(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Array(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::List(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Closure(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ArrowFunction(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::New(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::InterpolatedString(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Heredoc(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Nowdoc(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ShellExec(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::AnonymousClass(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Bool(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ArrayIndex(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::MagicConstant(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::ShortTernary(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Ternary(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Coalesce(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Clone(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Match(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Throw(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Yield(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::YieldFrom(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Cast(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                ExpressionKind::Name(inner) => {
                    let x = inner.as_ref();
                    children.push(x.into());
                }
                _ => {}
            },
            NodeKind::ExpressionStatement(node) => {
                let x = &node.expression;
                children.push(x.into());
            }
            NodeKind::GlobalStatement(node) => {
                for x in &node.variables {
                    children.push(x.into());
                }
            }
            NodeKind::BlockStatement(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::Case(node) => {
                if let Some(child) = &node.condition {
                    children.push(child.into());
                }
                for x in &node.body {
                    children.push(x.into());
                }
            }
            NodeKind::Use(node) => {
                let x = &node.name;
                children.push(x.into());
                if let Some(child) = &node.alias {
                    children.push(child.into());
                }
            }
            NodeKind::EvalExpression(node) => {
                let x = node.argument.as_ref();
                children.push(x.into());
            }
            NodeKind::EmptyExpression(node) => {
                let x = node.argument.as_ref();
                children.push(x.into());
            }
            NodeKind::DieExpression(node) => {
                if let Some(child) = &node.argument {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::ExitExpression(node) => {
                if let Some(child) = &node.argument {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::IssetExpression(node) => {
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::UnsetExpression(node) => {
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::PrintExpression(node) => {
                if let Some(child) = &node.value {
                    let child = child.as_ref();
                    children.push(child.into());
                }
                if let Some(child) = &node.argument {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::ConcatExpression(node) => {
                let x = node.left.as_ref();
                children.push(x.into());
                let x = node.right.as_ref();
                children.push(x.into());
            }
            NodeKind::InstanceofExpression(node) => {
                let x = node.left.as_ref();
                children.push(x.into());
                let x = node.right.as_ref();
                children.push(x.into());
            }
            NodeKind::ReferenceExpression(node) => {
                let x = node.right.as_ref();
                children.push(x.into());
            }
            NodeKind::ParenthesizedExpression(node) => {
                let x = node.expr.as_ref();
                children.push(x.into());
            }
            NodeKind::ErrorSuppressExpression(node) => {
                let x = node.expr.as_ref();
                children.push(x.into());
            }
            NodeKind::IncludeExpression(node) => {
                let x = node.path.as_ref();
                children.push(x.into());
            }
            NodeKind::IncludeOnceExpression(node) => {
                let x = node.path.as_ref();
                children.push(x.into());
            }
            NodeKind::RequireExpression(node) => {
                let x = node.path.as_ref();
                children.push(x.into());
            }
            NodeKind::RequireOnceExpression(node) => {
                let x = node.path.as_ref();
                children.push(x.into());
            }
            NodeKind::FunctionCallExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::FunctionClosureCreationExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.placeholder;
                children.push(x.into());
            }
            NodeKind::MethodCallExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = node.method.as_ref();
                children.push(x.into());
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::MethodClosureCreationExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = node.method.as_ref();
                children.push(x.into());
            }
            NodeKind::NullsafeMethodCallExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = node.method.as_ref();
                children.push(x.into());
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::StaticMethodCallExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.method;
                children.push(x.into());
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::StaticVariableMethodCallExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.method;
                children.push(x.into());
                let x = &node.arguments;
                children.push(x.into());
            }
            NodeKind::StaticMethodClosureCreationExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.method;
                children.push(x.into());
            }
            NodeKind::StaticVariableMethodClosureCreationExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.method;
                children.push(x.into());
            }
            NodeKind::PropertyFetchExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = node.property.as_ref();
                children.push(x.into());
            }
            NodeKind::NullsafePropertyFetchExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = node.property.as_ref();
                children.push(x.into());
            }
            NodeKind::StaticPropertyFetchExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.property;
                children.push(x.into());
            }
            NodeKind::ConstantFetchExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                let x = &node.constant;
                children.push(x.into());
            }
            NodeKind::ArrayExpression(node) => {
                for x in &node.items.inner {
                    children.push(x.into());
                }
            }
            NodeKind::ListExpression(node) => {
                for x in &node.items {
                    children.push(x.into());
                }
            }
            NodeKind::NewExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
                if let Some(child) = &node.arguments {
                    children.push(child.into());
                }
            }
            NodeKind::InterpolatedStringExpression(node) => {
                for x in &node.parts {
                    children.push(x.into());
                }
            }
            NodeKind::HeredocExpression(node) => {
                for x in &node.parts {
                    children.push(x.into());
                }
            }
            NodeKind::ShellExecExpression(node) => {
                for x in &node.parts {
                    children.push(x.into());
                }
            }
            NodeKind::ArrayIndexExpression(node) => {
                let x = node.array.as_ref();
                children.push(x.into());
                if let Some(child) = &node.index {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::ShortTernaryExpression(node) => {
                let x = node.condition.as_ref();
                children.push(x.into());
                let x = node.r#else.as_ref();
                children.push(x.into());
            }
            NodeKind::TernaryExpression(node) => {
                let x = node.condition.as_ref();
                children.push(x.into());
                let x = node.then.as_ref();
                children.push(x.into());
                let x = node.r#else.as_ref();
                children.push(x.into());
            }
            NodeKind::CoalesceExpression(node) => {
                let x = node.lhs.as_ref();
                children.push(x.into());
                let x = node.rhs.as_ref();
                children.push(x.into());
            }
            NodeKind::CloneExpression(node) => {
                let x = node.target.as_ref();
                children.push(x.into());
            }
            NodeKind::MatchExpression(node) => {
                let x = node.condition.as_ref();
                children.push(x.into());
                for x in &node.arms {
                    children.push(x.into());
                }
                if let Some(child) = &node.default {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::ThrowExpression(node) => {
                let x = node.value.as_ref();
                children.push(x.into());
            }
            NodeKind::YieldExpression(node) => {
                if let Some(child) = &node.key {
                    let child = child.as_ref();
                    children.push(child.into());
                }
                if let Some(child) = &node.value {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::YieldFromExpression(node) => {
                let x = node.value.as_ref();
                children.push(x.into());
            }
            NodeKind::CastExpression(node) => {
                let x = node.value.as_ref();
                children.push(x.into());
            }
            NodeKind::DefaultMatchArm(node) => {
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::MatchArm(node) => {
                for x in &node.conditions {
                    children.push(x.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::StringPart(node) => match node {
                StringPart::Literal(inner) => {
                    children.push(inner.into());
                }
                StringPart::Expression(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ExpressionStringPart(node) => {
                let x = node.expression.as_ref();
                children.push(x.into());
            }
            NodeKind::ArrayItem(node) => match node {
                ArrayItem::Value(inner) => {
                    children.push(inner.into());
                }
                ArrayItem::ReferencedValue(inner) => {
                    children.push(inner.into());
                }
                ArrayItem::SpreadValue(inner) => {
                    children.push(inner.into());
                }
                ArrayItem::KeyValue(inner) => {
                    children.push(inner.into());
                }
                ArrayItem::ReferencedKeyValue(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ArrayItemValue(node) => {
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ArrayItemReferencedValue(node) => {
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ArrayItemSpreadValue(node) => {
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ArrayItemKeyValue(node) => {
                let x = &node.key;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ArrayItemReferencedKeyValue(node) => {
                let x = &node.key;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ListEntry(node) => match node {
                ListEntry::Value(inner) => {
                    children.push(inner.into());
                }
                ListEntry::KeyValue(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ListEntryValue(node) => {
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ListEntryKeyValue(node) => {
                let x = &node.key;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::PositionalArgument(node) => {
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::NamedArgument(node) => {
                let x = &node.name;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::Argument(node) => match node {
                Argument::Positional(inner) => {
                    children.push(inner.into());
                }
                Argument::Named(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ArgumentList(node) => {
                for x in &node.arguments {
                    children.push(x.into());
                }
            }
            NodeKind::SingleArgument(node) => {
                if let Some(child) = &node.argument {
                    children.push(child.into());
                }
            }
            NodeKind::Attribute(node) => {
                let x = &node.name;
                children.push(x.into());
                if let Some(child) = &node.arguments {
                    children.push(child.into());
                }
            }
            NodeKind::AttributeGroup(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::ClassBody(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::ClassStatement(node) => {
                let x = &node.name;
                children.push(x.into());
                if let Some(child) = &node.extends {
                    children.push(child.into());
                }
                if let Some(child) = &node.implements {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::AnonymousClassBody(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::AnonymousClassExpression(node) => {
                if let Some(child) = &node.extends {
                    children.push(child.into());
                }
                if let Some(child) = &node.implements {
                    children.push(child.into());
                }
                let x = node.body.as_ref();
                children.push(x.into());
            }
            NodeKind::ClassExtends(node) => {
                let x = &node.parent;
                children.push(x.into());
            }
            NodeKind::ClassImplements(node) => {
                for x in &node.interfaces.inner {
                    children.push(x.into());
                }
            }
            NodeKind::ClassishMember(node) => match node {
                ClassishMember::Constant(inner) => {
                    children.push(inner.into());
                }
                ClassishMember::TraitUsage(inner) => {
                    children.push(inner.into());
                }
                ClassishMember::Property(inner) => {
                    children.push(inner.into());
                }
                ClassishMember::Method(inner) => {
                    children.push(inner.into());
                }
                ClassishMember::Missing(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::Method(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.name;
                children.push(x.into());
                let x = &node.parameters;
                children.push(x.into());
                if let Some(child) = &node.return_type {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::MethodBody(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::MethodBodyKind(node) => match node {
                MethodBodyKind::Abstract(inner) => {
                    children.push(inner.into());
                }
                MethodBodyKind::Concrete(inner) => {
                    children.push(inner.into());
                }
                MethodBodyKind::Missing(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ConcreteMethodBody(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::MethodParameterList(node) => {
                for x in &node.parameters.inner {
                    children.push(x.into());
                }
            }
            NodeKind::MethodParameter(node) => {
                let x = &node.name;
                children.push(x.into());
                if let Some(child) = &node.data_type {
                    children.push(child.into());
                }
                if let Some(child) = &node.default {
                    children.push(child.into());
                }
            }
            NodeKind::ConstantEntry(node) => {
                let x = &node.name;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ClassishConstantEntry(node) => {
                let x = &node.name;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ConstantStatement(node) => {
                for x in &node.entries {
                    children.push(x.into());
                }
            }
            NodeKind::ClassishConstant(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                if let Some(child) = &node.data_type {
                    children.push(child.into());
                }
                for x in &node.entries {
                    children.push(x.into());
                }
            }
            NodeKind::IfStatement(node) => {
                let x = &node.condition;
                children.push(x.into());
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::IfStatementBody(node) => match node {
                IfStatementBody::Statement(inner) => {
                    children.push(inner.into());
                }
                IfStatementBody::Block(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::IfStatementBodyStatement(node) => {
                let x = node.statement.as_ref();
                children.push(x.into());
                for x in &node.elseifs {
                    children.push(x.into());
                }
                if let Some(child) = &node.r#else {
                    children.push(child.into());
                }
            }
            NodeKind::IfStatementBodyBlock(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
                for x in &node.elseifs {
                    children.push(x.into());
                }
                if let Some(child) = &node.r#else {
                    let child = child.as_ref();
                    children.push(child.into());
                }
            }
            NodeKind::IfStatementElseIf(node) => {
                let x = &node.condition;
                children.push(x.into());
                let x = node.statement.as_ref();
                children.push(x.into());
            }
            NodeKind::IfStatementElse(node) => {
                let x = node.statement.as_ref();
                children.push(x.into());
            }
            NodeKind::IfStatementElseIfBlock(node) => {
                let x = &node.condition;
                children.push(x.into());
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::IfStatementElseBlock(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::DeclareEntry(node) => {
                let x = &node.key;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::DeclareEntryGroup(node) => {
                for x in &node.entries {
                    children.push(x.into());
                }
            }
            NodeKind::DeclareBody(node) => match node {
                DeclareBody::Noop(inner) => {
                    children.push(inner.into());
                }
                DeclareBody::Braced(inner) => {
                    children.push(inner.into());
                }
                DeclareBody::Expression(inner) => {
                    children.push(inner.into());
                }
                DeclareBody::Block(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::DeclareBodyBraced(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::DeclareBodyExpression(node) => {
                let x = &node.expression;
                children.push(x.into());
            }
            NodeKind::DeclareBodyBlock(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::DeclareStatement(node) => {
                let x = &node.entries;
                children.push(x.into());
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::UnitEnumCase(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.name;
                children.push(x.into());
            }
            NodeKind::UnitEnumMember(node) => match node {
                UnitEnumMember::Case(inner) => {
                    children.push(inner.into());
                }
                UnitEnumMember::Classish(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::UnitEnumBody(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::UnitEnumStatement(node) => {
                let x = &node.name;
                children.push(x.into());
                for x in &node.implements {
                    children.push(x.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::BackedEnumCase(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.name;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::BackedEnumMember(node) => match node {
                BackedEnumMember::Case(inner) => {
                    children.push(inner.into());
                }
                BackedEnumMember::Classish(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::BackedEnumBody(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::BackedEnumStatement(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.name;
                children.push(x.into());
                for x in &node.implements {
                    children.push(x.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::ReturnType(node) => {
                let x = &node.data_type;
                children.push(x.into());
            }
            NodeKind::FunctionParameter(node) => {
                let x = &node.name;
                children.push(x.into());
                if let Some(child) = &node.data_type {
                    children.push(child.into());
                }
                if let Some(child) = &node.default {
                    children.push(child.into());
                }
            }
            NodeKind::FunctionParameterList(node) => {
                for x in &node.parameters.inner {
                    children.push(x.into());
                }
            }
            NodeKind::FunctionBody(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::FunctionStatement(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.name;
                children.push(x.into());
                let x = &node.parameters;
                children.push(x.into());
                if let Some(child) = &node.return_type {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::ClosureUseVariable(node) => {
                let x = &node.variable;
                children.push(x.into());
            }
            NodeKind::ClosureUse(node) => {
                for x in &node.variables.inner {
                    children.push(x.into());
                }
            }
            NodeKind::ClosureExpression(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.parameters;
                children.push(x.into());
                if let Some(child) = &node.uses {
                    children.push(child.into());
                }
                if let Some(child) = &node.return_type {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::ArrowFunctionExpression(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.parameters;
                children.push(x.into());
                if let Some(child) = &node.return_type {
                    children.push(child.into());
                }
                let x = node.body.as_ref();
                children.push(x.into());
            }
            NodeKind::LabelStatement(node) => {
                let x = &node.label;
                children.push(x.into());
            }
            NodeKind::GotoStatement(node) => {
                let x = &node.label;
                children.push(x.into());
            }
            NodeKind::Identifier(node) => match node {
                Identifier::SimpleIdentifier(inner) => {
                    children.push(inner.into());
                }
                Identifier::DynamicIdentifier(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::DynamicIdentifier(node) => {
                let x = node.expr.as_ref();
                children.push(x.into());
            }
            NodeKind::InterfaceExtends(node) => {
                for x in &node.parents.inner {
                    children.push(x.into());
                }
            }
            NodeKind::InterfaceBody(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::InterfaceStatement(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.name;
                children.push(x.into());
                if let Some(child) = &node.extends {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::ForeachStatement(node) => {
                let x = &node.iterator;
                children.push(x.into());
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::ForeachStatementIterator(node) => match node {
                ForeachStatementIterator::Value(inner) => {
                    children.push(inner.into());
                }
                ForeachStatementIterator::KeyAndValue(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ForeachStatementIteratorValue(node) => {
                let x = &node.expression;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ForeachStatementIteratorKeyAndValue(node) => {
                let x = &node.expression;
                children.push(x.into());
                let x = &node.key;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::ForeachStatementBodyStatement(node) => {
                let x = node.statement.as_ref();
                children.push(x.into());
            }
            NodeKind::ForeachStatementBodyBlock(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::ForStatement(node) => {
                let x = &node.iterator;
                children.push(x.into());
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::ForStatementIterator(node) => {
                for x in &node.initializations.inner {
                    children.push(x.into());
                }
                for x in &node.conditions.inner {
                    children.push(x.into());
                }
                for x in &node.r#loop.inner {
                    children.push(x.into());
                }
            }
            NodeKind::ForStatementBodyStatement(node) => {
                let x = node.statement.as_ref();
                children.push(x.into());
            }
            NodeKind::ForStatementBodyBlock(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::DoWhileStatement(node) => {
                let x = &node.condition;
                children.push(x.into());
                let x = node.body.as_ref();
                children.push(x.into());
            }
            NodeKind::WhileStatement(node) => {
                let x = &node.condition;
                children.push(x.into());
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::WhileStatementBody(node) => match node {
                WhileStatementBody::Statement(inner) => {
                    children.push(inner.into());
                }
                WhileStatementBody::Block(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::WhileStatementBodyStatement(node) => {
                let x = node.statement.as_ref();
                children.push(x.into());
            }
            NodeKind::WhileStatementBodyBlock(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::ParenthesizedLevel(node) => {
                let x = node.level.as_ref();
                children.push(x.into());
            }
            NodeKind::BreakStatement(node) => {
                if let Some(child) = &node.level {
                    children.push(child.into());
                }
            }
            NodeKind::ContinueStatement(node) => {
                if let Some(child) = &node.level {
                    children.push(child.into());
                }
            }
            NodeKind::UnbracedNamespace(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::BracedNamespace(node) => {
                if let Some(child) = &node.name {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::BracedNamespaceBody(node) => {
                for x in &node.statements {
                    children.push(x.into());
                }
            }
            NodeKind::NamespaceStatement(node) => match node {
                NamespaceStatement::Unbraced(inner) => {
                    children.push(inner.into());
                }
                NamespaceStatement::Braced(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ArithmeticOperationExpression(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::ArithmeticOperationKind(node) => match node {
                ArithmeticOperationKind::Addition {
                    left, plus, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Subtraction {
                    left, minus, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Multiplication {
                    left,
                    asterisk,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Division {
                    left, slash, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Modulo {
                    left,
                    percent,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Exponentiation {
                    left, pow, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Negative { minus, right, .. } => {
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::Positive { plus, right, .. } => {
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::PreIncrement {
                    increment, right, ..
                } => {
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::PostIncrement {
                    left, increment, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::PreDecrement {
                    decrement, right, ..
                } => {
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ArithmeticOperationKind::PostDecrement {
                    left, decrement, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                }
            },
            NodeKind::AssignmentOperationExpression(node) => {
                let x = node.left.as_ref();
                children.push(x.into());
                let x = node.right.as_ref();
                children.push(x.into());
            }
            NodeKind::BitwiseOperationExpression(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::BitwiseOperationKind(node) => match node {
                BitwiseOperationKind::And {
                    left, and, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                BitwiseOperationKind::Or {
                    left, or, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                BitwiseOperationKind::Xor {
                    left, xor, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                BitwiseOperationKind::LeftShift {
                    left,
                    left_shift,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                BitwiseOperationKind::RightShift {
                    left,
                    right_shift,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                BitwiseOperationKind::Not { not, right, .. } => {
                    let x = right.as_ref();
                    children.push(x.into());
                }
            },
            NodeKind::ComparisonOperationExpression(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::ComparisonOperationKind(node) => match node {
                ComparisonOperationKind::Equal {
                    left,
                    double_equals,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::Identical {
                    left,
                    triple_equals,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::NotEqual {
                    left,
                    bang_equals,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::AngledNotEqual {
                    left,
                    angled_left_right,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::NotIdentical {
                    left,
                    bang_double_equals,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::LessThan {
                    left,
                    less_than,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::GreaterThan {
                    left,
                    greater_than,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::LessThanOrEqual {
                    left,
                    less_than_equals,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::GreaterThanOrEqual {
                    left,
                    greater_than_equals,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                ComparisonOperationKind::Spaceship {
                    left,
                    spaceship,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
            },
            NodeKind::LogicalOperationExpression(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::LogicalOperationKind(node) => match node {
                LogicalOperationKind::And {
                    left,
                    double_ampersand,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                LogicalOperationKind::Or {
                    left,
                    double_pipe,
                    right,
                    ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                LogicalOperationKind::Not { bang, right, .. } => {
                    let x = right.as_ref();
                    children.push(x.into());
                }
                LogicalOperationKind::LogicalAnd {
                    left, and, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                LogicalOperationKind::LogicalOr {
                    left, or, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
                LogicalOperationKind::LogicalXor {
                    left, xor, right, ..
                } => {
                    let x = left.as_ref();
                    children.push(x.into());
                    let x = right.as_ref();
                    children.push(x.into());
                }
            },
            NodeKind::Property(node) => match node {
                Property::Simple(inner) => {
                    children.push(inner.into());
                }
                Property::Hooked(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::SimpleProperty(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                if let Some(child) = &node.r#type {
                    children.push(child.into());
                }
                for x in &node.entries {
                    children.push(x.into());
                }
            }
            NodeKind::HookedProperty(node) => {
                for x in &node.attributes {
                    children.push(x.into());
                }
                if let Some(child) = &node.r#type {
                    children.push(child.into());
                }
                let x = &node.entry;
                children.push(x.into());
                let x = &node.hooks;
                children.push(x.into());
            }
            NodeKind::PropertyHookList(node) => {
                for x in &node.hooks {
                    children.push(x.into());
                }
            }
            NodeKind::PropertyHook(node) => {
                if let Some(child) = &node.parameters {
                    children.push(child.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::PropertyHookBody(node) => match node {
                PropertyHookBody::Concrete(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ConcretePropertyHookBody(node) => match node {
                ConcretePropertyHookBody::Block(inner) => {
                    children.push(inner.into());
                }
                ConcretePropertyHookBody::Expression(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::ConcretePropertyHookBodyBlock(node) => {
                for x in &node.body {
                    children.push(x.into());
                }
            }
            NodeKind::ConcretePropertyHookBodyExpression(node) => {
                let x = &node.expression;
                children.push(x.into());
            }
            NodeKind::PropertyEntry(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::UninitializedPropertyEntry(node) => {
                let x = &node.variable;
                children.push(x.into());
            }
            NodeKind::InitializedPropertyEntry(node) => {
                let x = &node.variable;
                children.push(x.into());
                let x = &node.value;
                children.push(x.into());
            }
            NodeKind::TraitBody(node) => {
                for x in &node.members {
                    children.push(x.into());
                }
            }
            NodeKind::TraitStatement(node) => {
                let x = &node.name;
                children.push(x.into());
                for x in &node.attributes {
                    children.push(x.into());
                }
                let x = &node.body;
                children.push(x.into());
            }
            NodeKind::TraitUsage(node) => {
                for x in &node.traits {
                    children.push(x.into());
                }
                for x in &node.adaptations {
                    children.push(x.into());
                }
            }
            NodeKind::TraitUsageAdaptation(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::TraitUsageAdaptationAlias(node) => {
                if let Some(child) = &node.r#trait {
                    children.push(child.into());
                }
                let x = &node.method;
                children.push(x.into());
                let x = &node.alias;
                children.push(x.into());
            }
            NodeKind::TraitUsageAdaptationVisibility(node) => {
                if let Some(child) = &node.r#trait {
                    children.push(child.into());
                }
                let x = &node.method;
                children.push(x.into());
            }
            NodeKind::TraitUsageAdaptationPrecedence(node) => {
                if let Some(child) = &node.r#trait {
                    children.push(child.into());
                }
                let x = &node.method;
                children.push(x.into());
                for x in &node.insteadof {
                    children.push(x.into());
                }
            }
            NodeKind::CatchType(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::CatchTypeKindIdentifier(node) => {
                let x = &node.identifier;
                children.push(x.into());
            }
            NodeKind::CatchTypeKindUnion(node) => {
                for x in &node.identifiers {
                    children.push(x.into());
                }
            }
            NodeKind::TryStatement(node) => {
                for x in &node.body {
                    children.push(x.into());
                }
                for x in &node.catches {
                    children.push(x.into());
                }
                if let Some(child) = &node.finally {
                    children.push(child.into());
                }
            }
            NodeKind::CatchBlock(node) => {
                let x = &node.types;
                children.push(x.into());
                if let Some(child) = &node.var {
                    children.push(child.into());
                }
                for x in &node.body {
                    children.push(x.into());
                }
            }
            NodeKind::FinallyBlock(node) => {
                for x in &node.body {
                    children.push(x.into());
                }
            }
            NodeKind::Variable(node) => match node {
                Variable::SimpleVariable(inner) => {
                    children.push(inner.into());
                }
                Variable::VariableVariable(inner) => {
                    children.push(inner.into());
                }
                Variable::BracedVariableVariable(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::VariableVariable(node) => {
                let x = node.variable.as_ref();
                children.push(x.into());
            }
            NodeKind::BracedVariableVariable(node) => {
                let x = node.variable.as_ref();
                children.push(x.into());
            }
            NodeKind::StaticStatement(node) => {
                for x in &node.vars {
                    children.push(x.into());
                }
            }
            NodeKind::SwitchStatement(node) => {
                let x = &node.condition;
                children.push(x.into());
                for x in &node.cases {
                    children.push(x.into());
                }
            }
            NodeKind::EchoStatement(node) => {
                for x in &node.values {
                    children.push(x.into());
                }
            }
            NodeKind::ReturnStatement(node) => {
                if let Some(child) = &node.value {
                    children.push(child.into());
                }
            }
            NodeKind::UseStatement(node) => {
                for x in &node.uses {
                    children.push(x.into());
                }
            }
            NodeKind::GroupUseStatement(node) => {
                let x = &node.prefix;
                children.push(x.into());
                for x in &node.uses {
                    children.push(x.into());
                }
            }
            NodeKind::StaticVar(node) => {
                let x = &node.var;
                children.push(x.into());
                if let Some(child) = &node.default {
                    children.push(child.into());
                }
            }
            NodeKind::Comment(node) => {
                let x = &node.kind;
                children.push(x.into());
            }
            NodeKind::CommentKind(node) => match node {
                CommentKind::SingleLine(inner) => {
                    children.push(inner.into());
                }
                CommentKind::MultiLine(inner) => {
                    children.push(inner.into());
                }
                CommentKind::HashMark(inner) => {
                    children.push(inner.into());
                }
                CommentKind::DocBlock(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::DocBlockComment(node) => {
                let x = &node.doc;
                children.push(x.into());
            }
            NodeKind::DocBlock(node) => {
                for x in &node.nodes {
                    children.push(x.into());
                }
            }
            NodeKind::DocBlockNode(node) => match node {
                DocBlockNode::Text(inner) => {
                    children.push(inner.into());
                }
                DocBlockNode::Tag(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            NodeKind::DocBlockTag(node) => match node {
                DocBlockTag::ParamClosureThis(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Param(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Return(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Throws(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Var(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Property(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Method(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Template(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Extends(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Implements(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Uses(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Deprecated(inner) => {
                    children.push(inner.into());
                }
                DocBlockTag::Generic(inner) => {
                    children.push(inner.into());
                }
                _ => {}
            },
            _ => {}
        }
        children
    }

    pub fn as_ptr(&self) -> NonNull<()> {
        match &self.kind {
            NodeKind::Block(node) => NonNull::from(node).cast(),
            NodeKind::Statement(node) => NonNull::from(node).cast(),
            NodeKind::StatementKind(node) => NonNull::from(node).cast(),
            NodeKind::Expression(node) => NonNull::from(node).cast(),
            NodeKind::ExpressionKind(node) => NonNull::from(node).cast(),
            NodeKind::MissingExpression(node) => NonNull::from(node).cast(),
            NodeKind::StaticExpression(node) => NonNull::from(node).cast(),
            NodeKind::SelfExpression(node) => NonNull::from(node).cast(),
            NodeKind::ParentExpression(node) => NonNull::from(node).cast(),
            NodeKind::CommentStatement(node) => NonNull::from(node).cast(),
            NodeKind::InlineHtmlStatement(node) => NonNull::from(node).cast(),
            NodeKind::FullOpeningTagStatement(node) => NonNull::from(node).cast(),
            NodeKind::ShortOpeningTagStatement(node) => NonNull::from(node).cast(),
            NodeKind::EchoOpeningTagStatement(node) => NonNull::from(node).cast(),
            NodeKind::ClosingTagStatement(node) => NonNull::from(node).cast(),
            NodeKind::ExpressionStatement(node) => NonNull::from(node).cast(),
            NodeKind::GlobalStatement(node) => NonNull::from(node).cast(),
            NodeKind::BlockStatement(node) => NonNull::from(node).cast(),
            NodeKind::Case(node) => NonNull::from(node).cast(),
            NodeKind::Use(node) => NonNull::from(node).cast(),
            NodeKind::EvalExpression(node) => NonNull::from(node).cast(),
            NodeKind::EmptyExpression(node) => NonNull::from(node).cast(),
            NodeKind::DieExpression(node) => NonNull::from(node).cast(),
            NodeKind::ExitExpression(node) => NonNull::from(node).cast(),
            NodeKind::IssetExpression(node) => NonNull::from(node).cast(),
            NodeKind::UnsetExpression(node) => NonNull::from(node).cast(),
            NodeKind::PrintExpression(node) => NonNull::from(node).cast(),
            NodeKind::ConcatExpression(node) => NonNull::from(node).cast(),
            NodeKind::InstanceofExpression(node) => NonNull::from(node).cast(),
            NodeKind::ReferenceExpression(node) => NonNull::from(node).cast(),
            NodeKind::ParenthesizedExpression(node) => NonNull::from(node).cast(),
            NodeKind::ErrorSuppressExpression(node) => NonNull::from(node).cast(),
            NodeKind::IncludeExpression(node) => NonNull::from(node).cast(),
            NodeKind::IncludeOnceExpression(node) => NonNull::from(node).cast(),
            NodeKind::RequireExpression(node) => NonNull::from(node).cast(),
            NodeKind::RequireOnceExpression(node) => NonNull::from(node).cast(),
            NodeKind::FunctionCallExpression(node) => NonNull::from(node).cast(),
            NodeKind::FunctionClosureCreationExpression(node) => NonNull::from(node).cast(),
            NodeKind::MethodCallExpression(node) => NonNull::from(node).cast(),
            NodeKind::MethodClosureCreationExpression(node) => NonNull::from(node).cast(),
            NodeKind::NullsafeMethodCallExpression(node) => NonNull::from(node).cast(),
            NodeKind::StaticMethodCallExpression(node) => NonNull::from(node).cast(),
            NodeKind::StaticVariableMethodCallExpression(node) => NonNull::from(node).cast(),
            NodeKind::StaticMethodClosureCreationExpression(node) => NonNull::from(node).cast(),
            NodeKind::StaticVariableMethodClosureCreationExpression(node) => {
                NonNull::from(node).cast()
            }
            NodeKind::PropertyFetchExpression(node) => NonNull::from(node).cast(),
            NodeKind::NullsafePropertyFetchExpression(node) => NonNull::from(node).cast(),
            NodeKind::StaticPropertyFetchExpression(node) => NonNull::from(node).cast(),
            NodeKind::ConstantFetchExpression(node) => NonNull::from(node).cast(),
            NodeKind::ArrayExpression(node) => NonNull::from(node).cast(),
            NodeKind::ListExpression(node) => NonNull::from(node).cast(),
            NodeKind::NewExpression(node) => NonNull::from(node).cast(),
            NodeKind::InterpolatedStringExpression(node) => NonNull::from(node).cast(),
            NodeKind::HeredocExpression(node) => NonNull::from(node).cast(),
            NodeKind::NowdocExpression(node) => NonNull::from(node).cast(),
            NodeKind::ShellExecExpression(node) => NonNull::from(node).cast(),
            NodeKind::BoolExpression(node) => NonNull::from(node).cast(),
            NodeKind::ArrayIndexExpression(node) => NonNull::from(node).cast(),
            NodeKind::ShortTernaryExpression(node) => NonNull::from(node).cast(),
            NodeKind::TernaryExpression(node) => NonNull::from(node).cast(),
            NodeKind::CoalesceExpression(node) => NonNull::from(node).cast(),
            NodeKind::CloneExpression(node) => NonNull::from(node).cast(),
            NodeKind::MatchExpression(node) => NonNull::from(node).cast(),
            NodeKind::ThrowExpression(node) => NonNull::from(node).cast(),
            NodeKind::YieldExpression(node) => NonNull::from(node).cast(),
            NodeKind::YieldFromExpression(node) => NonNull::from(node).cast(),
            NodeKind::CastExpression(node) => NonNull::from(node).cast(),
            NodeKind::DefaultMatchArm(node) => NonNull::from(node).cast(),
            NodeKind::MatchArm(node) => NonNull::from(node).cast(),
            NodeKind::MagicConstantExpression(node) => NonNull::from(node).cast(),
            NodeKind::StringPart(node) => NonNull::from(node).cast(),
            NodeKind::LiteralStringPart(node) => NonNull::from(node).cast(),
            NodeKind::ExpressionStringPart(node) => NonNull::from(node).cast(),
            NodeKind::ArrayItem(node) => NonNull::from(node).cast(),
            NodeKind::ArrayItemValue(node) => NonNull::from(node).cast(),
            NodeKind::ArrayItemReferencedValue(node) => NonNull::from(node).cast(),
            NodeKind::ArrayItemSpreadValue(node) => NonNull::from(node).cast(),
            NodeKind::ArrayItemKeyValue(node) => NonNull::from(node).cast(),
            NodeKind::ArrayItemReferencedKeyValue(node) => NonNull::from(node).cast(),
            NodeKind::ListEntry(node) => NonNull::from(node).cast(),
            NodeKind::ListEntryValue(node) => NonNull::from(node).cast(),
            NodeKind::ListEntryKeyValue(node) => NonNull::from(node).cast(),
            NodeKind::PositionalArgument(node) => NonNull::from(node).cast(),
            NodeKind::NamedArgument(node) => NonNull::from(node).cast(),
            NodeKind::Argument(node) => NonNull::from(node).cast(),
            NodeKind::ArgumentList(node) => NonNull::from(node).cast(),
            NodeKind::SingleArgument(node) => NonNull::from(node).cast(),
            NodeKind::ArgumentPlaceholder(node) => NonNull::from(node).cast(),
            NodeKind::Attribute(node) => NonNull::from(node).cast(),
            NodeKind::AttributeGroup(node) => NonNull::from(node).cast(),
            NodeKind::ClassBody(node) => NonNull::from(node).cast(),
            NodeKind::ClassStatement(node) => NonNull::from(node).cast(),
            NodeKind::AnonymousClassBody(node) => NonNull::from(node).cast(),
            NodeKind::AnonymousClassExpression(node) => NonNull::from(node).cast(),
            NodeKind::ClassExtends(node) => NonNull::from(node).cast(),
            NodeKind::ClassImplements(node) => NonNull::from(node).cast(),
            NodeKind::ClassishMember(node) => NonNull::from(node).cast(),
            NodeKind::Method(node) => NonNull::from(node).cast(),
            NodeKind::MethodBody(node) => NonNull::from(node).cast(),
            NodeKind::MethodBodyKind(node) => NonNull::from(node).cast(),
            NodeKind::MissingMethodBody(node) => NonNull::from(node).cast(),
            NodeKind::AbstractMethodBody(node) => NonNull::from(node).cast(),
            NodeKind::ConcreteMethodBody(node) => NonNull::from(node).cast(),
            NodeKind::MethodParameterList(node) => NonNull::from(node).cast(),
            NodeKind::MethodParameter(node) => NonNull::from(node).cast(),
            NodeKind::MissingClassishMember(node) => NonNull::from(node).cast(),
            NodeKind::ConstantEntry(node) => NonNull::from(node).cast(),
            NodeKind::ClassishConstantEntry(node) => NonNull::from(node).cast(),
            NodeKind::ConstantStatement(node) => NonNull::from(node).cast(),
            NodeKind::ClassishConstant(node) => NonNull::from(node).cast(),
            NodeKind::IfStatement(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementBody(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementBodyStatement(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementBodyBlock(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementElseIf(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementElse(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementElseIfBlock(node) => NonNull::from(node).cast(),
            NodeKind::IfStatementElseBlock(node) => NonNull::from(node).cast(),
            NodeKind::DataType(node) => NonNull::from(node).cast(),
            NodeKind::DeclareEntry(node) => NonNull::from(node).cast(),
            NodeKind::DeclareEntryGroup(node) => NonNull::from(node).cast(),
            NodeKind::DeclareBody(node) => NonNull::from(node).cast(),
            NodeKind::DeclareBodyNoop(node) => NonNull::from(node).cast(),
            NodeKind::DeclareBodyBraced(node) => NonNull::from(node).cast(),
            NodeKind::DeclareBodyExpression(node) => NonNull::from(node).cast(),
            NodeKind::DeclareBodyBlock(node) => NonNull::from(node).cast(),
            NodeKind::DeclareStatement(node) => NonNull::from(node).cast(),
            NodeKind::UnitEnumCase(node) => NonNull::from(node).cast(),
            NodeKind::UnitEnumMember(node) => NonNull::from(node).cast(),
            NodeKind::UnitEnumBody(node) => NonNull::from(node).cast(),
            NodeKind::UnitEnumStatement(node) => NonNull::from(node).cast(),
            NodeKind::BackedEnumCase(node) => NonNull::from(node).cast(),
            NodeKind::BackedEnumMember(node) => NonNull::from(node).cast(),
            NodeKind::BackedEnumBody(node) => NonNull::from(node).cast(),
            NodeKind::BackedEnumStatement(node) => NonNull::from(node).cast(),
            NodeKind::ReturnType(node) => NonNull::from(node).cast(),
            NodeKind::FunctionParameter(node) => NonNull::from(node).cast(),
            NodeKind::FunctionParameterList(node) => NonNull::from(node).cast(),
            NodeKind::FunctionBody(node) => NonNull::from(node).cast(),
            NodeKind::FunctionStatement(node) => NonNull::from(node).cast(),
            NodeKind::ClosureUseVariable(node) => NonNull::from(node).cast(),
            NodeKind::ClosureUse(node) => NonNull::from(node).cast(),
            NodeKind::ClosureExpression(node) => NonNull::from(node).cast(),
            NodeKind::ArrowFunctionExpression(node) => NonNull::from(node).cast(),
            NodeKind::LabelStatement(node) => NonNull::from(node).cast(),
            NodeKind::GotoStatement(node) => NonNull::from(node).cast(),
            NodeKind::Identifier(node) => NonNull::from(node).cast(),
            NodeKind::SimpleIdentifier(node) => NonNull::from(node).cast(),
            NodeKind::DynamicIdentifier(node) => NonNull::from(node).cast(),
            NodeKind::InterfaceExtends(node) => NonNull::from(node).cast(),
            NodeKind::InterfaceBody(node) => NonNull::from(node).cast(),
            NodeKind::InterfaceStatement(node) => NonNull::from(node).cast(),
            NodeKind::Literal(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatement(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatementIterator(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatementIteratorValue(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatementIteratorKeyAndValue(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatementBody(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatementBodyStatement(node) => NonNull::from(node).cast(),
            NodeKind::ForeachStatementBodyBlock(node) => NonNull::from(node).cast(),
            NodeKind::ForStatement(node) => NonNull::from(node).cast(),
            NodeKind::ForStatementIterator(node) => NonNull::from(node).cast(),
            NodeKind::ForStatementBody(node) => NonNull::from(node).cast(),
            NodeKind::ForStatementBodyStatement(node) => NonNull::from(node).cast(),
            NodeKind::ForStatementBodyBlock(node) => NonNull::from(node).cast(),
            NodeKind::DoWhileStatement(node) => NonNull::from(node).cast(),
            NodeKind::WhileStatement(node) => NonNull::from(node).cast(),
            NodeKind::WhileStatementBody(node) => NonNull::from(node).cast(),
            NodeKind::WhileStatementBodyStatement(node) => NonNull::from(node).cast(),
            NodeKind::WhileStatementBodyBlock(node) => NonNull::from(node).cast(),
            NodeKind::Level(node) => NonNull::from(node).cast(),
            NodeKind::LiteralLevel(node) => NonNull::from(node).cast(),
            NodeKind::ParenthesizedLevel(node) => NonNull::from(node).cast(),
            NodeKind::BreakStatement(node) => NonNull::from(node).cast(),
            NodeKind::ContinueStatement(node) => NonNull::from(node).cast(),
            NodeKind::PromotedPropertyModifierGroup(node) => NonNull::from(node).cast(),
            NodeKind::PropertyModifierGroup(node) => NonNull::from(node).cast(),
            NodeKind::MethodModifierGroup(node) => NonNull::from(node).cast(),
            NodeKind::ClassModifierGroup(node) => NonNull::from(node).cast(),
            NodeKind::ConstantModifierGroup(node) => NonNull::from(node).cast(),
            NodeKind::UnbracedNamespace(node) => NonNull::from(node).cast(),
            NodeKind::BracedNamespace(node) => NonNull::from(node).cast(),
            NodeKind::BracedNamespaceBody(node) => NonNull::from(node).cast(),
            NodeKind::NamespaceStatement(node) => NonNull::from(node).cast(),
            NodeKind::ArithmeticOperationExpression(node) => NonNull::from(node).cast(),
            NodeKind::ArithmeticOperationKind(node) => NonNull::from(node).cast(),
            NodeKind::AssignmentOperationExpression(node) => NonNull::from(node).cast(),
            NodeKind::BitwiseOperationExpression(node) => NonNull::from(node).cast(),
            NodeKind::BitwiseOperationKind(node) => NonNull::from(node).cast(),
            NodeKind::ComparisonOperationExpression(node) => NonNull::from(node).cast(),
            NodeKind::ComparisonOperationKind(node) => NonNull::from(node).cast(),
            NodeKind::LogicalOperationExpression(node) => NonNull::from(node).cast(),
            NodeKind::LogicalOperationKind(node) => NonNull::from(node).cast(),
            NodeKind::Name(node) => NonNull::from(node).cast(),
            NodeKind::Property(node) => NonNull::from(node).cast(),
            NodeKind::SimpleProperty(node) => NonNull::from(node).cast(),
            NodeKind::HookedProperty(node) => NonNull::from(node).cast(),
            NodeKind::PropertyHookList(node) => NonNull::from(node).cast(),
            NodeKind::PropertyHook(node) => NonNull::from(node).cast(),
            NodeKind::PropertyHookBody(node) => NonNull::from(node).cast(),
            NodeKind::ConcretePropertyHookBody(node) => NonNull::from(node).cast(),
            NodeKind::ConcretePropertyHookBodyBlock(node) => NonNull::from(node).cast(),
            NodeKind::ConcretePropertyHookBodyExpression(node) => NonNull::from(node).cast(),
            NodeKind::PropertyEntry(node) => NonNull::from(node).cast(),
            NodeKind::PropertyEntryKind(node) => NonNull::from(node).cast(),
            NodeKind::UninitializedPropertyEntry(node) => NonNull::from(node).cast(),
            NodeKind::InitializedPropertyEntry(node) => NonNull::from(node).cast(),
            NodeKind::TraitBody(node) => NonNull::from(node).cast(),
            NodeKind::TraitStatement(node) => NonNull::from(node).cast(),
            NodeKind::TraitUsage(node) => NonNull::from(node).cast(),
            NodeKind::TraitUsageAdaptation(node) => NonNull::from(node).cast(),
            NodeKind::TraitUsageAdaptationKind(node) => NonNull::from(node).cast(),
            NodeKind::TraitUsageAdaptationAlias(node) => NonNull::from(node).cast(),
            NodeKind::TraitUsageAdaptationVisibility(node) => NonNull::from(node).cast(),
            NodeKind::TraitUsageAdaptationPrecedence(node) => NonNull::from(node).cast(),
            NodeKind::CatchType(node) => NonNull::from(node).cast(),
            NodeKind::CatchTypeKind(node) => NonNull::from(node).cast(),
            NodeKind::CatchTypeKindIdentifier(node) => NonNull::from(node).cast(),
            NodeKind::CatchTypeKindUnion(node) => NonNull::from(node).cast(),
            NodeKind::TryStatement(node) => NonNull::from(node).cast(),
            NodeKind::CatchBlock(node) => NonNull::from(node).cast(),
            NodeKind::FinallyBlock(node) => NonNull::from(node).cast(),
            NodeKind::Variable(node) => NonNull::from(node).cast(),
            NodeKind::SimpleVariable(node) => NonNull::from(node).cast(),
            NodeKind::VariableVariable(node) => NonNull::from(node).cast(),
            NodeKind::BracedVariableVariable(node) => NonNull::from(node).cast(),
            NodeKind::StaticStatement(node) => NonNull::from(node).cast(),
            NodeKind::SwitchStatement(node) => NonNull::from(node).cast(),
            NodeKind::EchoStatement(node) => NonNull::from(node).cast(),
            NodeKind::ReturnStatement(node) => NonNull::from(node).cast(),
            NodeKind::UseStatement(node) => NonNull::from(node).cast(),
            NodeKind::GroupUseStatement(node) => NonNull::from(node).cast(),
            NodeKind::HaltCompilerStatement(node) => NonNull::from(node).cast(),
            NodeKind::StaticVar(node) => NonNull::from(node).cast(),
            NodeKind::Comment(node) => NonNull::from(node).cast(),
            NodeKind::CommentKind(node) => NonNull::from(node).cast(),
            NodeKind::SingleLineComment(node) => NonNull::from(node).cast(),
            NodeKind::MultiLineComment(node) => NonNull::from(node).cast(),
            NodeKind::HashMarkComment(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockComment(node) => NonNull::from(node).cast(),
            NodeKind::DocBlock(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockNode(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockTextNode(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockTagNode(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockParamClosureThisTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockParamTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockReturnTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockThrowsTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockVarTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockPropertyTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockMethodTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockTemplateTagValue(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockTemplateTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockExtendsTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockImplementsTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockUsesTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockDeprecatedTag(node) => NonNull::from(node).cast(),
            NodeKind::DocBlockGenericTag(node) => NonNull::from(node).cast(),
            NodeKind::CommentGroup(node) => NonNull::from(node).cast(),
        }
    }
}

impl<'a> From<&'a Statement> for Node<'a> {
    fn from(node: &'a Statement) -> Self {
        Node::new(node.id(), NodeKind::Statement(node), node.span())
    }
}

impl<'a> From<&'a StatementKind> for Node<'a> {
    fn from(node: &'a StatementKind) -> Self {
        Node::new(node.id(), NodeKind::StatementKind(node), node.span())
    }
}

impl<'a> From<&'a Expression> for Node<'a> {
    fn from(node: &'a Expression) -> Self {
        Node::new(node.id(), NodeKind::Expression(node), node.span())
    }
}

impl<'a> From<&'a ExpressionKind> for Node<'a> {
    fn from(node: &'a ExpressionKind) -> Self {
        Node::new(node.id(), NodeKind::ExpressionKind(node), node.span())
    }
}

impl<'a> From<&'a MissingExpression> for Node<'a> {
    fn from(node: &'a MissingExpression) -> Self {
        Node::new(node.id(), NodeKind::MissingExpression(node), node.span())
    }
}

impl<'a> From<&'a StaticExpression> for Node<'a> {
    fn from(node: &'a StaticExpression) -> Self {
        Node::new(node.id(), NodeKind::StaticExpression(node), node.span())
    }
}

impl<'a> From<&'a SelfExpression> for Node<'a> {
    fn from(node: &'a SelfExpression) -> Self {
        Node::new(node.id(), NodeKind::SelfExpression(node), node.span())
    }
}

impl<'a> From<&'a ParentExpression> for Node<'a> {
    fn from(node: &'a ParentExpression) -> Self {
        Node::new(node.id(), NodeKind::ParentExpression(node), node.span())
    }
}

impl<'a> From<&'a CommentStatement> for Node<'a> {
    fn from(node: &'a CommentStatement) -> Self {
        Node::new(node.id(), NodeKind::CommentStatement(node), node.span())
    }
}

impl<'a> From<&'a InlineHtmlStatement> for Node<'a> {
    fn from(node: &'a InlineHtmlStatement) -> Self {
        Node::new(node.id(), NodeKind::InlineHtmlStatement(node), node.span())
    }
}

impl<'a> From<&'a FullOpeningTagStatement> for Node<'a> {
    fn from(node: &'a FullOpeningTagStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::FullOpeningTagStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ShortOpeningTagStatement> for Node<'a> {
    fn from(node: &'a ShortOpeningTagStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::ShortOpeningTagStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a EchoOpeningTagStatement> for Node<'a> {
    fn from(node: &'a EchoOpeningTagStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::EchoOpeningTagStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ClosingTagStatement> for Node<'a> {
    fn from(node: &'a ClosingTagStatement) -> Self {
        Node::new(node.id(), NodeKind::ClosingTagStatement(node), node.span())
    }
}

impl<'a> From<&'a ExpressionStatement> for Node<'a> {
    fn from(node: &'a ExpressionStatement) -> Self {
        Node::new(node.id(), NodeKind::ExpressionStatement(node), node.span())
    }
}

impl<'a> From<&'a GlobalStatement> for Node<'a> {
    fn from(node: &'a GlobalStatement) -> Self {
        Node::new(node.id(), NodeKind::GlobalStatement(node), node.span())
    }
}

impl<'a> From<&'a BlockStatement> for Node<'a> {
    fn from(node: &'a BlockStatement) -> Self {
        Node::new(node.id(), NodeKind::BlockStatement(node), node.span())
    }
}

impl<'a> From<&'a Case> for Node<'a> {
    fn from(node: &'a Case) -> Self {
        Node::new(node.id(), NodeKind::Case(node), node.span())
    }
}

impl<'a> From<&'a Use> for Node<'a> {
    fn from(node: &'a Use) -> Self {
        Node::new(node.id(), NodeKind::Use(node), node.span())
    }
}

impl<'a> From<&'a EvalExpression> for Node<'a> {
    fn from(node: &'a EvalExpression) -> Self {
        Node::new(node.id(), NodeKind::EvalExpression(node), node.span())
    }
}

impl<'a> From<&'a EmptyExpression> for Node<'a> {
    fn from(node: &'a EmptyExpression) -> Self {
        Node::new(node.id(), NodeKind::EmptyExpression(node), node.span())
    }
}

impl<'a> From<&'a DieExpression> for Node<'a> {
    fn from(node: &'a DieExpression) -> Self {
        Node::new(node.id(), NodeKind::DieExpression(node), node.span())
    }
}

impl<'a> From<&'a ExitExpression> for Node<'a> {
    fn from(node: &'a ExitExpression) -> Self {
        Node::new(node.id(), NodeKind::ExitExpression(node), node.span())
    }
}

impl<'a> From<&'a IssetExpression> for Node<'a> {
    fn from(node: &'a IssetExpression) -> Self {
        Node::new(node.id(), NodeKind::IssetExpression(node), node.span())
    }
}

impl<'a> From<&'a UnsetExpression> for Node<'a> {
    fn from(node: &'a UnsetExpression) -> Self {
        Node::new(node.id(), NodeKind::UnsetExpression(node), node.span())
    }
}

impl<'a> From<&'a PrintExpression> for Node<'a> {
    fn from(node: &'a PrintExpression) -> Self {
        Node::new(node.id(), NodeKind::PrintExpression(node), node.span())
    }
}

impl<'a> From<&'a ConcatExpression> for Node<'a> {
    fn from(node: &'a ConcatExpression) -> Self {
        Node::new(node.id(), NodeKind::ConcatExpression(node), node.span())
    }
}

impl<'a> From<&'a InstanceofExpression> for Node<'a> {
    fn from(node: &'a InstanceofExpression) -> Self {
        Node::new(node.id(), NodeKind::InstanceofExpression(node), node.span())
    }
}

impl<'a> From<&'a ReferenceExpression> for Node<'a> {
    fn from(node: &'a ReferenceExpression) -> Self {
        Node::new(node.id(), NodeKind::ReferenceExpression(node), node.span())
    }
}

impl<'a> From<&'a ParenthesizedExpression> for Node<'a> {
    fn from(node: &'a ParenthesizedExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ParenthesizedExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ErrorSuppressExpression> for Node<'a> {
    fn from(node: &'a ErrorSuppressExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ErrorSuppressExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a IncludeExpression> for Node<'a> {
    fn from(node: &'a IncludeExpression) -> Self {
        Node::new(node.id(), NodeKind::IncludeExpression(node), node.span())
    }
}

impl<'a> From<&'a IncludeOnceExpression> for Node<'a> {
    fn from(node: &'a IncludeOnceExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::IncludeOnceExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a RequireExpression> for Node<'a> {
    fn from(node: &'a RequireExpression) -> Self {
        Node::new(node.id(), NodeKind::RequireExpression(node), node.span())
    }
}

impl<'a> From<&'a RequireOnceExpression> for Node<'a> {
    fn from(node: &'a RequireOnceExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::RequireOnceExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a FunctionCallExpression> for Node<'a> {
    fn from(node: &'a FunctionCallExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::FunctionCallExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a FunctionClosureCreationExpression> for Node<'a> {
    fn from(node: &'a FunctionClosureCreationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::FunctionClosureCreationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a MethodCallExpression> for Node<'a> {
    fn from(node: &'a MethodCallExpression) -> Self {
        Node::new(node.id(), NodeKind::MethodCallExpression(node), node.span())
    }
}

impl<'a> From<&'a MethodClosureCreationExpression> for Node<'a> {
    fn from(node: &'a MethodClosureCreationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::MethodClosureCreationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a NullsafeMethodCallExpression> for Node<'a> {
    fn from(node: &'a NullsafeMethodCallExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::NullsafeMethodCallExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticMethodCallExpression> for Node<'a> {
    fn from(node: &'a StaticMethodCallExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::StaticMethodCallExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticVariableMethodCallExpression> for Node<'a> {
    fn from(node: &'a StaticVariableMethodCallExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::StaticVariableMethodCallExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticMethodClosureCreationExpression> for Node<'a> {
    fn from(node: &'a StaticMethodClosureCreationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::StaticMethodClosureCreationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticVariableMethodClosureCreationExpression> for Node<'a> {
    fn from(node: &'a StaticVariableMethodClosureCreationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::StaticVariableMethodClosureCreationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a PropertyFetchExpression> for Node<'a> {
    fn from(node: &'a PropertyFetchExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::PropertyFetchExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a NullsafePropertyFetchExpression> for Node<'a> {
    fn from(node: &'a NullsafePropertyFetchExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::NullsafePropertyFetchExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticPropertyFetchExpression> for Node<'a> {
    fn from(node: &'a StaticPropertyFetchExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::StaticPropertyFetchExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ConstantFetchExpression> for Node<'a> {
    fn from(node: &'a ConstantFetchExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ConstantFetchExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ArrayExpression> for Node<'a> {
    fn from(node: &'a ArrayExpression) -> Self {
        Node::new(node.id(), NodeKind::ArrayExpression(node), node.span())
    }
}

impl<'a> From<&'a ListExpression> for Node<'a> {
    fn from(node: &'a ListExpression) -> Self {
        Node::new(node.id(), NodeKind::ListExpression(node), node.span())
    }
}

impl<'a> From<&'a NewExpression> for Node<'a> {
    fn from(node: &'a NewExpression) -> Self {
        Node::new(node.id(), NodeKind::NewExpression(node), node.span())
    }
}

impl<'a> From<&'a InterpolatedStringExpression> for Node<'a> {
    fn from(node: &'a InterpolatedStringExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::InterpolatedStringExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a HeredocExpression> for Node<'a> {
    fn from(node: &'a HeredocExpression) -> Self {
        Node::new(node.id(), NodeKind::HeredocExpression(node), node.span())
    }
}

impl<'a> From<&'a NowdocExpression> for Node<'a> {
    fn from(node: &'a NowdocExpression) -> Self {
        Node::new(node.id(), NodeKind::NowdocExpression(node), node.span())
    }
}

impl<'a> From<&'a ShellExecExpression> for Node<'a> {
    fn from(node: &'a ShellExecExpression) -> Self {
        Node::new(node.id(), NodeKind::ShellExecExpression(node), node.span())
    }
}

impl<'a> From<&'a BoolExpression> for Node<'a> {
    fn from(node: &'a BoolExpression) -> Self {
        Node::new(node.id(), NodeKind::BoolExpression(node), node.span())
    }
}

impl<'a> From<&'a ArrayIndexExpression> for Node<'a> {
    fn from(node: &'a ArrayIndexExpression) -> Self {
        Node::new(node.id(), NodeKind::ArrayIndexExpression(node), node.span())
    }
}

impl<'a> From<&'a ShortTernaryExpression> for Node<'a> {
    fn from(node: &'a ShortTernaryExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ShortTernaryExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a TernaryExpression> for Node<'a> {
    fn from(node: &'a TernaryExpression) -> Self {
        Node::new(node.id(), NodeKind::TernaryExpression(node), node.span())
    }
}

impl<'a> From<&'a CoalesceExpression> for Node<'a> {
    fn from(node: &'a CoalesceExpression) -> Self {
        Node::new(node.id(), NodeKind::CoalesceExpression(node), node.span())
    }
}

impl<'a> From<&'a CloneExpression> for Node<'a> {
    fn from(node: &'a CloneExpression) -> Self {
        Node::new(node.id(), NodeKind::CloneExpression(node), node.span())
    }
}

impl<'a> From<&'a MatchExpression> for Node<'a> {
    fn from(node: &'a MatchExpression) -> Self {
        Node::new(node.id(), NodeKind::MatchExpression(node), node.span())
    }
}

impl<'a> From<&'a ThrowExpression> for Node<'a> {
    fn from(node: &'a ThrowExpression) -> Self {
        Node::new(node.id(), NodeKind::ThrowExpression(node), node.span())
    }
}

impl<'a> From<&'a YieldExpression> for Node<'a> {
    fn from(node: &'a YieldExpression) -> Self {
        Node::new(node.id(), NodeKind::YieldExpression(node), node.span())
    }
}

impl<'a> From<&'a YieldFromExpression> for Node<'a> {
    fn from(node: &'a YieldFromExpression) -> Self {
        Node::new(node.id(), NodeKind::YieldFromExpression(node), node.span())
    }
}

impl<'a> From<&'a CastExpression> for Node<'a> {
    fn from(node: &'a CastExpression) -> Self {
        Node::new(node.id(), NodeKind::CastExpression(node), node.span())
    }
}

impl<'a> From<&'a DefaultMatchArm> for Node<'a> {
    fn from(node: &'a DefaultMatchArm) -> Self {
        Node::new(node.id(), NodeKind::DefaultMatchArm(node), node.span())
    }
}

impl<'a> From<&'a MatchArm> for Node<'a> {
    fn from(node: &'a MatchArm) -> Self {
        Node::new(node.id(), NodeKind::MatchArm(node), node.span())
    }
}

impl<'a> From<&'a MagicConstantExpression> for Node<'a> {
    fn from(node: &'a MagicConstantExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::MagicConstantExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StringPart> for Node<'a> {
    fn from(node: &'a StringPart) -> Self {
        Node::new(node.id(), NodeKind::StringPart(node), node.span())
    }
}

impl<'a> From<&'a LiteralStringPart> for Node<'a> {
    fn from(node: &'a LiteralStringPart) -> Self {
        Node::new(node.id(), NodeKind::LiteralStringPart(node), node.span())
    }
}

impl<'a> From<&'a ExpressionStringPart> for Node<'a> {
    fn from(node: &'a ExpressionStringPart) -> Self {
        Node::new(node.id(), NodeKind::ExpressionStringPart(node), node.span())
    }
}

impl<'a> From<&'a ArrayItem> for Node<'a> {
    fn from(node: &'a ArrayItem) -> Self {
        Node::new(node.id(), NodeKind::ArrayItem(node), node.span())
    }
}

impl<'a> From<&'a ArrayItemValue> for Node<'a> {
    fn from(node: &'a ArrayItemValue) -> Self {
        Node::new(node.id(), NodeKind::ArrayItemValue(node), node.span())
    }
}

impl<'a> From<&'a ArrayItemReferencedValue> for Node<'a> {
    fn from(node: &'a ArrayItemReferencedValue) -> Self {
        Node::new(
            node.id(),
            NodeKind::ArrayItemReferencedValue(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ArrayItemSpreadValue> for Node<'a> {
    fn from(node: &'a ArrayItemSpreadValue) -> Self {
        Node::new(node.id(), NodeKind::ArrayItemSpreadValue(node), node.span())
    }
}

impl<'a> From<&'a ArrayItemKeyValue> for Node<'a> {
    fn from(node: &'a ArrayItemKeyValue) -> Self {
        Node::new(node.id(), NodeKind::ArrayItemKeyValue(node), node.span())
    }
}

impl<'a> From<&'a ArrayItemReferencedKeyValue> for Node<'a> {
    fn from(node: &'a ArrayItemReferencedKeyValue) -> Self {
        Node::new(
            node.id(),
            NodeKind::ArrayItemReferencedKeyValue(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ListEntry> for Node<'a> {
    fn from(node: &'a ListEntry) -> Self {
        Node::new(node.id(), NodeKind::ListEntry(node), node.span())
    }
}

impl<'a> From<&'a ListEntryValue> for Node<'a> {
    fn from(node: &'a ListEntryValue) -> Self {
        Node::new(node.id(), NodeKind::ListEntryValue(node), node.span())
    }
}

impl<'a> From<&'a ListEntryKeyValue> for Node<'a> {
    fn from(node: &'a ListEntryKeyValue) -> Self {
        Node::new(node.id(), NodeKind::ListEntryKeyValue(node), node.span())
    }
}

impl<'a> From<&'a PositionalArgument> for Node<'a> {
    fn from(node: &'a PositionalArgument) -> Self {
        Node::new(node.id(), NodeKind::PositionalArgument(node), node.span())
    }
}

impl<'a> From<&'a NamedArgument> for Node<'a> {
    fn from(node: &'a NamedArgument) -> Self {
        Node::new(node.id(), NodeKind::NamedArgument(node), node.span())
    }
}

impl<'a> From<&'a Argument> for Node<'a> {
    fn from(node: &'a Argument) -> Self {
        Node::new(node.id(), NodeKind::Argument(node), node.span())
    }
}

impl<'a> From<&'a ArgumentList> for Node<'a> {
    fn from(node: &'a ArgumentList) -> Self {
        Node::new(node.id(), NodeKind::ArgumentList(node), node.span())
    }
}

impl<'a> From<&'a SingleArgument> for Node<'a> {
    fn from(node: &'a SingleArgument) -> Self {
        Node::new(node.id(), NodeKind::SingleArgument(node), node.span())
    }
}

impl<'a> From<&'a ArgumentPlaceholder> for Node<'a> {
    fn from(node: &'a ArgumentPlaceholder) -> Self {
        Node::new(node.id(), NodeKind::ArgumentPlaceholder(node), node.span())
    }
}

impl<'a> From<&'a Attribute> for Node<'a> {
    fn from(node: &'a Attribute) -> Self {
        Node::new(node.id(), NodeKind::Attribute(node), node.span())
    }
}

impl<'a> From<&'a AttributeGroup> for Node<'a> {
    fn from(node: &'a AttributeGroup) -> Self {
        Node::new(node.id(), NodeKind::AttributeGroup(node), node.span())
    }
}

impl<'a> From<&'a ClassBody> for Node<'a> {
    fn from(node: &'a ClassBody) -> Self {
        Node::new(node.id(), NodeKind::ClassBody(node), node.span())
    }
}

impl<'a> From<&'a ClassStatement> for Node<'a> {
    fn from(node: &'a ClassStatement) -> Self {
        Node::new(node.id(), NodeKind::ClassStatement(node), node.span())
    }
}

impl<'a> From<&'a AnonymousClassBody> for Node<'a> {
    fn from(node: &'a AnonymousClassBody) -> Self {
        Node::new(node.id(), NodeKind::AnonymousClassBody(node), node.span())
    }
}

impl<'a> From<&'a AnonymousClassExpression> for Node<'a> {
    fn from(node: &'a AnonymousClassExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::AnonymousClassExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ClassExtends> for Node<'a> {
    fn from(node: &'a ClassExtends) -> Self {
        Node::new(node.id(), NodeKind::ClassExtends(node), node.span())
    }
}

impl<'a> From<&'a ClassImplements> for Node<'a> {
    fn from(node: &'a ClassImplements) -> Self {
        Node::new(node.id(), NodeKind::ClassImplements(node), node.span())
    }
}

impl<'a> From<&'a ClassishMember> for Node<'a> {
    fn from(node: &'a ClassishMember) -> Self {
        Node::new(node.id(), NodeKind::ClassishMember(node), node.span())
    }
}

impl<'a> From<&'a Method> for Node<'a> {
    fn from(node: &'a Method) -> Self {
        Node::new(node.id(), NodeKind::Method(node), node.span())
    }
}

impl<'a> From<&'a MethodBody> for Node<'a> {
    fn from(node: &'a MethodBody) -> Self {
        Node::new(node.id(), NodeKind::MethodBody(node), node.span())
    }
}

impl<'a> From<&'a MethodBodyKind> for Node<'a> {
    fn from(node: &'a MethodBodyKind) -> Self {
        Node::new(node.id(), NodeKind::MethodBodyKind(node), node.span())
    }
}

impl<'a> From<&'a MissingMethodBody> for Node<'a> {
    fn from(node: &'a MissingMethodBody) -> Self {
        Node::new(node.id(), NodeKind::MissingMethodBody(node), node.span())
    }
}

impl<'a> From<&'a AbstractMethodBody> for Node<'a> {
    fn from(node: &'a AbstractMethodBody) -> Self {
        Node::new(node.id(), NodeKind::AbstractMethodBody(node), node.span())
    }
}

impl<'a> From<&'a ConcreteMethodBody> for Node<'a> {
    fn from(node: &'a ConcreteMethodBody) -> Self {
        Node::new(node.id(), NodeKind::ConcreteMethodBody(node), node.span())
    }
}

impl<'a> From<&'a MethodParameterList> for Node<'a> {
    fn from(node: &'a MethodParameterList) -> Self {
        Node::new(node.id(), NodeKind::MethodParameterList(node), node.span())
    }
}

impl<'a> From<&'a MethodParameter> for Node<'a> {
    fn from(node: &'a MethodParameter) -> Self {
        Node::new(node.id(), NodeKind::MethodParameter(node), node.span())
    }
}

impl<'a> From<&'a MissingClassishMember> for Node<'a> {
    fn from(node: &'a MissingClassishMember) -> Self {
        Node::new(
            node.id(),
            NodeKind::MissingClassishMember(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ConstantEntry> for Node<'a> {
    fn from(node: &'a ConstantEntry) -> Self {
        Node::new(node.id(), NodeKind::ConstantEntry(node), node.span())
    }
}

impl<'a> From<&'a ClassishConstantEntry> for Node<'a> {
    fn from(node: &'a ClassishConstantEntry) -> Self {
        Node::new(
            node.id(),
            NodeKind::ClassishConstantEntry(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ConstantStatement> for Node<'a> {
    fn from(node: &'a ConstantStatement) -> Self {
        Node::new(node.id(), NodeKind::ConstantStatement(node), node.span())
    }
}

impl<'a> From<&'a ClassishConstant> for Node<'a> {
    fn from(node: &'a ClassishConstant) -> Self {
        Node::new(node.id(), NodeKind::ClassishConstant(node), node.span())
    }
}

impl<'a> From<&'a IfStatement> for Node<'a> {
    fn from(node: &'a IfStatement) -> Self {
        Node::new(node.id(), NodeKind::IfStatement(node), node.span())
    }
}

impl<'a> From<&'a IfStatementBody> for Node<'a> {
    fn from(node: &'a IfStatementBody) -> Self {
        Node::new(node.id(), NodeKind::IfStatementBody(node), node.span())
    }
}

impl<'a> From<&'a IfStatementBodyStatement> for Node<'a> {
    fn from(node: &'a IfStatementBodyStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::IfStatementBodyStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a IfStatementBodyBlock> for Node<'a> {
    fn from(node: &'a IfStatementBodyBlock) -> Self {
        Node::new(node.id(), NodeKind::IfStatementBodyBlock(node), node.span())
    }
}

impl<'a> From<&'a IfStatementElseIf> for Node<'a> {
    fn from(node: &'a IfStatementElseIf) -> Self {
        Node::new(node.id(), NodeKind::IfStatementElseIf(node), node.span())
    }
}

impl<'a> From<&'a IfStatementElse> for Node<'a> {
    fn from(node: &'a IfStatementElse) -> Self {
        Node::new(node.id(), NodeKind::IfStatementElse(node), node.span())
    }
}

impl<'a> From<&'a IfStatementElseIfBlock> for Node<'a> {
    fn from(node: &'a IfStatementElseIfBlock) -> Self {
        Node::new(
            node.id(),
            NodeKind::IfStatementElseIfBlock(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a IfStatementElseBlock> for Node<'a> {
    fn from(node: &'a IfStatementElseBlock) -> Self {
        Node::new(node.id(), NodeKind::IfStatementElseBlock(node), node.span())
    }
}

impl<'a> From<&'a DataType> for Node<'a> {
    fn from(node: &'a DataType) -> Self {
        Node::new(node.id(), NodeKind::DataType(node), node.span())
    }
}

impl<'a> From<&'a DeclareEntry> for Node<'a> {
    fn from(node: &'a DeclareEntry) -> Self {
        Node::new(node.id(), NodeKind::DeclareEntry(node), node.span())
    }
}

impl<'a> From<&'a DeclareEntryGroup> for Node<'a> {
    fn from(node: &'a DeclareEntryGroup) -> Self {
        Node::new(node.id(), NodeKind::DeclareEntryGroup(node), node.span())
    }
}

impl<'a> From<&'a DeclareBody> for Node<'a> {
    fn from(node: &'a DeclareBody) -> Self {
        Node::new(node.id(), NodeKind::DeclareBody(node), node.span())
    }
}

impl<'a> From<&'a DeclareBodyNoop> for Node<'a> {
    fn from(node: &'a DeclareBodyNoop) -> Self {
        Node::new(node.id(), NodeKind::DeclareBodyNoop(node), node.span())
    }
}

impl<'a> From<&'a DeclareBodyBraced> for Node<'a> {
    fn from(node: &'a DeclareBodyBraced) -> Self {
        Node::new(node.id(), NodeKind::DeclareBodyBraced(node), node.span())
    }
}

impl<'a> From<&'a DeclareBodyExpression> for Node<'a> {
    fn from(node: &'a DeclareBodyExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::DeclareBodyExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a DeclareBodyBlock> for Node<'a> {
    fn from(node: &'a DeclareBodyBlock) -> Self {
        Node::new(node.id(), NodeKind::DeclareBodyBlock(node), node.span())
    }
}

impl<'a> From<&'a DeclareStatement> for Node<'a> {
    fn from(node: &'a DeclareStatement) -> Self {
        Node::new(node.id(), NodeKind::DeclareStatement(node), node.span())
    }
}

impl<'a> From<&'a UnitEnumCase> for Node<'a> {
    fn from(node: &'a UnitEnumCase) -> Self {
        Node::new(node.id(), NodeKind::UnitEnumCase(node), node.span())
    }
}

impl<'a> From<&'a UnitEnumMember> for Node<'a> {
    fn from(node: &'a UnitEnumMember) -> Self {
        Node::new(node.id(), NodeKind::UnitEnumMember(node), node.span())
    }
}

impl<'a> From<&'a UnitEnumBody> for Node<'a> {
    fn from(node: &'a UnitEnumBody) -> Self {
        Node::new(node.id(), NodeKind::UnitEnumBody(node), node.span())
    }
}

impl<'a> From<&'a UnitEnumStatement> for Node<'a> {
    fn from(node: &'a UnitEnumStatement) -> Self {
        Node::new(node.id(), NodeKind::UnitEnumStatement(node), node.span())
    }
}

impl<'a> From<&'a BackedEnumCase> for Node<'a> {
    fn from(node: &'a BackedEnumCase) -> Self {
        Node::new(node.id(), NodeKind::BackedEnumCase(node), node.span())
    }
}

impl<'a> From<&'a BackedEnumMember> for Node<'a> {
    fn from(node: &'a BackedEnumMember) -> Self {
        Node::new(node.id(), NodeKind::BackedEnumMember(node), node.span())
    }
}

impl<'a> From<&'a BackedEnumBody> for Node<'a> {
    fn from(node: &'a BackedEnumBody) -> Self {
        Node::new(node.id(), NodeKind::BackedEnumBody(node), node.span())
    }
}

impl<'a> From<&'a BackedEnumStatement> for Node<'a> {
    fn from(node: &'a BackedEnumStatement) -> Self {
        Node::new(node.id(), NodeKind::BackedEnumStatement(node), node.span())
    }
}

impl<'a> From<&'a ReturnType> for Node<'a> {
    fn from(node: &'a ReturnType) -> Self {
        Node::new(node.id(), NodeKind::ReturnType(node), node.span())
    }
}

impl<'a> From<&'a FunctionParameter> for Node<'a> {
    fn from(node: &'a FunctionParameter) -> Self {
        Node::new(node.id(), NodeKind::FunctionParameter(node), node.span())
    }
}

impl<'a> From<&'a FunctionParameterList> for Node<'a> {
    fn from(node: &'a FunctionParameterList) -> Self {
        Node::new(
            node.id(),
            NodeKind::FunctionParameterList(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a FunctionBody> for Node<'a> {
    fn from(node: &'a FunctionBody) -> Self {
        Node::new(node.id(), NodeKind::FunctionBody(node), node.span())
    }
}

impl<'a> From<&'a FunctionStatement> for Node<'a> {
    fn from(node: &'a FunctionStatement) -> Self {
        Node::new(node.id(), NodeKind::FunctionStatement(node), node.span())
    }
}

impl<'a> From<&'a ClosureUseVariable> for Node<'a> {
    fn from(node: &'a ClosureUseVariable) -> Self {
        Node::new(node.id(), NodeKind::ClosureUseVariable(node), node.span())
    }
}

impl<'a> From<&'a ClosureUse> for Node<'a> {
    fn from(node: &'a ClosureUse) -> Self {
        Node::new(node.id(), NodeKind::ClosureUse(node), node.span())
    }
}

impl<'a> From<&'a ClosureExpression> for Node<'a> {
    fn from(node: &'a ClosureExpression) -> Self {
        Node::new(node.id(), NodeKind::ClosureExpression(node), node.span())
    }
}

impl<'a> From<&'a ArrowFunctionExpression> for Node<'a> {
    fn from(node: &'a ArrowFunctionExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ArrowFunctionExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a LabelStatement> for Node<'a> {
    fn from(node: &'a LabelStatement) -> Self {
        Node::new(node.id(), NodeKind::LabelStatement(node), node.span())
    }
}

impl<'a> From<&'a GotoStatement> for Node<'a> {
    fn from(node: &'a GotoStatement) -> Self {
        Node::new(node.id(), NodeKind::GotoStatement(node), node.span())
    }
}

impl<'a> From<&'a Identifier> for Node<'a> {
    fn from(node: &'a Identifier) -> Self {
        Node::new(node.id(), NodeKind::Identifier(node), node.span())
    }
}

impl<'a> From<&'a SimpleIdentifier> for Node<'a> {
    fn from(node: &'a SimpleIdentifier) -> Self {
        Node::new(node.id(), NodeKind::SimpleIdentifier(node), node.span())
    }
}

impl<'a> From<&'a DynamicIdentifier> for Node<'a> {
    fn from(node: &'a DynamicIdentifier) -> Self {
        Node::new(node.id(), NodeKind::DynamicIdentifier(node), node.span())
    }
}

impl<'a> From<&'a InterfaceExtends> for Node<'a> {
    fn from(node: &'a InterfaceExtends) -> Self {
        Node::new(node.id(), NodeKind::InterfaceExtends(node), node.span())
    }
}

impl<'a> From<&'a InterfaceBody> for Node<'a> {
    fn from(node: &'a InterfaceBody) -> Self {
        Node::new(node.id(), NodeKind::InterfaceBody(node), node.span())
    }
}

impl<'a> From<&'a InterfaceStatement> for Node<'a> {
    fn from(node: &'a InterfaceStatement) -> Self {
        Node::new(node.id(), NodeKind::InterfaceStatement(node), node.span())
    }
}

impl<'a> From<&'a Literal> for Node<'a> {
    fn from(node: &'a Literal) -> Self {
        Node::new(node.id(), NodeKind::Literal(node), node.span())
    }
}

impl<'a> From<&'a ForeachStatement> for Node<'a> {
    fn from(node: &'a ForeachStatement) -> Self {
        Node::new(node.id(), NodeKind::ForeachStatement(node), node.span())
    }
}

impl<'a> From<&'a ForeachStatementIterator> for Node<'a> {
    fn from(node: &'a ForeachStatementIterator) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForeachStatementIterator(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ForeachStatementIteratorValue> for Node<'a> {
    fn from(node: &'a ForeachStatementIteratorValue) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForeachStatementIteratorValue(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ForeachStatementIteratorKeyAndValue> for Node<'a> {
    fn from(node: &'a ForeachStatementIteratorKeyAndValue) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForeachStatementIteratorKeyAndValue(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ForeachStatementBody> for Node<'a> {
    fn from(node: &'a ForeachStatementBody) -> Self {
        Node::new(node.id(), NodeKind::ForeachStatementBody(node), node.span())
    }
}

impl<'a> From<&'a ForeachStatementBodyStatement> for Node<'a> {
    fn from(node: &'a ForeachStatementBodyStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForeachStatementBodyStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ForeachStatementBodyBlock> for Node<'a> {
    fn from(node: &'a ForeachStatementBodyBlock) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForeachStatementBodyBlock(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ForStatement> for Node<'a> {
    fn from(node: &'a ForStatement) -> Self {
        Node::new(node.id(), NodeKind::ForStatement(node), node.span())
    }
}

impl<'a> From<&'a ForStatementIterator> for Node<'a> {
    fn from(node: &'a ForStatementIterator) -> Self {
        Node::new(node.id(), NodeKind::ForStatementIterator(node), node.span())
    }
}

impl<'a> From<&'a ForStatementBody> for Node<'a> {
    fn from(node: &'a ForStatementBody) -> Self {
        Node::new(node.id(), NodeKind::ForStatementBody(node), node.span())
    }
}

impl<'a> From<&'a ForStatementBodyStatement> for Node<'a> {
    fn from(node: &'a ForStatementBodyStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForStatementBodyStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ForStatementBodyBlock> for Node<'a> {
    fn from(node: &'a ForStatementBodyBlock) -> Self {
        Node::new(
            node.id(),
            NodeKind::ForStatementBodyBlock(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a DoWhileStatement> for Node<'a> {
    fn from(node: &'a DoWhileStatement) -> Self {
        Node::new(node.id(), NodeKind::DoWhileStatement(node), node.span())
    }
}

impl<'a> From<&'a WhileStatement> for Node<'a> {
    fn from(node: &'a WhileStatement) -> Self {
        Node::new(node.id(), NodeKind::WhileStatement(node), node.span())
    }
}

impl<'a> From<&'a WhileStatementBody> for Node<'a> {
    fn from(node: &'a WhileStatementBody) -> Self {
        Node::new(node.id(), NodeKind::WhileStatementBody(node), node.span())
    }
}

impl<'a> From<&'a WhileStatementBodyStatement> for Node<'a> {
    fn from(node: &'a WhileStatementBodyStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::WhileStatementBodyStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a WhileStatementBodyBlock> for Node<'a> {
    fn from(node: &'a WhileStatementBodyBlock) -> Self {
        Node::new(
            node.id(),
            NodeKind::WhileStatementBodyBlock(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a Level> for Node<'a> {
    fn from(node: &'a Level) -> Self {
        Node::new(node.id(), NodeKind::Level(node), node.span())
    }
}

impl<'a> From<&'a LiteralLevel> for Node<'a> {
    fn from(node: &'a LiteralLevel) -> Self {
        Node::new(node.id(), NodeKind::LiteralLevel(node), node.span())
    }
}

impl<'a> From<&'a ParenthesizedLevel> for Node<'a> {
    fn from(node: &'a ParenthesizedLevel) -> Self {
        Node::new(node.id(), NodeKind::ParenthesizedLevel(node), node.span())
    }
}

impl<'a> From<&'a BreakStatement> for Node<'a> {
    fn from(node: &'a BreakStatement) -> Self {
        Node::new(node.id(), NodeKind::BreakStatement(node), node.span())
    }
}

impl<'a> From<&'a ContinueStatement> for Node<'a> {
    fn from(node: &'a ContinueStatement) -> Self {
        Node::new(node.id(), NodeKind::ContinueStatement(node), node.span())
    }
}

impl<'a> From<&'a PromotedPropertyModifierGroup> for Node<'a> {
    fn from(node: &'a PromotedPropertyModifierGroup) -> Self {
        Node::new(
            node.id(),
            NodeKind::PromotedPropertyModifierGroup(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a PropertyModifierGroup> for Node<'a> {
    fn from(node: &'a PropertyModifierGroup) -> Self {
        Node::new(
            node.id(),
            NodeKind::PropertyModifierGroup(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a MethodModifierGroup> for Node<'a> {
    fn from(node: &'a MethodModifierGroup) -> Self {
        Node::new(node.id(), NodeKind::MethodModifierGroup(node), node.span())
    }
}

impl<'a> From<&'a ClassModifierGroup> for Node<'a> {
    fn from(node: &'a ClassModifierGroup) -> Self {
        Node::new(node.id(), NodeKind::ClassModifierGroup(node), node.span())
    }
}

impl<'a> From<&'a ConstantModifierGroup> for Node<'a> {
    fn from(node: &'a ConstantModifierGroup) -> Self {
        Node::new(
            node.id(),
            NodeKind::ConstantModifierGroup(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a UnbracedNamespace> for Node<'a> {
    fn from(node: &'a UnbracedNamespace) -> Self {
        Node::new(node.id(), NodeKind::UnbracedNamespace(node), node.span())
    }
}

impl<'a> From<&'a BracedNamespace> for Node<'a> {
    fn from(node: &'a BracedNamespace) -> Self {
        Node::new(node.id(), NodeKind::BracedNamespace(node), node.span())
    }
}

impl<'a> From<&'a BracedNamespaceBody> for Node<'a> {
    fn from(node: &'a BracedNamespaceBody) -> Self {
        Node::new(node.id(), NodeKind::BracedNamespaceBody(node), node.span())
    }
}

impl<'a> From<&'a NamespaceStatement> for Node<'a> {
    fn from(node: &'a NamespaceStatement) -> Self {
        Node::new(node.id(), NodeKind::NamespaceStatement(node), node.span())
    }
}

impl<'a> From<&'a ArithmeticOperationExpression> for Node<'a> {
    fn from(node: &'a ArithmeticOperationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ArithmeticOperationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ArithmeticOperationKind> for Node<'a> {
    fn from(node: &'a ArithmeticOperationKind) -> Self {
        Node::new(
            node.id(),
            NodeKind::ArithmeticOperationKind(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a AssignmentOperationExpression> for Node<'a> {
    fn from(node: &'a AssignmentOperationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::AssignmentOperationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a BitwiseOperationExpression> for Node<'a> {
    fn from(node: &'a BitwiseOperationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::BitwiseOperationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a BitwiseOperationKind> for Node<'a> {
    fn from(node: &'a BitwiseOperationKind) -> Self {
        Node::new(node.id(), NodeKind::BitwiseOperationKind(node), node.span())
    }
}

impl<'a> From<&'a ComparisonOperationExpression> for Node<'a> {
    fn from(node: &'a ComparisonOperationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ComparisonOperationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ComparisonOperationKind> for Node<'a> {
    fn from(node: &'a ComparisonOperationKind) -> Self {
        Node::new(
            node.id(),
            NodeKind::ComparisonOperationKind(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a LogicalOperationExpression> for Node<'a> {
    fn from(node: &'a LogicalOperationExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::LogicalOperationExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a LogicalOperationKind> for Node<'a> {
    fn from(node: &'a LogicalOperationKind) -> Self {
        Node::new(node.id(), NodeKind::LogicalOperationKind(node), node.span())
    }
}

impl<'a> From<&'a Name> for Node<'a> {
    fn from(node: &'a Name) -> Self {
        Node::new(node.id(), NodeKind::Name(node), node.span())
    }
}

impl<'a> From<&'a Property> for Node<'a> {
    fn from(node: &'a Property) -> Self {
        Node::new(node.id(), NodeKind::Property(node), node.span())
    }
}

impl<'a> From<&'a SimpleProperty> for Node<'a> {
    fn from(node: &'a SimpleProperty) -> Self {
        Node::new(node.id(), NodeKind::SimpleProperty(node), node.span())
    }
}

impl<'a> From<&'a HookedProperty> for Node<'a> {
    fn from(node: &'a HookedProperty) -> Self {
        Node::new(node.id(), NodeKind::HookedProperty(node), node.span())
    }
}

impl<'a> From<&'a PropertyHookList> for Node<'a> {
    fn from(node: &'a PropertyHookList) -> Self {
        Node::new(node.id(), NodeKind::PropertyHookList(node), node.span())
    }
}

impl<'a> From<&'a PropertyHook> for Node<'a> {
    fn from(node: &'a PropertyHook) -> Self {
        Node::new(node.id(), NodeKind::PropertyHook(node), node.span())
    }
}

impl<'a> From<&'a PropertyHookBody> for Node<'a> {
    fn from(node: &'a PropertyHookBody) -> Self {
        Node::new(node.id(), NodeKind::PropertyHookBody(node), node.span())
    }
}

impl<'a> From<&'a ConcretePropertyHookBody> for Node<'a> {
    fn from(node: &'a ConcretePropertyHookBody) -> Self {
        Node::new(
            node.id(),
            NodeKind::ConcretePropertyHookBody(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ConcretePropertyHookBodyBlock> for Node<'a> {
    fn from(node: &'a ConcretePropertyHookBodyBlock) -> Self {
        Node::new(
            node.id(),
            NodeKind::ConcretePropertyHookBodyBlock(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a ConcretePropertyHookBodyExpression> for Node<'a> {
    fn from(node: &'a ConcretePropertyHookBodyExpression) -> Self {
        Node::new(
            node.id(),
            NodeKind::ConcretePropertyHookBodyExpression(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a PropertyEntry> for Node<'a> {
    fn from(node: &'a PropertyEntry) -> Self {
        Node::new(node.id(), NodeKind::PropertyEntry(node), node.span())
    }
}

impl<'a> From<&'a PropertyEntryKind> for Node<'a> {
    fn from(node: &'a PropertyEntryKind) -> Self {
        Node::new(node.id(), NodeKind::PropertyEntryKind(node), node.span())
    }
}

impl<'a> From<&'a UninitializedPropertyEntry> for Node<'a> {
    fn from(node: &'a UninitializedPropertyEntry) -> Self {
        Node::new(
            node.id(),
            NodeKind::UninitializedPropertyEntry(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a InitializedPropertyEntry> for Node<'a> {
    fn from(node: &'a InitializedPropertyEntry) -> Self {
        Node::new(
            node.id(),
            NodeKind::InitializedPropertyEntry(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a TraitBody> for Node<'a> {
    fn from(node: &'a TraitBody) -> Self {
        Node::new(node.id(), NodeKind::TraitBody(node), node.span())
    }
}

impl<'a> From<&'a TraitStatement> for Node<'a> {
    fn from(node: &'a TraitStatement) -> Self {
        Node::new(node.id(), NodeKind::TraitStatement(node), node.span())
    }
}

impl<'a> From<&'a TraitUsage> for Node<'a> {
    fn from(node: &'a TraitUsage) -> Self {
        Node::new(node.id(), NodeKind::TraitUsage(node), node.span())
    }
}

impl<'a> From<&'a TraitUsageAdaptation> for Node<'a> {
    fn from(node: &'a TraitUsageAdaptation) -> Self {
        Node::new(node.id(), NodeKind::TraitUsageAdaptation(node), node.span())
    }
}

impl<'a> From<&'a TraitUsageAdaptationKind> for Node<'a> {
    fn from(node: &'a TraitUsageAdaptationKind) -> Self {
        Node::new(
            node.id(),
            NodeKind::TraitUsageAdaptationKind(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a TraitUsageAdaptationAlias> for Node<'a> {
    fn from(node: &'a TraitUsageAdaptationAlias) -> Self {
        Node::new(
            node.id(),
            NodeKind::TraitUsageAdaptationAlias(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a TraitUsageAdaptationVisibility> for Node<'a> {
    fn from(node: &'a TraitUsageAdaptationVisibility) -> Self {
        Node::new(
            node.id(),
            NodeKind::TraitUsageAdaptationVisibility(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a TraitUsageAdaptationPrecedence> for Node<'a> {
    fn from(node: &'a TraitUsageAdaptationPrecedence) -> Self {
        Node::new(
            node.id(),
            NodeKind::TraitUsageAdaptationPrecedence(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a CatchType> for Node<'a> {
    fn from(node: &'a CatchType) -> Self {
        Node::new(node.id(), NodeKind::CatchType(node), node.span())
    }
}

impl<'a> From<&'a CatchTypeKind> for Node<'a> {
    fn from(node: &'a CatchTypeKind) -> Self {
        Node::new(node.id(), NodeKind::CatchTypeKind(node), node.span())
    }
}

impl<'a> From<&'a CatchTypeKindIdentifier> for Node<'a> {
    fn from(node: &'a CatchTypeKindIdentifier) -> Self {
        Node::new(
            node.id(),
            NodeKind::CatchTypeKindIdentifier(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a CatchTypeKindUnion> for Node<'a> {
    fn from(node: &'a CatchTypeKindUnion) -> Self {
        Node::new(node.id(), NodeKind::CatchTypeKindUnion(node), node.span())
    }
}

impl<'a> From<&'a TryStatement> for Node<'a> {
    fn from(node: &'a TryStatement) -> Self {
        Node::new(node.id(), NodeKind::TryStatement(node), node.span())
    }
}

impl<'a> From<&'a CatchBlock> for Node<'a> {
    fn from(node: &'a CatchBlock) -> Self {
        Node::new(node.id(), NodeKind::CatchBlock(node), node.span())
    }
}

impl<'a> From<&'a FinallyBlock> for Node<'a> {
    fn from(node: &'a FinallyBlock) -> Self {
        Node::new(node.id(), NodeKind::FinallyBlock(node), node.span())
    }
}

impl<'a> From<&'a Variable> for Node<'a> {
    fn from(node: &'a Variable) -> Self {
        Node::new(node.id(), NodeKind::Variable(node), node.span())
    }
}

impl<'a> From<&'a SimpleVariable> for Node<'a> {
    fn from(node: &'a SimpleVariable) -> Self {
        Node::new(node.id(), NodeKind::SimpleVariable(node), node.span())
    }
}

impl<'a> From<&'a VariableVariable> for Node<'a> {
    fn from(node: &'a VariableVariable) -> Self {
        Node::new(node.id(), NodeKind::VariableVariable(node), node.span())
    }
}

impl<'a> From<&'a BracedVariableVariable> for Node<'a> {
    fn from(node: &'a BracedVariableVariable) -> Self {
        Node::new(
            node.id(),
            NodeKind::BracedVariableVariable(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticStatement> for Node<'a> {
    fn from(node: &'a StaticStatement) -> Self {
        Node::new(node.id(), NodeKind::StaticStatement(node), node.span())
    }
}

impl<'a> From<&'a SwitchStatement> for Node<'a> {
    fn from(node: &'a SwitchStatement) -> Self {
        Node::new(node.id(), NodeKind::SwitchStatement(node), node.span())
    }
}

impl<'a> From<&'a EchoStatement> for Node<'a> {
    fn from(node: &'a EchoStatement) -> Self {
        Node::new(node.id(), NodeKind::EchoStatement(node), node.span())
    }
}

impl<'a> From<&'a ReturnStatement> for Node<'a> {
    fn from(node: &'a ReturnStatement) -> Self {
        Node::new(node.id(), NodeKind::ReturnStatement(node), node.span())
    }
}

impl<'a> From<&'a UseStatement> for Node<'a> {
    fn from(node: &'a UseStatement) -> Self {
        Node::new(node.id(), NodeKind::UseStatement(node), node.span())
    }
}

impl<'a> From<&'a GroupUseStatement> for Node<'a> {
    fn from(node: &'a GroupUseStatement) -> Self {
        Node::new(node.id(), NodeKind::GroupUseStatement(node), node.span())
    }
}

impl<'a> From<&'a HaltCompilerStatement> for Node<'a> {
    fn from(node: &'a HaltCompilerStatement) -> Self {
        Node::new(
            node.id(),
            NodeKind::HaltCompilerStatement(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a StaticVar> for Node<'a> {
    fn from(node: &'a StaticVar) -> Self {
        Node::new(node.id(), NodeKind::StaticVar(node), node.span())
    }
}

impl<'a> From<&'a Comment> for Node<'a> {
    fn from(node: &'a Comment) -> Self {
        Node::new(node.id(), NodeKind::Comment(node), node.span())
    }
}

impl<'a> From<&'a CommentKind> for Node<'a> {
    fn from(node: &'a CommentKind) -> Self {
        Node::new(node.id(), NodeKind::CommentKind(node), node.span())
    }
}

impl<'a> From<&'a SingleLineComment> for Node<'a> {
    fn from(node: &'a SingleLineComment) -> Self {
        Node::new(node.id(), NodeKind::SingleLineComment(node), node.span())
    }
}

impl<'a> From<&'a MultiLineComment> for Node<'a> {
    fn from(node: &'a MultiLineComment) -> Self {
        Node::new(node.id(), NodeKind::MultiLineComment(node), node.span())
    }
}

impl<'a> From<&'a HashMarkComment> for Node<'a> {
    fn from(node: &'a HashMarkComment) -> Self {
        Node::new(node.id(), NodeKind::HashMarkComment(node), node.span())
    }
}

impl<'a> From<&'a DocBlockComment> for Node<'a> {
    fn from(node: &'a DocBlockComment) -> Self {
        Node::new(node.id(), NodeKind::DocBlockComment(node), node.span())
    }
}

impl<'a> From<&'a DocBlock> for Node<'a> {
    fn from(node: &'a DocBlock) -> Self {
        Node::new(node.id(), NodeKind::DocBlock(node), node.span())
    }
}

impl<'a> From<&'a DocBlockNode> for Node<'a> {
    fn from(node: &'a DocBlockNode) -> Self {
        Node::new(node.id(), NodeKind::DocBlockNode(node), node.span())
    }
}

impl<'a> From<&'a DocBlockTextNode> for Node<'a> {
    fn from(node: &'a DocBlockTextNode) -> Self {
        Node::new(node.id(), NodeKind::DocBlockTextNode(node), node.span())
    }
}

impl<'a> From<&'a DocBlockTagNode> for Node<'a> {
    fn from(node: &'a DocBlockTagNode) -> Self {
        Node::new(node.id(), NodeKind::DocBlockTagNode(node), node.span())
    }
}

impl<'a> From<&'a DocBlockTag> for Node<'a> {
    fn from(node: &'a DocBlockTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockParamClosureThisTag> for Node<'a> {
    fn from(node: &'a DocBlockParamClosureThisTag) -> Self {
        Node::new(
            node.id(),
            NodeKind::DocBlockParamClosureThisTag(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a DocBlockParamTag> for Node<'a> {
    fn from(node: &'a DocBlockParamTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockParamTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockReturnTag> for Node<'a> {
    fn from(node: &'a DocBlockReturnTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockReturnTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockThrowsTag> for Node<'a> {
    fn from(node: &'a DocBlockThrowsTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockThrowsTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockVarTag> for Node<'a> {
    fn from(node: &'a DocBlockVarTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockVarTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockPropertyTag> for Node<'a> {
    fn from(node: &'a DocBlockPropertyTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockPropertyTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockMethodTag> for Node<'a> {
    fn from(node: &'a DocBlockMethodTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockMethodTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockTemplateTagValue> for Node<'a> {
    fn from(node: &'a DocBlockTemplateTagValue) -> Self {
        Node::new(
            node.id(),
            NodeKind::DocBlockTemplateTagValue(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a DocBlockTemplateTag> for Node<'a> {
    fn from(node: &'a DocBlockTemplateTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockTemplateTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockExtendsTag> for Node<'a> {
    fn from(node: &'a DocBlockExtendsTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockExtendsTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockImplementsTag> for Node<'a> {
    fn from(node: &'a DocBlockImplementsTag) -> Self {
        Node::new(
            node.id(),
            NodeKind::DocBlockImplementsTag(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a DocBlockUsesTag> for Node<'a> {
    fn from(node: &'a DocBlockUsesTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockUsesTag(node), node.span())
    }
}

impl<'a> From<&'a DocBlockDeprecatedTag> for Node<'a> {
    fn from(node: &'a DocBlockDeprecatedTag) -> Self {
        Node::new(
            node.id(),
            NodeKind::DocBlockDeprecatedTag(node),
            node.span(),
        )
    }
}

impl<'a> From<&'a DocBlockGenericTag> for Node<'a> {
    fn from(node: &'a DocBlockGenericTag) -> Self {
        Node::new(node.id(), NodeKind::DocBlockGenericTag(node), node.span())
    }
}

impl<'a> From<&'a CommentGroup> for Node<'a> {
    fn from(node: &'a CommentGroup) -> Self {
        Node::new(node.id(), NodeKind::CommentGroup(node), node.span())
    }
}
