# This file contains the AST definition.
# Each node in the AST is defined as an object in this file.
#
# The keys of the object are the field names of the node.
# If the object has an `as` field with a value of Enum, it is an `enum`.
#
# There are some "special" field names used to modify the output.
# as: used to declare the type of the node.
# derive: used to add additional traits to the node.
#
# AST nodes should not be modified directly. All changes should be made in this file.

NodeId: u32
Block: Vec<Statement>

Statement:
  children: [kind]
  kind: StatementKind
  span: Span
  comments: CommentGroup

StatementKind:
  as: Enum
  children: [self]
  FullOpeningTag: FullOpeningTagStatement
  ShortOpeningTag: ShortOpeningTagStatement
  EchoOpeningTag: EchoOpeningTagStatement
  ClosingTag: ClosingTagStatement
  InlineHtml: InlineHtmlStatement
  Label: LabelStatement
  Goto: GotoStatement
  HaltCompiler: HaltCompilerStatement
  Static: StaticStatement
  DoWhile: DoWhileStatement
  While: WhileStatement
  For: ForStatement
  Foreach: ForeachStatement
  Break: BreakStatement
  Continue: ContinueStatement
  Constant: ConstantStatement
  Function: FunctionStatement
  Class: ClassStatement
  Trait: TraitStatement
  Interface: InterfaceStatement
  If: IfStatement
  Switch: SwitchStatement
  Echo: EchoStatement
  Expression: ExpressionStatement
  Return: ReturnStatement
  Namespace: NamespaceStatement
  Use: UseStatement
  GroupUse: GroupUseStatement
  Comment: CommentStatement
  Try: TryStatement
  UnitEnum: UnitEnumStatement
  BackedEnum: BackedEnumStatement
  Block: BlockStatement
  Global: GlobalStatement
  Declare: DeclareStatement
  Noop: Span

Expression:
  children: [kind]
  kind: ExpressionKind
  span: Span
  comments: CommentGroup

ExpressionKind:
  as: Enum
  children: [self]
  Missing: MissingExpression
  Eval: EvalExpression
  Empty: EmptyExpression
  Die: DieExpression
  Exit: ExitExpression
  Isset: IssetExpression
  Unset: UnsetExpression
  Print: PrintExpression
  Literal: Literal
  ArithmeticOperation: ArithmeticOperationExpression
  AssignmentOperation: AssignmentOperationExpression
  BitwiseOperation: BitwiseOperationExpression
  ComparisonOperation: ComparisonOperationExpression
  LogicalOperation: LogicalOperationExpression
  Concat: ConcatExpression
  Instanceof: InstanceofExpression
  Reference: ReferenceExpression
  Parenthesized: ParenthesizedExpression
  ErrorSuppress: ErrorSuppressExpression
  Identifier: Identifier
  Variable: Variable
  Include: IncludeExpression
  IncludeOnce: IncludeOnceExpression
  Require: RequireExpression
  RequireOnce: RequireOnceExpression
  FunctionCall: FunctionCallExpression
  FunctionClosureCreation: FunctionClosureCreationExpression
  MethodCall: MethodCallExpression
  MethodClosureCreation: MethodClosureCreationExpression
  NullsafeMethodCall: NullsafeMethodCallExpression
  StaticMethodCall: StaticMethodCallExpression
  StaticVariableMethodCall: StaticVariableMethodCallExpression
  StaticMethodClosureCreation: StaticMethodClosureCreationExpression
  StaticVariableMethodClosureCreation: StaticVariableMethodClosureCreationExpression
  PropertyFetch: PropertyFetchExpression
  NullsafePropertyFetch: NullsafePropertyFetchExpression
  StaticPropertyFetch: StaticPropertyFetchExpression
  ConstantFetch: ConstantFetchExpression
  Static: StaticExpression
  Self_: SelfExpression
  Parent: ParentExpression
  ShortArray: ShortArrayExpression
  Array: ArrayExpression
  List: ListExpression
  Closure: ClosureExpression
  ArrowFunction: ArrowFunctionExpression
  New: NewExpression
  InterpolatedString: InterpolatedStringExpression
  Heredoc: HeredocExpression
  Nowdoc: NowdocExpression
  ShellExec: ShellExecExpression
  AnonymousClass: AnonymousClassExpression
  Bool: BoolExpression
  ArrayIndex: ArrayIndexExpression
  "Null": Span
  MagicConstant: MagicConstantExpression
  ShortTernary: ShortTernaryExpression
  Ternary: TernaryExpression
  Coalesce: CoalesceExpression
  Clone: CloneExpression
  Match: MatchExpression
  Throw: ThrowExpression
  Yield: YieldExpression
  YieldFrom: YieldFromExpression
  Cast: CastExpression
  Name: Name
  Noop: Span

MissingExpression:
  span: Span

StaticExpression:
  span: Span

SelfExpression:
  span: Span

ParentExpression:
  span: Span

CommentStatement:
  span: Span
  comment: Comment

InlineHtmlStatement:
  span: Span
  html: Token

FullOpeningTagStatement:
  span: Span

ShortOpeningTagStatement:
  span: Span

EchoOpeningTagStatement:
  span: Span

ClosingTagStatement:
  span: Span

ExpressionStatement:
  children: [expression]
  span: Span
  expression: Expression
  ending: Ending

GlobalStatement:
  children: [variables]
  span: Span
  global: Span
  variables: Vec<Variable>
  semicolon: Span

BlockStatement:
  children: [statements]
  span: Span
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

CastKind:
  node: false
  as: Enum
  Int: Span
  Bool: Span
  Float: Span
  String: Span
  Array: Span
  Object: Span
  Unset: Span

Case:
  children: [condition?, body]
  span: Span
  condition: Option<Expression>
  body: Block

Use:
  children: [name, alias?]
  span: Span
  name: Name
  alias: Option<SimpleIdentifier>
  kind: Option<UseKind>

UseKind:
  node: false
  as: Enum
  derive: Hash, Copy
  Normal: ''
  Function: ''
  Const: ''

EvalExpression:
  children: [argument]
  span: Span
  eval: Span
  argument: Box<SingleArgument>

EmptyExpression:
  children: [argument]
  span: Span
  empty: Span
  argument: Box<SingleArgument>

DieExpression:
  children: [argument?]
  span: Span
  die: Span
  argument: Option<Box<SingleArgument>>

ExitExpression:
  children: [argument?]
  span: Span
  exit: Span
  argument: Option<Box<SingleArgument>>

IssetExpression:
  children: [arguments]
  span: Span
  isset: Span
  arguments: ArgumentList

UnsetExpression:
  children: [arguments]
  span: Span
  unset: Span
  arguments: ArgumentList

PrintExpression:
  children: [value?, argument?]
  span: Span
  print: Span
  value: Option<Box<Expression>>
  argument: Option<Box<SingleArgument>>

ConcatExpression:
  children: [left, right]
  span: Span
  left: Box<Expression>
  dot: Span
  right: Box<Expression>

InstanceofExpression:
  children: [left, right]
  span: Span
  left: Box<Expression>
  instanceof: Span
  right: Box<Expression>

ReferenceExpression:
  children: [right]
  span: Span
  ampersand: Span
  right: Box<Expression>

ParenthesizedExpression:
  children: [expr]
  span: Span
  start: Span
  expr: Box<Expression>
  end: Span

ErrorSuppressExpression:
  children: [expr]
  span: Span
  at: Span
  expr: Box<Expression>

IncludeExpression:
  children: [path]
  span: Span
  include: Span
  path: Box<Expression>

IncludeOnceExpression:
  children: [path]
  span: Span
  include_once: Span
  path: Box<Expression>

RequireExpression:
  children: [path]
  span: Span
  require: Span
  path: Box<Expression>

RequireOnceExpression:
  children: [path]
  span: Span
  require_once: Span
  path: Box<Expression>

FunctionCallExpression:
  children: [target, arguments]
  span: Span
  target: Box<Expression>
  arguments: ArgumentList

FunctionClosureCreationExpression:
  children: [target, placeholder]
  span: Span
  target: Box<Expression>
  placeholder: ArgumentPlaceholder

MethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  arrow: Span
  method: Box<Expression>
  arguments: ArgumentList

MethodClosureCreationExpression:
  children: [target, method]
  span: Span
  target: Box<Expression>
  arrow: Span
  method: Box<Expression>
  placeholder: ArgumentPlaceholder

NullsafeMethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  question_arrow: Span
  method: Box<Expression>
  arguments: ArgumentList

StaticMethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Identifier
  arguments: ArgumentList

StaticVariableMethodCallExpression:
  children: [target, method, arguments]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Variable
  arguments: ArgumentList

StaticMethodClosureCreationExpression:
  children: [target, method]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Identifier
  placeholder: ArgumentPlaceholder

StaticVariableMethodClosureCreationExpression:
  children: [target, method]
  span: Span
  target: Box<Expression>
  double_colon: Span
  method: Variable
  placeholder: ArgumentPlaceholder

PropertyFetchExpression:
  children: [target, property]
  span: Span
  target: Box<Expression>
  arrow: Span
  property: Box<Expression>

NullsafePropertyFetchExpression:
  children: [target, property]
  span: Span
  target: Box<Expression>
  question_arrow: Span
  property: Box<Expression>

StaticPropertyFetchExpression:
  children: [target, property]
  span: Span
  target: Box<Expression>
  double_colon: Span
  property: Variable

ConstantFetchExpression:
  children: [target, constant]
  span: Span
  target: Box<Expression>
  double_colon: Span
  constant: Identifier

ShortArrayExpression:
  children: [items]
  span: Span
  start: Span
  items: CommaSeparated<ArrayItem>
  end: Span

ArrayExpression:
  children: [items]
  span: Span
  array: Span
  start: Span
  items: CommaSeparated<ArrayItem>
  end: Span

ListExpression:
  children: [items]
  span: Span
  list: Span
  start: Span
  items: Vec<ListEntry>
  end: Span

NewExpression:
  children: [target, arguments?]
  span: Span
  new: Span
  target: Box<Expression>
  arguments: Option<ArgumentList>

InterpolatedStringExpression:
  children: [parts]
  span: Span
  parts: Vec<StringPart>

HeredocExpression:
  children: [parts]
  span: Span
  label: ByteString
  parts: Vec<StringPart>

NowdocExpression:
  span: Span
  label: Token
  value: Token

ShellExecExpression:
  children: [parts]
  span: Span
  parts: Vec<StringPart>

BoolExpression:
  span: Span
  value: Token

ArrayIndexExpression:
  children: [array, index?]
  span: Span
  array: Box<Expression>
  left_bracket: Span
  index: Option<Box<Expression>>
  right_bracket: Span

ShortTernaryExpression:
  children: [condition, r#else]
  span: Span
  condition: Box<Expression>
  question_colon: Span
  r#else: Box<Expression>

TernaryExpression:
  children: [condition, then, r#else]
  span: Span
  condition: Box<Expression>
  question: Span
  then: Box<Expression>
  colon: Span
  r#else: Box<Expression>

CoalesceExpression:
  children: [lhs, rhs]
  span: Span
  lhs: Box<Expression>
  double_question: Span
  rhs: Box<Expression>

CloneExpression:
  children: [target]
  span: Span
  clone: Span
  target: Box<Expression>

MatchExpression:
  children: [condition, arms, default?]
  span: Span
  keyword: Span
  left_parenthesis: Span
  condition: Box<Expression>
  right_parenthesis: Span
  left_brace: Span
  default: Option<Box<DefaultMatchArm>>
  arms: Vec<MatchArm>
  right_brace: Span

ThrowExpression:
  children: [value]
  span: Span
  value: Box<Expression>

YieldExpression:
  children: [key?, value?]
  span: Span
  r#yield: Span
  key: Option<Box<Expression>>
  value: Option<Box<Expression>>

YieldFromExpression:
  children: [value]
  span: Span
  r#yield: Span
  from: Span
  value: Box<Expression>

CastExpression:
  children: [value]
  span: Span
  kind: CastKind
  value: Box<Expression>

DefaultMatchArm:
  children: [body]
  span: Span
  keyword: Span
  double_arrow: Span
  body: Expression

MatchArm:
  children: [conditions, body]
  span: Span
  conditions: Vec<Expression>
  arrow: Span
  body: Expression

MagicConstantExpression:
  span: Span
  kind: MagicConstantKind

MagicConstantKind:
  as: Enum
  node: false
  Directory: ""
  File: ""
  Line: ""
  Function: ""
  Class: ""
  Method: ""
  Namespace: ""
  Trait: ""
  CompilerHaltOffset: ""

StringPart:
  children: [self]
  as: Enum
  Literal: LiteralStringPart
  Expression: ExpressionStringPart

LiteralStringPart:
  span: Span
  value: ByteString

ExpressionStringPart:
  children: [expression]
  span: Span
  expression: Box<Expression>

ArrayItem:
  children: [self]
  as: Enum
  Skipped: Span
  Value: ArrayItemValue
  ReferencedValue: ArrayItemReferencedValue
  SpreadValue: ArrayItemSpreadValue
  KeyValue: ArrayItemKeyValue
  ReferencedKeyValue: ArrayItemReferencedKeyValue

ArrayItemValue:
  children: [value]
  span: Span
  value: Expression

ArrayItemReferencedValue:
  children: [value]
  span: Span
  ampersand: Span
  value: Expression

ArrayItemSpreadValue:
  children: [value]
  span: Span
  ellipsis: Span
  value: Expression

ArrayItemKeyValue:
  children: [key, value]
  span: Span
  key: Expression
  double_arrow: Span
  value: Expression

ArrayItemReferencedKeyValue:
  children: [key, value]
  span: Span
  key: Expression
  double_arrow: Span
  ampersand: Span
  value: Expression

ListEntry:
  children: [self]
  as: Enum
  Skipped: Span
  Value: ListEntryValue
  KeyValue: ListEntryKeyValue

ListEntryValue:
  children: [value]
  span: Span
  value: Expression

ListEntryKeyValue:
  children: [key, value]
  span: Span
  key: Expression
  double_arrow: Span
  value: Expression

PositionalArgument:
  children: [value]
  span: Span
  comments: CommentGroup
  ellipsis: Option<Span>
  value: Expression

NamedArgument:
  children: [name, value]
  span: Span
  comments: CommentGroup
  name: SimpleIdentifier
  colon: Span
  ellipsis: Option<Span>
  value: Expression

Argument:
  children: [self]
  as: Enum
  Positional: PositionalArgument
  Named: NamedArgument

ArgumentList:
  children: [arguments]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  arguments: Vec<Argument>
  right_parenthesis: Span

SingleArgument:
  children: [argument?]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  argument: Option<Argument>
  right_parenthesis: Span

ArgumentPlaceholder:
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  ellipsis: Span
  right_parenthesis: Span

Attribute:
  children: [name, arguments?]
  span: Span
  name: Name
  arguments: Option<ArgumentList>

AttributeGroup:
  children: [members]
  span: Span
  members: Vec<Attribute>

ClassBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

ClassStatement:
  children: [name, extends?, implements?, body]
  span: Span
  attributes: Vec<AttributeGroup>
  modifiers: ClassModifierGroup
  class: Span
  name: Name
  extends: Option<ClassExtends>
  implements: Option<ClassImplements>
  body: ClassBody

AnonymousClassBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

AnonymousClassExpression:
  children: [extends?, implements?, body]
  span: Span
  attributes: Vec<AttributeGroup>
  class: Span
  extends: Option<ClassExtends>
  implements: Option<ClassImplements>
  body: AnonymousClassBody

ClassExtends:
  children: [parent]
  span: Span
  extends: Span
  parent: Name

ClassImplements:
  children: [interfaces]
  span: Span
  implements: Span
  interfaces: CommaSeparated<Name>

ClassishMember:
  children: [self]
  as: Enum
  Constant: ClassishConstant
  TraitUsage: TraitUsage
  Property: Property
  VariableProperty: VariableProperty
  AbstractMethod: AbstractMethod
  AbstractConstructor: AbstractConstructor
  ConcreteMethod: ConcreteMethod
  ConcreteConstructor: ConcreteConstructor
  Missing: MissingClassishMember

MissingClassishMember:
  span: Span

ConstantEntry:
  children: [name, value]
  span: Span
  name: Name
  equals: Span
  value: Expression

ClassishConstantEntry:
  children: [name, value]
  span: Span
  name: SimpleIdentifier
  equals: Span
  value: Expression

ConstantStatement:
  children: [entries]
  span: Span
  comments: CommentGroup
  r#const: Span
  entries: Vec<ConstantEntry>
  semicolon: Span

ClassishConstant:
  children: [attributes, data_type?, entries]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: ConstantModifierGroup
  r#const: Span
  data_type: Option<DataType>
  entries: Vec<ClassishConstantEntry>
  semicolon: Span

IfStatement:
  children: [condition, body]
  span: Span
  r#if: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  body: IfStatementBody

IfStatementBody:
  children: [self]
  as: Enum
  Statement: IfStatementBodyStatement
  Block: IfStatementBodyBlock

IfStatementBodyStatement:
  children: [statement, elseifs, r#else?]
  span: Span
  statement: Box<Statement>
  elseifs: Vec<IfStatementElseIf>
  r#else: Option<IfStatementElse>

IfStatementBodyBlock:
  children: [statements, elseifs, r#else?]
  span: Span
  colon: Span
  statements: Vec<Statement>
  elseifs: Vec<IfStatementElseIfBlock>
  r#else: Option<IfStatementElseBlock>
  endif: Span
  ending: Ending

IfStatementElseIf:
  children: [condition, statement]
  span: Span
  elseif: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  statement: Box<Statement>

IfStatementElse:
  children: [statement]
  span: Span
  r#else: Span
  statement: Box<Statement>

IfStatementElseIfBlock:
  children: [condition, statements]
  span: Span
  elseif: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  colon: Span
  statements: Vec<Statement>

IfStatementElseBlock:
  children: [statements]
  span: Span
  r#else: Span
  colon: Span
  statements: Vec<Statement>

DataType:
  kind: Type<Name>
  span: Span

DeclareEntry:
  children: [key, value]
  span: Span
  key: SimpleIdentifier
  equals: Span
  value: Literal

DeclareEntryGroup:
  children: [entries]
  span: Span
  left_parenthesis: Span
  right_parenthesis: Span
  entries: Vec<DeclareEntry>

DeclareBody:
  children: [self]
  as: Enum
  Noop: DeclareBodyNoop
  Braced: DeclareBodyBraced
  Expression: DeclareBodyExpression
  Block: DeclareBodyBlock

DeclareBodyNoop:
  span: Span
  semicolon: Span

DeclareBodyBraced:
  children: [statements]
  span: Span
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

DeclareBodyExpression:
  children: [expression]
  span: Span
  expression: Expression
  semicolon: Span

DeclareBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  enddeclare: Span
  semicolon: Span

DeclareStatement:
  children: [entries, body]
  span: Span
  declare: Span
  entries: DeclareEntryGroup
  body: DeclareBody

UnitEnumCase:
  children: [attributes, name]
  span: Span
  attributes: Vec<AttributeGroup>
  start: Span
  name: SimpleIdentifier
  end: Span

UnitEnumMember:
  children: [self]
  as: Enum
  Case: UnitEnumCase
  Classish: ClassishMember

UnitEnumBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<UnitEnumMember>
  right_brace: Span

UnitEnumStatement:
  children: [name, implements, body]
  span: Span
  attributes: Vec<AttributeGroup>
  r#enum: Span
  name: Name
  implements: Vec<Name>
  body: UnitEnumBody

BackedEnumCase:
  children: [attributes, name, value]
  span: Span
  attributes: Vec<AttributeGroup>
  case: Span
  name: SimpleIdentifier
  equals: Span
  value: Expression
  semicolon: Span

BackedEnumMember:
  children: [self]
  as: Enum
  Case: BackedEnumCase
  Classish: ClassishMember

BackedEnumBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<BackedEnumMember>
  right_brace: Span

BackedEnumStatement:
  children: [attributes, name, implements, body]
  span: Span
  attributes: Vec<AttributeGroup>
  r#enum: Span
  name: Name
  colon: Span
  backed_type: BackedEnumType
  implements: Vec<Name>
  body: BackedEnumBody

BackedEnumType:
  as: Enum
  node: false
  String: Span
  Int: Span
  Invalid: ''

ReturnType:
  children: [data_type]
  span: Span
  colon: Span
  data_type: DataType

FunctionParameter:
  children: [name, data_type?, default?]
  span: Span
  comments: CommentGroup
  name: SimpleVariable
  attributes: Vec<AttributeGroup>
  data_type: Option<DataType>
  ellipsis: Option<Span>
  default: Option<Expression>
  ampersand: Option<Span>

FunctionParameterList:
  children: [parameters]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  parameters: CommaSeparated<FunctionParameter>
  right_parenthesis: Span

FunctionBody:
  children: [statements]
  span: Span
  comments: CommentGroup
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

FunctionStatement:
  children: [attributes, name, parameters, return_type?, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  function: Span
  ampersand: Option<Span>
  name: Name
  parameters: FunctionParameterList
  return_type: Option<ReturnType>
  body: FunctionBody

ClosureUseVariable:
  children: [variable]
  span: Span
  comments: CommentGroup
  ampersand: Option<Span>
  variable: SimpleVariable

ClosureUse:
  children: [variables]
  span: Span
  comments: CommentGroup
  r#use: Span
  left_parenthesis: Span
  variables: CommaSeparated<ClosureUseVariable>
  right_parenthesis: Span

ClosureExpression:
  children: [attributes, parameters, uses?, return_type?, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  r#static: Option<Span>
  function: Span
  ampersand: Option<Span>
  parameters: FunctionParameterList
  uses: Option<ClosureUse>
  return_type: Option<ReturnType>
  body: FunctionBody

ArrowFunctionExpression:
  children: [attributes, parameters, return_type?, body]
  span: Span
  comments: CommentGroup
  r#static: Option<Span>
  ampersand: Option<Span>
  r#fn: Span
  attributes: Vec<AttributeGroup>
  parameters: FunctionParameterList
  return_type: Option<ReturnType>
  double_arrow: Span
  body: Box<Expression>

ConstructorParameter:
  children: [name, data_type?, default?]
  span: Span
  attributes: Vec<AttributeGroup>
  comments: CommentGroup
  ampersand: Option<Span>
  name: SimpleVariable
  data_type: Option<DataType>
  ellipsis: Option<Span>
  default: Option<Expression>
  modifiers: PromotedPropertyModifierGroup

ConstructorParameterList:
  children: [parameters]
  span: Span
  comments: CommentGroup
  left_parenthesis: Span
  parameters: CommaSeparated<ConstructorParameter>
  right_parenthesis: Span

AbstractConstructor:
  children: [attributes, name, parameters]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: MethodModifierGroup
  function: Span
  ampersand: Option<Span>
  name: SimpleIdentifier
  parameters: ConstructorParameterList
  semicolon: Span

ConcreteConstructor:
  children: [attributes, name, parameters, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: MethodModifierGroup
  function: Span
  ampersand: Option<Span>
  name: SimpleIdentifier
  parameters: ConstructorParameterList
  body: MethodBody

AbstractMethod:
  children: [attributes, name, parameters, return_type?]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: MethodModifierGroup
  function: Span
  ampersand: Option<Span>
  name: SimpleIdentifier
  parameters: FunctionParameterList
  return_type: Option<ReturnType>
  semicolon: Span

ConcreteMethod:
  children: [attributes, name, parameters, return_type?, body]
  span: Span
  comments: CommentGroup
  attributes: Vec<AttributeGroup>
  modifiers: MethodModifierGroup
  function: Span
  ampersand: Option<Span>
  name: SimpleIdentifier
  parameters: FunctionParameterList
  return_type: Option<ReturnType>
  body: MethodBody

MethodBody:
  children: [statements]
  span: Span
  comments: CommentGroup
  left_brace: Span
  statements: Vec<Statement>
  right_brace: Span

LabelStatement:
  children: [label]
  span: Span
  comments: CommentGroup
  label: SimpleIdentifier
  colon: Span

GotoStatement:
  children: [label]
  span: Span
  comments: CommentGroup
  keyword: Span
  label: SimpleIdentifier
  semicolon: Span

Identifier:
  children: [self]
  as: Enum
  SimpleIdentifier: SimpleIdentifier
  DynamicIdentifier: DynamicIdentifier

SimpleIdentifier:
  symbol: ByteString
  span: Span

DynamicIdentifier:
  children: [expr]
  span: Span
  expr: Box<Expression>

InterfaceExtends:
  children: [parents]
  span: Span
  extends: Span
  parents: CommaSeparated<Name>

InterfaceBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

InterfaceStatement:
  children: [attributes, name, extends?, body]
  span: Span
  attributes: Vec<AttributeGroup>
  interface: Span
  name: Name
  extends: Option<InterfaceExtends>
  body: InterfaceBody

Literal:
  span: Span
  kind: LiteralKind
  token: Token

LiteralKind:
  as: Enum
  node: false
  Integer: ""
  Float: ""
  String: ""
  Missing: ""

ForeachStatement:
  children: [iterator, body]
  span: Span
  foreach: Span
  left_parenthesis: Span
  iterator: ForeachStatementIterator
  right_parenthesis: Span
  body: ForeachStatementBody

ForeachStatementIterator:
  children: [self]
  as: Enum
  Value: ForeachStatementIteratorValue
  KeyAndValue: ForeachStatementIteratorKeyAndValue

ForeachStatementIteratorValue:
  children: [expression, value]
  span: Span
  expression: Expression
  r#as: Span
  ampersand: Option<Span>
  value: Expression

ForeachStatementIteratorKeyAndValue:
  children: [expression, key, value]
  span: Span
  expression: Expression
  r#as: Span
  ampersand: Option<Span>
  key: Expression
  double_arrow: Span
  value: Expression

ForeachStatementBody:
  as: Enum
  Statement: ForeachStatementBodyStatement
  Block: ForeachStatementBodyBlock
  
ForeachStatementBodyStatement:
  children: [statement]
  span: Span
  statement: Box<Statement>

ForeachStatementBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  endforeach: Span
  ending: Ending

ForStatement:
  children: [iterator, body]
  span: Span
  r#for: Span
  left_parenthesis: Span
  iterator: ForStatementIterator
  right_parenthesis: Span
  body: ForStatementBody

ForStatementIterator:
  children: [initializations, conditions, r#loop]
  span: Span
  initializations: CommaSeparated<Expression>
  initializations_semicolon: Span
  conditions: CommaSeparated<Expression>
  conditions_semicolon: Span
  r#loop: CommaSeparated<Expression>

ForStatementBody:
  as: Enum
  Statement: ForStatementBodyStatement
  Block: ForStatementBodyBlock

ForStatementBodyStatement:
  children: [statement]
  span: Span
  statement: Box<Statement>

ForStatementBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  endfor: Span
  ending: Ending

DoWhileStatement:
  children: [condition, body]
  span: Span
  r#do: Span
  body: Box<Statement>
  r#while: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  semicolon: Span

WhileStatement:
  children: [condition, body]
  span: Span
  r#while: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  body: WhileStatementBody

WhileStatementBody:
  children: [self]
  as: Enum
  Statement: WhileStatementBodyStatement
  Block: WhileStatementBodyBlock
  
WhileStatementBodyStatement:
  children: [statement]
  span: Span
  statement: Box<Statement>

WhileStatementBodyBlock:
  children: [statements]
  span: Span
  colon: Span
  statements: Vec<Statement>
  endwhile: Span
  ending: Ending

Level:
  as: Enum
  Literal: LiteralLevel
  Parenthesized: ParenthesizedLevel

LiteralLevel:
  literal: Literal

ParenthesizedLevel:
  children: [level]
  span: Span
  left_parenthesis: Span
  level: Box<Level>
  right_parenthesis: Span

BreakStatement:
  children: [level?]
  span: Span
  r#break: Span
  level: Option<Level>
  ending: Ending

ContinueStatement:
  children: [level?]
  span: Span
  r#continue: Span
  level: Option<Level>
  ending: Ending

VisibilityModifier:
  as: Enum
  Public: Span
  Protected: Span
  Private: Span

PromotedPropertyModifier:
  as: Enum
  Public: Span
  Protected: Span
  Private: Span
  Readonly: Span

PromotedPropertyModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<PromotedPropertyModifier>

PropertyModifier:
  as: Enum
  Public: Span
  Protected: Span
  Private: Span
  Static: Span
  Readonly: Span

PropertyModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<PropertyModifier>

MethodModifier:
  as: Enum
  Public: Span
  Protected: Span
  Private: Span
  Static: Span
  Abstract: Span
  Final: Span

MethodModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<MethodModifier>

ClassModifier:
  as: Enum
  Abstract: Span
  Final: Span
  Readonly: Span

ClassModifierGroup:
  derive: Default
  span: Span
  modifiers: Vec<ClassModifier>

ConstantModifier:
  as: Enum
  Public: Span
  Protected: Span
  Private: Span
  Final: Span

ConstantModifierGroup:
  span: Span
  modifiers: Vec<ConstantModifier>

UnbracedNamespace:
  children: [statements]
  span: Span
  start: Span
  name: Name
  end: Span
  statements: Vec<Statement>

BracedNamespace:
  children: [name?, body]
  span: Span
  namespace: Span
  name: Option<Name>
  body: BracedNamespaceBody

BracedNamespaceBody:
  children: [statements]
  span: Span
  start: Span
  end: Span
  statements: Vec<Statement>

NamespaceStatement:
  children: [self]
  as: Enum
  Unbraced: UnbracedNamespace
  Braced: BracedNamespace

ArithmeticOperationExpression:
  children: [kind]
  span: Span
  kind: ArithmeticOperationKind

ArithmeticOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  Addition:
    left: Box<Expression>
    plus: Span
    right: Box<Expression>
  Subtraction:
    left: Box<Expression>
    minus: Span
    right: Box<Expression>
  Multiplication:
    left: Box<Expression>
    asterisk: Span
    right: Box<Expression>
  Division:
    left: Box<Expression>
    slash: Span
    right: Box<Expression>
  Modulo:
    left: Box<Expression>
    percent: Span
    right: Box<Expression>
  Exponentiation:
    left: Box<Expression>
    pow: Span
    right: Box<Expression>
  Negative:
    minus: Span
    right: Box<Expression>
  Positive:
    plus: Span
    right: Box<Expression>
  PreIncrement:
    increment: Span
    right: Box<Expression>
  PostIncrement:
    left: Box<Expression>
    increment: Span
  PreDecrement:
    decrement: Span
    right: Box<Expression>
  PostDecrement:
    left: Box<Expression>
    decrement: Span

AssignmentOperationExpression:
  children: [kind]
  span: Span
  kind: AssignmentOperationKind

AssignmentOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  Assign:
    left: Box<Expression>
    equals: Span
    right: Box<Expression>
  Addition:
    left: Box<Expression>
    plus_equals: Span
    right: Box<Expression>
  Subtraction:
    left: Box<Expression>
    minus_equals: Span
    right: Box<Expression>
  Multiplication:
    left: Box<Expression>
    asterisk_equals: Span
    right: Box<Expression>
  Division:
    left: Box<Expression>
    slash_equals: Span
    right: Box<Expression>
  Modulo:
    left: Box<Expression>
    percent_equals: Span
    right: Box<Expression>
  Exponentiation:
    left: Box<Expression>
    pow_equals: Span
    right: Box<Expression>
  Concat:
    left: Box<Expression>
    dot_equals: Span
    right: Box<Expression>
  BitwiseAnd:
    left: Box<Expression>
    ampersand_equals: Span
    right: Box<Expression>
  BitwiseOr:
    left: Box<Expression>
    pipe_equals: Span
    right: Box<Expression>
  BitwiseXor:
    left: Box<Expression>
    caret_equals: Span
    right: Box<Expression>
  LeftShift:
    left: Box<Expression>
    left_shift_equals: Span
    right: Box<Expression>
  RightShift:
    left: Box<Expression>
    right_shift_equals: Span
    right: Box<Expression>
  Coalesce:
    left: Box<Expression>
    coalesce_equals: Span
    right: Box<Expression>

BitwiseOperationExpression:
  children: [kind]
  span: Span
  kind: BitwiseOperationKind

BitwiseOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  And:
    left: Box<Expression>
    and: Span
    right: Box<Expression>
  Or:
    left: Box<Expression>
    or: Span
    right: Box<Expression>
  Xor:
    left: Box<Expression>
    xor: Span
    right: Box<Expression>
  LeftShift:
    left: Box<Expression>
    left_shift: Span
    right: Box<Expression>
  RightShift:
    left: Box<Expression>
    right_shift: Span
    right: Box<Expression>
  Not:
    not: Span
    right: Box<Expression>

ComparisonOperationExpression:
  children: [kind]
  span: Span
  kind: ComparisonOperationKind

ComparisonOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  Equal:
    left: Box<Expression>
    double_equals: Span
    right: Box<Expression>
  Identical:
    left: Box<Expression>
    triple_equals: Span
    right: Box<Expression>
  NotEqual:
    left: Box<Expression>
    bang_equals: Span
    right: Box<Expression>
  AngledNotEqual:
    left: Box<Expression>
    angled_left_right: Span
    right: Box<Expression>
  NotIdentical:
    left: Box<Expression>
    bang_double_equals: Span
    right: Box<Expression>
  LessThan:
    left: Box<Expression>
    less_than: Span
    right: Box<Expression>
  GreaterThan:
    left: Box<Expression>
    greater_than: Span
    right: Box<Expression>
  LessThanOrEqual:
    left: Box<Expression>
    less_than_equals: Span
    right: Box<Expression>
  GreaterThanOrEqual:
    left: Box<Expression>
    greater_than_equals: Span
    right: Box<Expression>
  Spaceship:
    left: Box<Expression>
    spaceship: Span
    right: Box<Expression>

LogicalOperationExpression:
  children: [kind]
  span: Span
  kind: LogicalOperationKind

LogicalOperationKind:
  children: [self.left!, self.right!]
  as: Enum
  And:
    left: Box<Expression>
    double_ampersand: Span
    right: Box<Expression>
  Or:
    left: Box<Expression>
    double_pipe: Span
    right: Box<Expression>
  Not:
    bang: Span
    right: Box<Expression>
  LogicalAnd:
    left: Box<Expression>
    and: Span
    right: Box<Expression>
  LogicalOr:
    left: Box<Expression>
    or: Span
    right: Box<Expression>
  LogicalXor:
    left: Box<Expression>
    xor: Span
    right: Box<Expression>

Name:
  kind: NameKind
  span: Span

NameKind:
  children: [self]
  as: Enum
  Special: SpecialName
  Unresolved: UnresolvedName
  Resolved: ResolvedName

SpecialName:
  span: Span
  kind: SpecialNameKind
  symbol: ByteString

SpecialNameKind:
  as: Enum
  derive: Copy
  Self_: Span
  Parent: Span
  Static: Span

UnresolvedName:
  span: Span
  symbol: ByteString
  qualification: NameQualification

ResolvedName:
  span: Span
  resolved: ByteString
  original: ByteString

Property:
  children: [attributes, r#type?, entries]
  span: Span
  attributes: Vec<AttributeGroup>
  modifiers: PropertyModifierGroup
  r#type: Option<DataType>
  entries: Vec<PropertyEntry>
  end: Span

VariableProperty: 
  children: [attributes, r#type?, entries]
  span: Span
  attributes: Vec<AttributeGroup>
  r#type: Option<DataType>
  entries: Vec<PropertyEntry>
  end: Span

PropertyEntry:
  children: [kind]
  span: Span
  kind: PropertyEntryKind

PropertyEntryKind:
  as: Enum
  Uninitialized: UninitializedPropertyEntry
  Initialized: InitializedPropertyEntry

UninitializedPropertyEntry:
  children: [variable]
  span: Span
  variable: SimpleVariable

InitializedPropertyEntry:
  children: [variable, value]
  span: Span
  variable: SimpleVariable
  equals: Span
  value: Expression

TraitBody:
  children: [members]
  span: Span
  left_brace: Span
  members: Vec<ClassishMember>
  right_brace: Span

TraitStatement:
  children: [name, attributes, body]
  span: Span
  r#trait: Span
  name: Name
  attributes: Vec<AttributeGroup>
  body: TraitBody

TraitUsage:
  children: [traits, adaptations]
  span: Span
  r#use: Span
  traits: Vec<Name>
  adaptations: Vec<TraitUsageAdaptation>

TraitUsageAdaptation:
  children: [kind]
  span: Span
  kind: TraitUsageAdaptationKind

TraitUsageAdaptationKind:
  as: Enum
  Alias: TraitUsageAdaptationAlias
  Visibility: TraitUsageAdaptationVisibility
  Precedence: TraitUsageAdaptationPrecedence

TraitUsageAdaptationAlias:
  children: [r#trait?, method, alias, visibility?]
  span: Span
  r#trait: Option<Name>
  method: SimpleIdentifier
  alias: SimpleIdentifier
  visibility: Option<VisibilityModifier>

TraitUsageAdaptationVisibility:
  children: [r#trait?, method, visibility]
  span: Span
  r#trait: Option<Name>
  method: SimpleIdentifier
  visibility: VisibilityModifier

TraitUsageAdaptationPrecedence:
  children: [r#trait?, method, insteadof]
  span: Span
  r#trait: Option<Name>
  method: SimpleIdentifier
  insteadof: Vec<SimpleIdentifier>

CatchType:
  children: [kind]
  span: Span
  kind: CatchTypeKind

CatchTypeKind:
  as: Enum
  Identifier: CatchTypeKindIdentifier
  Union: CatchTypeKindUnion

CatchTypeKindIdentifier:
  children: [identifier]
  span: Span
  identifier: SimpleIdentifier

CatchTypeKindUnion:
  children: [identifiers]
  span: Span
  identifiers: Vec<SimpleIdentifier>

TryStatement:
  children: [body, catches, finally?]
  span: Span
  start: Span
  end: Span
  body: Block
  catches: Vec<CatchBlock>
  finally: Option<FinallyBlock>

CatchBlock:
  children: [types, var?, body]
  span: Span
  start: Span
  end: Span
  types: CatchType
  var: Option<SimpleVariable>
  body: Block

FinallyBlock:
  children: [body]
  span: Span
  start: Span
  end: Span
  body: Block

Variable:
  children: [self]
  as: Enum
  SimpleVariable: SimpleVariable
  VariableVariable: VariableVariable
  BracedVariableVariable: BracedVariableVariable

SimpleVariable:
  symbol: ByteString
  stripped: ByteString
  span: Span

VariableVariable:
  children: [variable]
  span: Span
  variable: Box<Variable>

BracedVariableVariable:
  children: [variable]
  span: Span
  start: Span
  variable: Box<Expression>
  end: Span

Ending:
  as: Enum
  node: false
  Missing: Span
  Semicolon: Span
  CloseTag: Span

StaticStatement:
  children: [vars]
  span: Span
  vars: Vec<StaticVar>
  semicolon: Span

SwitchStatement:
  children: [condition, cases]
  span: Span
  switch: Span
  left_parenthesis: Span
  condition: Expression
  right_parenthesis: Span
  cases: Vec<Case>

EchoStatement:
  children: [values]
  span: Span
  echo: Span
  values: Vec<Expression>
  ending: Ending

ReturnStatement:
  children: [value?]
  span: Span
  r#return: Span
  value: Option<Expression>
  ending: Ending

UseStatement:
  children: [uses]
  span: Span
  kind: UseKind
  uses: Vec<Use>

GroupUseStatement:
  children: [prefix, uses]
  span: Span
  prefix: SimpleIdentifier
  kind: UseKind
  uses: Vec<Use>

HaltCompilerStatement:
  span: Span
  content: Option<Token>

StaticVar:
  children: [var, default?]
  span: Span
  var: Variable
  default: Option<Expression>

Comment:
  node: false
  span: Span
  format: CommentFormat
  content: ByteString

CommentFormat:
  as: Enum
  node: false
  SingleLine: ""
  MultiLine: ""
  HashMark: ""
  DocBlock: ""

CommentGroup:
  node: false
  derive: Default
  comments: Vec<Comment>